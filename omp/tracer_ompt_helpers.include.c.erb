#include "thapi_sampling.h"

<% require "yaml" %>

#define _OMPT_SET_CALLBACK(value, name) \
do { \
    const ompt_set_result_t _res = ompt_set_callback(value, (ompt_callback_t) (uintptr_t) name ## _func); \
    if (!verbose) \
        break; \
    switch (_res) { \
    case ompt_set_sometimes: \
    case ompt_set_sometimes_paired: \
        fprintf(stderr, "THAPI Warning: '%s' callback will be called sometimes (error code: %d)\n", #name, _res); \
        break; \
    case ompt_set_error: \
    case ompt_set_never: \
    case ompt_set_impossible: \
        fprintf(stderr, "THAPI Warning: '%s' callback will never be called (error code: %d)\n", #name, _res); \
        break; \
    case ompt_set_always: \
        break; \
    } \
} while (0)

static void _ompt_finalize(ompt_data_t *tool_data) {
    (void) tool_data;
}

static int _ompt_initialize(ompt_function_lookup_t lookup,
                            int initial_device_num,
                            ompt_data_t *tool_data)
{
    (void) initial_device_num;
    (void) tool_data;
    int do_callbacks_emi = 1;
    int do_callbacks_intel = 0;
    int verbose = 0;

    thapi_sampling_init();

    /* TODO: enable when oneAPI updates ompt runtime omp_version
    if (tool_data->value < 202011) {
        // Note: version 202011 is 5.1, where the emi callbacks were added
        do_callbacks_emi = 0;
    }
    */
    if (getenv("LTTNG_UST_OMP_NO_EMI")) {
        do_callbacks_emi = 0;
        if (getenv("LTTNG_UST_OMP_INTEL")) {
            do_callbacks_intel = 1;
        }
    }
    if (getenv("LTTNG_UST_OMP_VERBOSE")) {
        verbose = 1;
    }

    ompt_set_callback_t ompt_set_callback = (ompt_set_callback_t) (uintptr_t) lookup("ompt_set_callback");
    if (ompt_set_callback == NULL)
        return 0;
<% YAML.load_file(File.join(ENV["SRC_DIR"],"ompt_callbacks.yaml")).each do | val, names| %>
  <% if names.size == 1 %>

    _OMPT_SET_CALLBACK(<%= val%>, <%= names.first%>);

  <% elsif names.size == 2 %>

    if (do_callbacks_emi) {
       _OMPT_SET_CALLBACK(<%= names.last%>, <%= names.last%>);
    } else {
       _OMPT_SET_CALLBACK(<%= val%>, <%= names.first%>);
    }

  <% else %>

    if (do_callbacks_intel) {
       // Note: intel callbacks do not have their own enum value!?
       _OMPT_SET_CALLBACK(<%= val%>, <%= names[2]%>);
    } else if (do_callbacks_emi) {
       _OMPT_SET_CALLBACK(<%= names[1] %>, <%= names[1]%>);
    } else {
       _OMPT_SET_CALLBACK(<%= val%>, <%= names[0]%>);
    }

  <% end %>
<% end %>
    return 1;
}

static ompt_start_tool_result_t _ompt_start_tool_result = {&_ompt_initialize, &_ompt_finalize, (ompt_data_t) {.value=0} };

ompt_start_tool_result_t* ompt_start_tool(unsigned int omp_version, const char* runtime_version) {
    (void) runtime_version;
    _ompt_start_tool_result.tool_data.value = omp_version;
    return &_ompt_start_tool_result;
}
