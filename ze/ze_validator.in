#!/usr/bin/env ruby
DATADIR = File.join("@prefix@", "share")
$:.unshift(DATADIR) if File.directory?(DATADIR)
require 'optparse'
require 'babeltrace2'
require 'find'
require 'ze_library'
require 'pp'
require 'set'

# Don't complain about broken pipe
Signal.trap('SIGPIPE', 'SYSTEM_DEFAULT')

$options = { live: false }

OptionParser.new do |opts|
  opts.banner = 'Usage: ze_validator [OPTIONS] trace_directory...'

  opts.on('-h', '--help', 'Prints this help') do
    puts opts
    exit
  end

  opts.on('--live', 'Enable live processing of the trace') do
    $options[:live] = true
  end
end.parse!

ctf_fs = BT2::BTPlugin.find('ctf').get_source_component_class_by_name('fs')
ctf_lttng_live = BT2::BTPlugin.find("ctf").get_source_component_class_by_name("lttng-live")
utils_muxer = BT2::BTPlugin.find('utils').get_filter_component_class_by_name('muxer')

ARGV.uniq!

if !$options[:live]
  trace_locations =
    Find.find(*ARGV).reject do |path|
      FileTest.directory?(path)
    end.select do |path|
      File.basename(path) == 'metadata'
    end.collect do |path|
      File.dirname(path)
    end.select do |path|
      qe = BT2::BTQueryExecutor.new(component_class: ctf_fs, object_name: 'babeltrace.support-info',
                                    params: { 'input' => path, 'type' => 'directory' })
      qe.query.value['weight'] > 0.5
   end
else
  trace_locations = ARGV
end
raise 'Could not find lttng trace' if trace_locations.size == 0

graph = BT2::BTGraph.new

if !$options[:live]
  comp_sources = trace_locations.each_with_index.collect { |trace_location, i| graph.add_component(ctf_fs, "trace_#{i}", params: {"inputs" => [ trace_location ] }) }
else
  comp_sources = trace_locations.each_with_index.collect { |trace_location, i| graph.add_component(ctf_lttng_live, "trace_#{i}", params: {"inputs" => [ trace_location ], "session-not-found-action" => "end" }) }
end

# Muxer
comp_muxer = graph.add_component(utils_muxer, 'mux')

module ZEModel

class Object
  attr_reader :handle

  def initialize(handle)
    @handle = handle
  end
end

class Driver < Object
  attr_reader :devices

  def initialize(handle)
    super
    @devices = []
  end
end

class Device < Object
  attr_reader :properties
  attr_reader :sub_devices

  def initialize(handle)
    super
    @sub_devices = []
  end
end

class SubDevice < Device
  attr_reader :parent

  def initialize(handle, parent)
    @parent = parent
    super(handle)
  end
end

class Context < Object
  attr_reader :driver
  attr_reader :desc
  attr_reader :devices

  attr_reader :event_pools
  attr_reader :command_queues
  attr_reader :command_lists

  def initialize(handle, driver, desc, devices = nil)
    super(handle)
    @driver = driver
    @desc = desc
    @devices = devices

    @event_pools = {}
    @command_queues = {}
    @command_lists = {}
  end
end

class EventPool < Object
  attr_reader :context
  attr_reader :desc
  attr_reader :devices
  attr_reader :events
  attr_reader :indices

  def initialize(handle, context, desc, devices = nil)
    super(handle)
    @context = context
    @desc = desc
    @devices = devices
    @events = {}
    @indices = Set.new(desc[:count].times.to_a)
  end
end

class Event < Object
  attr_reader :event_pool
  attr_reader :desc

  def initialize(handle, event_pool, desc)
    super(handle)
    @event_pool = event_pool
    @desc = desc
  end
end

class CommandQueue < Object
  attr_reader :context
  attr_reader :device
  attr_reader :desc

  def initialize(handle, context, device, desc)
    super(handle)
    @context = context
    @device = device
    @desc = desc
  end
end

class CommandList < Object
  attr_reader :context
  attr_reader :device
  attr_reader :desc
  attr_reader :altdesc

  def initialize(handle, context, device, desc, altdesc)
    super(handle)
    @context = context
    @device = device
    @desc = desc
    @altdesc = altdesc
  end

  def immediate?
    return !desc
  end
end

class ApiCall
  attr_reader :name
  attr_reader :params

  def initialize(name, params)
    @name = name
    @params = params
  end
end

class Thread
  attr_reader :vtid
  attr_accessor :last_entry

  def initialize(vtid)
    @vtid = vtid
    @last_entry = nil
  end
end

class Process
  attr_reader :vpid
  attr_reader :threads

  attr_reader :drivers
  attr_reader :devices
  attr_reader :contexts
  attr_reader :event_pools
  attr_reader :events
  attr_reader :command_queues
  attr_reader :command_lists

  def initialize(vpid)
    @vpid = vpid
    @threads = Hash.new { |h, k| h[k] = Thread.new(k) }

    @drivers = {}
    @devices = {}
    @contexts = {}
    @event_pools = {}
    @events = {}
    @command_queues = {}
    @command_lists = {}
  end
end

class Node
  attr_reader :name
  attr_reader :processes

  def initialize(name)
    @name = name
    @processes = Hash.new { |h, k| h[k] = Process.new(k) }
  end
end

end

STATE = Hash.new { |h, k| h[k] = ZEModel::Node.new(k) }

def get_last_entry(context)
  STATE[context['hostname']].processes[context['vpid']].threads[context['vtid']].last_entry
end

def get_thread(context)
  STATE[context['hostname']].processes[context['vpid']].threads[context['vtid']]
end

def get_process(context)
  STATE[context['hostname']].processes[context['vpid']]
end

def check_last_entry(context)
  last_entry = get_last_entry(context)
  unless last_entry && last_entry.name == context['api']
    raise "Invalid State in #{context['api']}"
  end
end

def set_last_entry(context, defi)
  get_thread(context).last_entry = ZEModel::ApiCall.new(context['api'], defi)
end

def reset_last_entry(context)
  get_thread(context).last_entry = nil
end

def validate_result(defi)
  ZE::ZEResult.from_native(defi["zeResult"], nil) == :ZE_RESULT_SUCCESS
end

def if_validated(defi, &block)
  if validate_result(defi)
    block.call
  end
end

def get_handle_str(handle)
  '0x%016x' % handle
end

def get_proc_context_str(context)
  "#{context['hostname']} - #{context['vpid']}"
end

def get_context_str(context)
  "#{get_proc_context_str(context)} - #{context['vtid']} in #{context['api']}"
end

def print_usage_error(context, str)
  $stderr.puts "Level Zero Usage Error: on #{get_context_str(context)}: #{str}"
end

def pring_crash_error(context, str)
  $stderr.puts "Level Zero Crash Error: on #{get_context_str(context)}: #{str}"
end

def pring_leak_error(context, type, handle)
  $stderr.puts "Level Zero Leak: on #{get_proc_context_str(context)}: #{type} #{get_handle_str(handle)}"
end

def raise_internal_error(context, str)
  raise "Invalid state #{get_context_str(context)}: #{str}"
end

def find_param(context, name)
  get_last_entry(context).params[name]
end

def find_objects(context, type)
  get_process(context).instance_variable_get("@#{type}s")
end

def find_object(context, type, handle)
  handle = find_param(context, handle) if handle.kind_of? String
  find_objects(context, type)[handle]
end

def to_struct(memory, klass)
  memory.size > 0 ? klass.new(FFI::MemoryPointer.from_string(memory)) : nil
end

$exit_lambdas = {}

$exit_lambdas['zeDriverGet'] = lambda { |ctx, defi|
  drivers = get_process(ctx).drivers
  defi['phDrivers_vals'].each { |h|
    drivers[h] = ZEModel::Driver.new(h) unless drivers[h]
  }
}

$exit_lambdas['zeDeviceGet'] = lambda { |ctx, defi|
  devices = find_objects(ctx, 'device')
  driver = find_object(ctx, 'driver', 'hDriver')
  defi['phDevices_vals'].each { |h|
    unless devices[h]
      devices[h] = ZEModel::Device.new(h)
      driver.devices.push devices[h]
    end
  }
}

$exit_lambdas['zeDeviceGetSubDevices'] = lambda { |ctx, defi|
  devices = find_objects(ctx, 'device')
  device = find_object(ctx, 'device', 'hDevice')
  defi['phSubdevices_vals'].each { |h|
    unless devices[h]
      devices[h] = ZEModel::SubDevice.new(h, device)
      device.sub_devices.push devices[h]
    end
  }
}

$exit_lambdas['zeContextCreate'] = lambda { |ctx, defi|
  contexts = find_objects(ctx, 'context')
  driver = find_object(ctx, 'driver', 'hDriver')
  desc_val = find_param(ctx, 'desc_val')
  desc = to_struct(desc_val, ZE::ZEContextDesc)
  handle = defi['phContext_val']
  contexts[handle] = ZEModel::Context.new(handle, driver, desc)
}

$exit_lambdas['zeContextCreateEx'] = lambda { |ctx, defi|
  contexts = find_objects(ctx, 'context')
  devices = find_objects(ctx, 'device')
  driver = find_object(ctx, 'driver', 'hDriver')
  desc_val = find_param(ctx, 'desc_val')
  desc = to_struct(desc_val, ZE::ZEContextDesc)
  devs = find_param(ctx, 'phDevices_vals').collect { |h| devices[h] }
  devs = nil unless find_param(ctx, 'phDevices') != 0
  handle = defi['phContext_val']
  contexts[handle] = ZEModel::Context.new(handle, driver, desc, devs)
}

$exit_lambdas['zeContextDestroy'] = lambda { |ctx, defi|
  contexts = find_objects(ctx, 'context')
  contexts.delete(find_param(ctx, 'hContext')) { |h|
    raise_internal_error(ctx, "context #{get_handle_str(h)} does not exist")
  }
}

$exit_lambdas['zeEventPoolCreate'] = lambda { |ctx, defi|
  context = find_object(ctx, 'context', 'hContext')
  devices = find_objects(ctx, 'device')
  event_pools = find_objects(ctx, 'event_pool')
  desc_val = find_param(ctx, 'desc_val')
  desc = to_struct(desc_val, ZE::ZEEventPoolDesc)
  devs = find_param(ctx, 'phDevices_vals').collect { |h| devices[h] }
  devs = nil unless find_param(ctx, 'phDevices') != 0
  handle = defi['phEventPool_val']
  event_pools[handle] = ZEModel::EventPool.new(handle, context, desc, devs)
  context.event_pools[handle] = event_pools[handle]
}

$exit_lambdas['zeEventPoolDestroy'] = lambda { |ctx, defi|
  event_pools = find_objects(ctx, 'event_pool')
  handle = find_param(ctx, 'hEventPool')
  event_pool = event_pools.delete(handle) {
    raise_internal_error(ctx, "event_pool #{get_handle_str(handle)} does not exist")
  }
  event_pool.context.event_pools.delete(handle) {
    raise_internal_error(ctx, "event_pool #{get_handle_str(handle)} does not exist in context")
  }
  event_pool.events.each { |h, _|
    print_usage_error(ctx, "event #{get_handle_str(h)} was not destroyed prior to event_pool #{get_handle_str(handle)} destruction")
  }
}

$exit_lambdas['zeEventCreate'] = lambda { |ctx, defi|
  events = find_objects(ctx, 'event')
  event_pool = find_object(ctx, 'event_pool', 'hEventPool')
  desc_val = find_param(ctx, 'desc_val')
  desc = to_struct(desc_val, ZE::ZEEventDesc)
  handle = defi['phEvent_val']
  events[handle] = ZEModel::Event.new(handle, event_pool, desc)
  if !event_pool.indices.delete?(desc[:index])
    print_usage_error(ctx, "event_pool #{get_handle_str(event_pool.handle)} index #{desc['index']} is already used")
  end
  event_pool.events[handle] = events[handle]
}

$exit_lambdas['zeEventDestroy'] = lambda { |ctx, defi|
  events = find_objects(ctx, 'event')
  handle = find_param(ctx, 'hEvent')
  event = events.delete(handle) {
    raise_internal_error(ctx, "event #{get_handle_str(handle)} does not exist")
  }
  event_pool = event.event_pool
  event_pool.events.delete(handle) {
    raise_internal_error(ctx, "event #{get_handle_str(handle)} does not exist in event_pool")
  }
  if !event_pool.indices.add?(event.desc[:index])
     print_usage_error(ctx, "event_pool #{get_handle_str(event_pool.handle)} index #{event.desc[:index]} is already freed")
  end
}

$exit_lambdas['zeCommandQueueCreate'] = lambda { |ctx, defi|
  command_queues = find_objects(ctx, 'command_queue')
  context = find_object(ctx, 'context', 'hContext')
  device = find_object(ctx, 'device', 'hDevice')
  desc_val = find_param(ctx, 'desc_val')
  desc = to_struct(desc_val, ZE::ZECommandQueueDesc)
  handle = defi['phCommandQueue_val']
  command_queues[handle] = ZEModel::CommandQueue.new(handle, context, device, desc)
  context.command_queues[handle] = command_queues[handle]
}

$exit_lambdas['zeCommandQueueDestroy'] = lambda { |ctx, defi|
  command_queues = find_objects(ctx, 'command_queue')
  handle = find_param(ctx, 'hCommandQueue')
  command_queue = command_queues.delete(handle) {
    raise_internal_error(ctx, "command_queue #{get_handle_str(handle)} does not exist")
  }
  command_queue.context.command_queues.delete(handle) {
    raise_internal_error(ctx, "command_queue #{get_handle_str(handle)} does not exist in context")
  }
}

$exit_lambdas['zeCommandListCreate'] = lambda { |ctx, defi|
  command_lists = find_objects(ctx, 'command_list')
  context = find_object(ctx, 'context', 'hContext')
  device = find_object(ctx, 'device', 'hDevice')
  desc_val = find_param(ctx, 'desc_val')
  desc = to_struct(desc_val, ZE::ZECommandListDesc)
  handle = defi['phCommandList_val']
  command_lists[handle] = ZEModel::CommandList.new(handle, context, device, desc, nil)
  context.command_lists[handle] = command_lists[handle]
}

$exit_lambdas['zeCommandListCreateImmediate'] = lambda { |ctx, defi|
  command_lists = find_objects(ctx, 'command_list')
  context = find_object(ctx, 'context', 'hContext')
  device = find_object(ctx, 'device', 'hDevice')
  altdesc_val = find_param(ctx, 'altdesc_val')
  altdesc = to_struct(altdesc_val, ZE::ZECommandQueueDesc)
  handle = defi['phCommandList_val']
  command_lists[handle] = ZEModel::CommandList.new(handle, context, device, nil, altdesc)
  context.command_lists[handle] = command_lists[handle]
}

$exit_lambdas['zeCommandListDestroy'] = lambda { |ctx, defi|
  command_lists = find_objects(ctx, 'command_list')
  handle = find_param(ctx, 'hCommandList')
  command_list = command_lists.delete(handle) {
    raise_internal_error(ctx, "command_list #{get_handle_str(handle)} does not exist")
  }
  command_list.context.command_lists.delete(handle) {
    raise_internal_error(ctx, "command_list #{get_handle_str(handle)} does not exist in context")
  }
}

consume = lambda { |iterator, _|
  iterator.next_messages.each do |m|
    next unless m.type == :BT_MESSAGE_TYPE_EVENT
    e = m.event
    m = e.name.match(/:(.*)_(entry|exit)/)
    if m
      hostname = e.stream.trace.get_environment_entry_value_by_name('hostname').value
      context = e.get_common_context_field.value
      defi = e.payload_field.value
      context['hostname'] = hostname
      context['api'] = m[1]

      set_last_entry(context, defi) if m[2] == 'entry'
      if_validated(defi) {
        l = $exit_lambdas[m[1]]
        l.call(context, e.payload_field.value) if l
      }
      if m[2] == 'exit'
        check_last_entry(context)
        reset_last_entry(context)
      end
    end
  end
}
sink = graph.add_simple_sink('babeltrace_thapi', consume)

# Sources to muxer
comp_sources.flat_map(&:output_ports).each_with_index do |op, i|
  ip = comp_muxer.input_port(i)
  graph.connect_ports(op, ip)
end

# Chain the rest
[comp_muxer, sink].flatten.each_cons(2) do |_out, _in|
  op = _out.output_port(0)
  ip = _in.input_port(0)
  graph.connect_ports(op, ip)
end

graph.run

crash = false
STATE.each { |hostname, node|
  node.processes.each { |pid, process|
    process.threads.each { |tid, thread|
      if thread.last_entry
        ctx = {'hostname' => hostname, 'vpid'=> pid, 'vtid' => tid, 'api' => thread.last_entry.name}
        pring_crash_error(ctx, 'command did not finish execution')
        crash = true
      end
    }
  }
}

unless crash && false
  STATE.each { |hostname, node|
    node.processes.each { |pid, process|
      ctx = {'hostname' => hostname, 'vpid'=> pid}
      process.contexts.each { |h, c|
        pring_leak_error(ctx, 'context', h)
      }
      process.command_queues.each { |h, c|
        pring_leak_error(ctx, 'command_queue', h)
      }
      process.command_lists.each { |h, c|
        pring_leak_error(ctx, 'command_list', h)
      }
    }
  }
end
