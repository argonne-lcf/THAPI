#include <ze_api.h>
#include <ze_ddi.h>
#include <zet_api.h>
#include <zet_ddi.h>
#include <zes_api.h>
#include <zes_ddi.h>
#include "babeltrace2/babeltrace.h"
#include "babeltrace_ze.h"
#include "xprof_utils.h"
#include <iomanip>
#include <vector>
#include <algorithm>
#include <iostream>
#include <unordered_map>
#include <tuple>
#include <climits>
#include "zeprof_callbacks.h"
#include <set>

/* Callback */

typedef std::tuple<hostname_t, process_id_t, ze_event_handle_t> hp_event_t;
typedef std::tuple<hostname_t, process_id_t, ze_kernel_handle_t> hp_kernel_t;

typedef std::tuple<hostname_t, process_id_t, ze_command_list_handle_t> hp_command_list_t; 
typedef std::tuple<hostname_t, process_id_t, ze_command_queue_handle_t> hp_command_queue_t;


typedef std::tuple<uint64_t, uint64_t> timerResolution_kernelTimestampValidBits_t;


std::unordered_map<hpt_t, thapi_function_name> last_command;
std::unordered_map<hpt_t, thapi_function_name> last_kernel;

std::unordered_map<hp_t, ze_device_handle_t> last_device;
std::unordered_map<hp_t, ze_command_queue_handle_t> last_command_queue;

std::unordered_map<hpt_function_name_t, ze_device_handle_t> function_name_to_device;
std::unordered_map<hp_event_t,t_function_name_t> event_to_function_name;

std::unordered_map<hp_event_t, uint64_t> event_result_to_delta;
std::unordered_map<hp_kernel_t, std::string> kernel_to_name;


std::unordered_map<hp_command_list_t, dsd_t> command_list_to_device;

std::unordered_map<hp_device_t, timerResolution_kernelTimestampValidBits_t> device_to_timerResolution_kernelTimestampValidBits;

<%# Rely on global variable device_to_timerResolution_kernelTimestampValidBits %>
inline uint64_t born_timing_to_ns(hp_device_t hp_device, uint64_t start, uint64_t end) {
    const auto [timerResolution,kernelTimestampValidBits] =  device_to_timerResolution_kernelTimestampValidBits[hp_device];
    if (end >= start) {
        return (end - start) * timerResolution;
    } else {
       <%# We cycle (don't know how many time. Lets assume one) %>
       const uint64_t max_val = (1 << kernelTimestampValidBits) - 1;
       return (max_val - start + end ) * timerResolution;
    }
}

<% $dbt_events.each do | dbt_event | %>
static void zeprof_<%= dbt_event.uuid %>_callback(
   <%= dbt_event.fields.join(",\n  ") %>
){
  <%#                             ___      _
       |   _   _  _. | o _|_       |  ._ _|_ _
       |_ (_) (_ (_| | |  |_ \/   _|_ | | | (_)
                             /
  %>
  <%if dbt_event.namespace == :'lttng_ust_ze' or  dbt_event.namespace == :lttng_ust_zet %>
    const hostname_t   hostname   = borrow_hostname(bt_evt);
    const process_id_t process_id = borrow_process_id(bt_evt);
    const thread_id_t  thread_id  = borrow_thread_id(bt_evt);
  <%end %>
   
  <%#        _ ___
        /\  |_) |     _  _. | |  _
       /--\ |  _|_   (_ (_| | | _>
  %>
  <%if dbt_event.namespace == :lttng_ust_ze or  dbt_event.namespace == :lttng_ust_zet %>
  int64_t ns_from_origin; 
  bt_clock_snapshot_get_ns_from_origin(bt_clock, &ns_from_origin);
     <%if dbt_event.suffix == :start %>
  api_call[hpt_function_name_t(hostname,process_id, thread_id, "<%= dbt_event.name %>")].start(ns_from_origin);
     <%elsif dbt_event.suffix == :stop %>
  api_call[hpt_function_name_t(hostname,process_id, thread_id, "<%= dbt_event.name %>")].stop(ns_from_origin);
        <% if dbt_event.include?('zeResult') %>
    if (zeResult != 0)
        api_call[hpt_function_name_t(hostname,process_id, thread_id, "<%= dbt_event.name %>")].set_error();
        <% end %>
     <%end%>
  <%end%>  

  <%#
       |\/|  _  ._ _   _  ._      _.  _  _  _   _  _  _   _
       |  | (/_ | | | (_) | \/   (_| (_ (_ (/_ _> _> (/_ _>
                            /
  %>
  <% if (dbt_event.name.include?("Alloc") or dbt_event.name.include?("Memory")) and  dbt_event.include? ("size_t size") %>
    memory_trafic[hpt_function_name_t(hostname,process_id, thread_id, "<%= dbt_event.name %>")].delta(size);
  <% end %>

  <%#
    _         _                    _                                   __          _
   |_) ._ _ _|_ o | o ._   _  o   | \  _     o  _  _     _. ._   _|   (_      |_  | \  _     o  _  _
   |   | (_) |  | | | | | (_| o   |_/ (/_ \/ | (_ (/_   (_| | | (_|   __) |_| |_) |_/ (/_ \/ | (_ (/_
                           _|
   Map [ Tuple [ Hostnane, process, cl_command_queue ], Tuple [ device, subdevice] ]
  %>

  <%# Map [ Tuple [hostname, process, device_or_subdevice], device] ] %>
  <% if  dbt_event.name == 'zeDeviceGet' and dbt_event.suffix == :stop %>
    if (phDevices_vals != nullptr) {  
        for (unsigned int i=0; i < pCount_val; i++ ) {
            const thapi_device_id d = (thapi_device_id) phDevices_vals[i];
            device_to_rootdevice[hp_device_t(hostname,process_id, d) ] = d;
        }
    }
  <% elsif dbt_event.name == "zeDeviceGetSubDevices" and dbt_event.suffix == :start %>
    start_device[hpt_t(hostname,process_id,thread_id) ] =  (thapi_device_id) hDevice;
  <% elsif dbt_event.name == "zeDeviceGetSubDevices" and dbt_event.suffix == :stop %>
    const thapi_device_id device = start_device[hpt_t(hostname,process_id,thread_id) ];
    const thapi_device_id root_device = device_to_rootdevice[hp_device_t(hostname,process_id, device) ];
    if (phSubdevices_vals != nullptr) {  
        for (unsigned int i=0; i < pCount_val; i++ ) {
            const thapi_device_id d = (thapi_device_id) phSubdevices_vals[i];
            device_to_rootdevice[hp_device_t(hostname,process_id, d) ] = root_device;
        }
    }
  <% end %>

  <%# Map [ Tuple [ Hostnane, process, cl_command_queue ], Tuple [ device, subdevice] ] %>
  <% if ['zeCommandListCreate','zeCommandListCreateImmediate'].include? dbt_event.name and dbt_event.suffix == :start %>
    start_device[hpt_t(hostname,process_id,thread_id) ] =  (thapi_device_id) hDevice;
  <%elsif ['zeCommandListCreate','zeCommandListCreateImmediate'].include? dbt_event.name and dbt_event.suffix == :stop %>
    const thapi_device_id device = start_device[hpt_t(hostname,process_id,thread_id) ];
    const thapi_device_id root_device = device_to_rootdevice[hp_device_t(hostname,process_id, device) ];
    command_list_to_device[hp_command_list_t(hostname,process_id,phCommandList_val)]=  dsd_t(root_device, device);
  <% end %>
  
  <%#
    _         _                    _
   |_) ._ _ _|_ o | o ._   _  o   |_    ._   _ _|_ o  _  ._    ._   _. ._ _   _
   |   | (_) |  | | | | | (_| o   | |_| | | (_  |_ | (_) | |   | | (_| | | | (/_
                           _|
   Map [ Tuple [ Hostnane, process, thread, function_name], Tuple [ device, subdevice] ]
  %>
  <%# Save kernel name %>
    <% if dbt_event.lltng == "lttng_ust_ze:zeKernelCreate_#{START}" %>
    last_kernel[hpt_t(hostname,process_id,thread_id)] = std::string{desc__pKernelName_val};
     <% elsif dbt_event.lltng == "lttng_ust_ze:zeKernelCreate_#{STOP}" %>
    kernel_to_name[hp_kernel_t(hostname,process_id,phKernel_val)] =  last_kernel[hpt_t(hostname,process_id,thread_id)];
 <% end %>
 <% if dbt_event.suffix == :start and  dbt_event.include? "hSignalEvent" %>
        <%if  dbt_event.include? " hKernel" %>
    const thapi_function_name name  = kernel_to_name[hp_kernel_t(hostname,process_id,hKernel)];
        <% else %>
    constexpr char name[] = "<%= dbt_event.name %>";
        <% end %>
    profiled_function_name[hpt_t(hostname,process_id,thread_id)] = name;
        <% if dbt_event.suffix == :start and dbt_event.include? 'hCommandList' %>
    function_name_to_dsd[hpt_function_name_t(hostname,process_id,thread_id,name)] = command_list_to_device[hp_command_list_t(hostname,process_id,hCommandList)];
        <% end %>
 <% end %>
    
  <%#
    _         _                    _                        ___
   |_) ._ _ _|_ o | o ._   _  o   |_ |  _. ._   _  _   _|    | o ._ _   _   _
   |   | (_) |  | | | | | (_| o   |_ | (_| |_) _> (/_ (_|    | | | | | (/_ _>
                           _|              |
   Map [ Tuple[hostname, process, device, subdevice, cl_function_name], elapsed_time ]
  %>
  
  <%# Getting timer resultion of each device %>
  <%if dbt_event.lltng == "lttng_ust_ze_properties:device" %>
   const hostname_t hostname    = borrow_hostname(bt_evt);
   const process_id_t process_id = borrow_process_id(bt_evt);
   const auto t = timerResolution_kernelTimestampValidBits_t( pDeviceProperties_val -> timerResolution, 64);
   device_to_timerResolution_kernelTimestampValidBits[hp_device_t(hostname,process_id, (thapi_device_id) hDevice)] = t ;

  <%elsif dbt_event.lltng == "lttng_ust_ze_profiling:event_profiling" %>
   const hostname_t hostname    = borrow_hostname(bt_evt);
   const process_id_t process_id = borrow_process_id(bt_evt);
   const thread_id_t thread_id   = borrow_thread_id(bt_evt);
   const hp_event_t hp_event{hostname,process_id, hEvent};
   const thapi_function_name function_name = profiled_function_name[hpt_t(hostname,process_id,thread_id)];
   if (!event_to_function_name.count(hp_event)){
      event_to_function_name[hp_event] = t_function_name_t(thread_id, function_name);
   } else {
      const uint64_t delta = event_result_to_delta[hp_event];
      const auto [device,subdevice] = function_name_to_dsd[hpt_function_name_t(hostname,process_id,thread_id, function_name)];
      if (delta != 0)
             device_id_result[hpt_device_function_name_t(hostname,process_id,thread_id, device, subdevice, function_name)].delta(delta);
      event_to_function_name.erase(hp_event);
   }
  <% elsif dbt_event.lltng == "lttng_ust_ze_profiling:event_profiling_results" %>
   const std::string hostname    = borrow_hostname(bt_evt);
   const process_id_t process_id = borrow_process_id(bt_evt);
   const hp_event_t hp_event{hostname,process_id, hEvent};

   if (event_to_function_name.count(hp_event)) {
     const auto [thread_id,function_name] =  event_to_function_name[hp_event];
     const auto [device,subdevice] = function_name_to_dsd[hpt_function_name_t(hostname,process_id,thread_id, function_name)];
     const uint64_t delta = born_timing_to_ns(hp_device_t(hostname,process_id, device),contextStart,contextEnd);
     if (delta != 0)
        device_id_result[hpt_device_function_name_t(hostname,process_id,thread_id, device, subdevice, function_name)].delta(delta);
 
     event_to_function_name.erase(hp_event);
   } else {
     <%# Not sure about this one. Need to see when we have native callbacks %>
     const thread_id_t thread_id   = borrow_thread_id(bt_evt);
     const thapi_function_name function_name = profiled_function_name[hpt_t(hostname,process_id,thread_id)];
     
     const auto [device,subdevice] = function_name_to_dsd[hpt_function_name_t(hostname,process_id,thread_id, function_name)];
     const uint64_t delta = born_timing_to_ns(hp_device_t(hostname,process_id, device),contextStart,contextEnd);
     (void)subdevice;
     event_result_to_delta[hp_event]= delta;
     event_to_function_name[hp_event] = t_function_name_t(thread_id, function_name);
  }
  <% end %>
};
<% end %>

<%#
 ___
  |  ._  o _|_ o  _. | o _   _
 _|_ | | |  |_ | (_| | | /_ (/_

%>

void init_callbacks(struct ze_dispatch   *ze_dispatch) {
<% $dbt_events.each do | dbt_event| %>
  ze_register_callback(ze_dispatch, "<%= dbt_event.lltng %>", (void *) &zeprof_<%= dbt_event.uuid %>_callback);
<% end %>
}

<%#
  _
 |_ o ._   _. | o _   _
 |  | | | (_| | | /_ (/_

%>

void finalize_callbacks() {
   std::string display {bt_value_string_get(display_mode)};
   if (display == "compact" ) {
  <% ['api_call','device_id_result','memory_trafic'].each do |a| %>
    print_compact_<%= a %>();
  <% end %>
   } else if (display == "extended" ) {
  <% ['api_call','device_id_result','memory_trafic'].each do |a| %>
     print_extented_<%= a %>();
  <% end %>
   }
}
