#include <iomanip>
#include <iostream>
#include "babeltrace_zeinterval.h"
#include "zeinterval_callbacks.hpp"
#include "xprof_utils.hpp"
#include <babeltrace2/babeltrace.h>

#include <ze_api.h>
#include <ze_ddi.h>
#include <zet_api.h>
#include <zet_ddi.h>
#include <zes_api.h>
#include <zes_ddi.h>
#include <zel_tracepoints.h>

#include <vector>
#include <algorithm>
#include <iostream>
#include <unordered_map>
#include <tuple>
#include <climits>
#include <set>
#include <assert.h>     /* assert */

<%# Should pass device_to_timerResolution_kernelTimestampValidBits %>
static inline uint64_t corrected_l1(const uint64_t d1, const uint64_t l0, const uint64_t d0, const uint64_t l1_min, const uint64_t valid_bits) {
    /*
    d1 is the device time we want to convert to the lttng time (l1)
    l0 and d0 are a lttng and device timestamp who are synchronized
    l1_min is the minimun approximation of l1

    lttng timer (l*) is assumed to be monotonic, where the device term can overflow and loop arround
    */

    const int64_t l1_nocycle = d1 + l0 - d0;
    return l1_nocycle;

    assert (valid_bits <= 64);
    const uint64_t max_val = (uint64_t) 1 << valid_bits;
    const unsigned n = ( (l1_min - l1_nocycle) >> valid_bits ) + 1 ;
    return max_val*n + l1_nocycle;
}

static inline uint64_t elapsed_time_ns(zeinterval_callbacks_state* state, hp_device_t hp_device, uint64_t start, uint64_t end) {
    static bool is_ns = true;
    uint64_t timerResolution = 1;
    uint64_t kernelTimestampValidBits = 32;
    auto map = state->device_to_timerResolution_kernelTimestampValidBits;
    auto it = map.find(hp_device);
    if (it == map.end()) {
        if (is_ns) {
            std::cerr << "No timerResolution have been found for a device. "
                      << "Data will be displayed as cycles." << std::endl;
            is_ns = false;
        }
    } else {
        const auto [timerResolution_,kernelTimestampValidBits_] = it->second;
        timerResolution = timerResolution_;
        kernelTimestampValidBits = kernelTimestampValidBits_;
    }
    if (end >= start) {
        return (end - start) * timerResolution;
    } else {
       <%# We cycle (don't know how many time. Lets assume one) %>
       const uint64_t max_val = ((uint64_t) 1 << kernelTimestampValidBits) - 1;
       return (max_val - start + end ) * timerResolution;
    }
}

static inline uint64_t start_time_ns(zeinterval_callbacks_state* state, hp_device_t hp_device, uint64_t start, uint64_t born_min) {

    static bool WarningOnce= true;

    auto map_sync = state->sync_clock_lttng_device;
    auto it_sync = map_sync.find(hp_device);

    auto map_timer = state->device_to_timerResolution_kernelTimestampValidBits;
    auto it_timer = map_timer.find(hp_device);

    if (it_timer != map_timer.end() && it_sync != map_sync.end()) {
        const auto [l0,d0] = it_sync->second;
        const auto [_timerResolution, _kernelTimestampValidBits] = it_timer->second;
        const uint64_t start_ns = start * _timerResolution;
        return corrected_l1(start_ns, l0, d0, born_min, _kernelTimestampValidBits);
    } else {
        if (WarningOnce) {
            std::cerr << "THAPI::Warning No host-device clock synchronization have been found. "
                      << "Kernel start time will be a lowerbound"<< std::endl;
            WarningOnce = false;
        }
        return born_min;
    }
}

// Hash UUID
uintptr_t hash_device(zeinterval_callbacks_state* state, const hostname_t hostname, thapi_device_id device) {
    if (!device)
        return 0;

    auto device_uuid = state->device_to_uuid[h_device_t(hostname, device)];

    // Right now we store `ptr` and not `uuid`.
    // we cast `uiid` to `ptr`. This should to the oposite
    uintptr_t device_uuid_hash[2];
    memcpy(&device_uuid_hash[0], &device_uuid, sizeof(device_uuid));
    device_uuid_hash[0]+= device_uuid_hash[1];
    return device_uuid_hash[0];
}

void *init_zeinterval_callbacks_state() {
    zeinterval_callbacks_state *s = new zeinterval_callbacks_state;
    return (void*) s;
}

static void create_and_enqueue_host_message(const char* hostname, const process_id_t process_id, const thread_id_t thread_id, const char* name,
                                            const uint64_t ts, const uint64_t duration, const bool err) {

     /* Message creation */
     bt_message *message = create_host_message(hostname, process_id, thread_id, name, ts, duration, err,
                            zeinterval_iter_g->dispatch->host_event_class,
                            zeinterval_self_message_iterator_g,
                            zeinterval_iter_g->dispatch->stream);

     zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;
     state->downstream_message_queue.push(message);
}

void create_and_enqueue_device_message(const char* hostname, const process_id_t process_id, const thread_id_t thread_id,
                                       const thapi_device_id device_id, const thapi_device_id subdevice_id,
                                       const char* name, const uint64_t ts, const uint64_t duration, const bool err, const char* metadata) {

     /* Message creation */
     bt_message *message = create_device_message(hostname, process_id, thread_id, device_id, subdevice_id, name, ts, duration, err, metadata,
                            zeinterval_iter_g->dispatch->device_event_class,
                            zeinterval_self_message_iterator_g,
                            zeinterval_iter_g->dispatch->stream);


     /* Set message */
     zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;
     state->downstream_message_queue.push(message);
}

static void create_and_enqueue_traffic_message(const char* hostname, const process_id_t process_id, const thread_id_t thread_id, const char* name,
                                               const uint64_t size) {

     /* Message creation */
     bt_message *message = create_traffic_message(hostname, process_id, thread_id, name, size,
                                                  zeinterval_iter_g->dispatch->traffic_event_class,
                                                  zeinterval_self_message_iterator_g,
                                                  zeinterval_iter_g->dispatch->stream);

     zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;
     state->downstream_message_queue.push(message);
}

<%#
  _                                         _                          _ ___
 | \  _       ._   _ _|_ ._ _   _. ._ _    / \      _       _     /\  |_) |
 |_/ (_) \/\/ | | _>  |_ | (/_ (_| | | |   \_X |_| (/_ |_| (/_   /--\ |  _|_

%>

bool zeinterval_downstream_message_queue_empty(struct zeinterval_message_iterator *interval_dispatch_iter)
{
    zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) interval_dispatch_iter->callbacks_state;
    return state->downstream_message_queue.empty();
}

size_t zeinterval_downstream_message_queue_size(struct zeinterval_message_iterator *interval_dispatch_iter)
{
    zeinterval_callbacks_state* state = (zeinterval_callbacks_state*)  interval_dispatch_iter->callbacks_state;
    return state->downstream_message_queue.size();
}

const bt_message* zeinterval_downstream_message_queue_pop(struct zeinterval_message_iterator *interval_dispatch_iter)
{
    zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) interval_dispatch_iter->callbacks_state;
    const bt_message* m = state->downstream_message_queue.front();
    state->downstream_message_queue.pop();
    return m;
}

void zeinterval_downstream_message_queue_push(struct zeinterval_message_iterator *interval_dispatch_iter, const bt_message *message)
{
    zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) interval_dispatch_iter->callbacks_state;
    state->downstream_message_queue.push(message);
}

<%#
                    ___
   |\/|  _  ._ _     |  ._ _|_  _  ._    _. |
   |  | (/_ | | |   _|_ | | |_ (/_ | \/ (_| |

%>

void remove_memory(zeinterval_callbacks_state* state, hp_t hp, const uintptr_t ptr) {

    auto &rs = state->rangeset_memory_shared[hp];
    auto its = rs.find(ptr);
    if (its != rs.end()) {
         rs.erase(its);
         return;
    }
    auto &rd = state->rangeset_memory_device[hp];
    auto itd = rd.find(ptr);
    if (itd != rd.end()) {
         rd.erase(itd);
         return;
    }

    auto &rh = state->rangeset_memory_host[hp];
    auto ith = rh.find(ptr);
    if (ith != rh.end()) {
         rh.erase(ith);
         return;
    }

    return;
}

const char* memory_location(zeinterval_callbacks_state* state, hp_t hp, const uintptr_t ptr) {
    const auto &rs = state->rangeset_memory_shared[hp];
    if (contains(rs, ptr))
        return "S";

    const auto &rd = state->rangeset_memory_device[hp];
    if (contains(rd, ptr))
        return "D";

    const auto &rh = state->rangeset_memory_host[hp];
    if (contains(rh, ptr))
        return "H";

    return "M";
}

<%#
  _
 /   _. | | |_   _.  _ |   _
 \_ (_| | | |_) (_| (_ |< _>

%>

<% $dbt_events.each do | dbt_event | %>
static void zeinterval_<%= dbt_event.name %>_callback(
   <%= dbt_event.callback_signature %>
){
  <%#                             ___      _
       |   _   _  _. | o _|_       |  ._ _|_ _
       |_ (_) (_ (_| | |  |_ \/   _|_ | | | (_)
                             /
  %>
  <%if dbt_event.name_unsanitized.start_with?('lttng_ust_ze:')  or
       dbt_event.name_unsanitized.start_with?('lttng_ust_zet:') or
       dbt_event.name_unsanitized.start_with?('lttng_ust_zes:') or
       dbt_event.name_unsanitized.start_with?('lttng_ust_zel:')  %>

    const hostname_t   hostname   = borrow_hostname(bt_evt);
    const process_id_t process_id = borrow_process_id(bt_evt);
    const thread_id_t  thread_id  = borrow_thread_id(bt_evt);
    zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;
  <%end %>

  <%#        _ ___
        /\  |_) |     _  _. | |  _
       /--\ |  _|_   (_ (_| | | _>
  %>
  <%if dbt_event.name_unsanitized.start_with?('lttng_ust_ze:')  or
       dbt_event.name_unsanitized.start_with?('lttng_ust_zet:') or
       dbt_event.name_unsanitized.start_with?('lttng_ust_zes:') or
       dbt_event.name_unsanitized.start_with?('lttng_ust_zel:')  %>
    int64_t ns_from_origin;
    bt_clock_snapshot_get_ns_from_origin(bt_clock, &ns_from_origin);
    <%if dbt_event.name_unsanitized.end_with?(START) %>
    state->host_start[hpt_function_name_t(hostname,process_id, thread_id, "<%= dbt_event.name_striped %>")] = ns_from_origin;
    <%elsif dbt_event.name_unsanitized.end_with?(STOP) %>
    uint64_t &start_g = state->host_start.at(hpt_function_name_t(hostname,process_id, thread_id, "<%= dbt_event.name_striped %>"));
     <% if dbt_event.fields_name.include?('zeResult') %>
       <%# In level0 1.0-rev-3  only those use `ZE_RESULT_NOT_READY` %>
       <% if dbt_event.name_striped.include? ('Synchronize') or dbt_event.name_striped.include? ('Query')  %>
    create_and_enqueue_host_message(hostname.c_str(), process_id, thread_id, "<%= dbt_event.name_striped %>", start_g, ns_from_origin-start_g, zeResult != ZE_RESULT_SUCCESS && zeResult != ZE_RESULT_NOT_READY);
       <% else %>
    create_and_enqueue_host_message(hostname.c_str(), process_id, thread_id, "<%= dbt_event.name_striped %>", start_g, ns_from_origin-start_g, zeResult);
       <% end %>
     <% else %>
    create_and_enqueue_host_message(hostname.c_str(), process_id, thread_id, "<%= dbt_event.name_striped %>", start_g, ns_from_origin-start_g, 0);
     <% end %>
    start_g = 0;
   <%end%>
  <%end%>

  <%#
       |\/|  _  ._ _   _  ._      _.  _  _  _   _  _  _   _
       |  | (/_ | | | (_) | \/   (_| (_ (_ (/_ _> _> (/_ _>
                            /
  %>
  <% if ['zeMemAllocHost','zeMemAllocDevice','zeMemAllocShared'].include? dbt_event.name_striped and dbt_event.name_unsanitized.end_with?(START) %>
    state->last_alloc[hpt_t(hostname.c_str(),process_id,thread_id)] = size;
  <% end %>

  <% if dbt_event.name_striped == "zeMemAllocHost" and dbt_event.name_unsanitized.end_with?(STOP) %>
    if ( zeResult == ZE_RESULT_SUCCESS ) {
        const auto size = state->last_alloc[hpt_t(hostname.c_str(),process_id,thread_id)];
        state->rangeset_memory_host[hp_t(hostname.c_str(), process_id)][(uintptr_t) pptr_val] = ((uintptr_t) (pptr_val) + size);
    }
  <% end %>

  <% if dbt_event.name_striped == "zeMemAllocDevice" and dbt_event.name_unsanitized.end_with?(STOP) %>
    if ( zeResult == ZE_RESULT_SUCCESS ) {
        const auto size = state->last_alloc[hpt_t(hostname.c_str(),process_id,thread_id)];
        state->rangeset_memory_device[hp_t(hostname.c_str(), process_id)][(uintptr_t) pptr_val] = ((uintptr_t) (pptr_val) + size);
    }
  <% end %>

  <% if dbt_event.name_striped == "zeMemAllocShared" and dbt_event.name_unsanitized.end_with?(STOP) %>
    if ( zeResult == ZE_RESULT_SUCCESS ) {
        const auto size = state->last_alloc[hpt_t(hostname.c_str(),process_id,thread_id)];
        state->rangeset_memory_shared[hp_t(hostname.c_str(), process_id)][(uintptr_t) pptr_val] = ((uintptr_t) (pptr_val) + size);
    }
  <% end %>

  <% if dbt_event.name_striped == "zeMemFree" and dbt_event.name_unsanitized.end_with?(START) %>
    state->last_free[hpt_t(hostname.c_str(),process_id,thread_id)] = (uintptr_t) ptr;
  <% end %>
  <% if dbt_event.name_striped == "zeMemFree" and dbt_event.name_unsanitized.end_with?(STOP) %>
    if ( zeResult == ZE_RESULT_SUCCESS ) {
        const auto ptr = state->last_free[hpt_t(hostname.c_str(),process_id,thread_id)];
        remove_memory(state, hp_t(hostname.c_str(), process_id), ptr);
    }
  <% end %>

  <%#  ___                                    __         _
        | o ._ _   _   _ _|_  _. ._ _  ._    (_  |_  o _|_ _|_
        | | | | | (/_ _>  |_ (_| | | | |_)   __) | | |  |   |_
                                     |
  %>
  <%if dbt_event.name_unsanitized == "lttng_ust_ze_properties:device_timer"  %>
    const hostname_t  hostname{borrow_hostname(bt_evt)};
    const process_id_t process_id = borrow_process_id(bt_evt);
    zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;

    int64_t ns_from_origin;
    bt_clock_snapshot_get_ns_from_origin(bt_clock, &ns_from_origin);

    hp_device_t hp_device{hostname, process_id, (thapi_device_id) hDevice};

    auto map = state->device_to_timerResolution_kernelTimestampValidBits;
    auto it = map.find(hp_device);

    if (it != map.end()) {
        const auto [_timerResolution, _kernelTimestampValidBits] = it->second;
        const uint64_t mask = ((uint64_t) 1 << _kernelTimestampValidBits) - 1;
        state->sync_clock_lttng_device[hp_device] = clock_lttng_device_t{ns_from_origin, (deviceTimestamp & mask )*_timerResolution};
    }
  <% end %>

  <%#
    _         _                    _                                   __          _
   |_) ._ _ _|_ o | o ._   _  o   | \  _     o  _  _     _. ._   _|   (_      |_  | \  _     o  _  _
   |   | (_) |  | | | | | (_| o   |_/ (/_ \/ | (_ (/_   (_| | | (_|   __) |_| |_) |_/ (/_ \/ | (_ (/_
                           _|
   Map [ Tuple [ Hostnane, process, cl_command_queue ], Tuple [ device, subdevice] ]
  %>

  <%# Save devices information. Device UUID and device timer resolution %>
  <%if dbt_event.name_unsanitized == "lttng_ust_ze_properties:device" %>
   zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;
   const hostname_t hostname    = borrow_hostname(bt_evt);
   const process_id_t process_id = borrow_process_id(bt_evt);
   const auto t = timerResolution_kernelTimestampValidBits_t( pDeviceProperties_val->timerResolution, pDeviceProperties_val->kernelTimestampValidBits);
   state->device_to_timerResolution_kernelTimestampValidBits[hp_device_t(hostname,process_id, (thapi_device_id) hDevice)] = t ;
   state->device_to_uuid[h_device_t(hostname, (thapi_device_id) hDevice) ] = pDeviceProperties_val->uuid ;


  <%elsif dbt_event.name_unsanitized == "lttng_ust_ze_properties:subdevice" %>
   zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;
   const hostname_t hostname    = borrow_hostname(bt_evt);
   const process_id_t process_id = borrow_process_id(bt_evt);
   const auto t = timerResolution_kernelTimestampValidBits_t( pDeviceProperties_val->timerResolution, pDeviceProperties_val->kernelTimestampValidBits);

   state->device_to_timerResolution_kernelTimestampValidBits[hp_device_t(hostname,process_id, (thapi_device_id) hSubDevice)] = t ;
   //Need to pach UUID to be at least different between tile...
   state->device_to_uuid[h_device_t(hostname, (thapi_device_id) hSubDevice) ] = pDeviceProperties_val->uuid ;

   state->device_to_rootdevice[hp_device_t(hostname,process_id,  (thapi_device_id) hSubDevice) ] =  (thapi_device_id) hDevice;

  <% end %>

  <%# Map [ Tuple [ Hostnane, process, cl_command_queue ], Tuple [ device, subdevice] ] %>
  <% if ['zeCommandListCreate','zeCommandListCreateImmediate'].include? dbt_event.name_striped %>
       <% if dbt_event.name_unsanitized.end_with?(START) %>
    state->start_device[hpt_t(hostname,process_id,thread_id) ] = (thapi_device_id) hDevice;
       <% elsif dbt_event.name_unsanitized.end_with?(STOP) %>
    const auto device_or_subdevice = state->start_device[hpt_t(hostname, process_id,thread_id) ];
    auto it = state->device_to_rootdevice.find(hp_device_t(hostname, process_id, device_or_subdevice));
    if (it == state->device_to_rootdevice.end()) { // A device
       state->command_list_to_device[hp_command_list_t(hostname,process_id,phCommandList_val)]=  dsd_t(device_or_subdevice, NULL);
    } else {
        state->command_list_to_device[hp_command_list_t(hostname,process_id,phCommandList_val)]=  dsd_t(it->second, device_or_subdevice);
    }
       <% else %>
           <% raise "Dont know what kind of commandListCreate events this is"%>
       <% end %>
  <% end %>

  <%#
    _         _                    _
   |_) ._ _ _|_ o | o ._   _  o   |_    ._   _ _|_ o  _  ._    ._   _. ._ _   _
   |   | (_) |  | | | | | (_| o   | |_| | | (_  |_ | (_) | |   | | (_| | | | (/_
                           _|
   Map [ Tuple [ Hostnane, process, thread, function_name], Tuple [ device, subdevice] ]
  %>
  <%# Save kernel name %>
  <% if dbt_event.name_unsanitized == "lttng_ust_ze:zeKernelCreate_#{START}" %>
    state->last_kernel[hpt_t(hostname,process_id,thread_id)] = std::string{desc__pKernelName_val};
  <% elsif dbt_event.name_unsanitized == "lttng_ust_ze:zeKernelCreate_#{STOP}" %>
    state->kernel_to_name[hp_kernel_t(hostname,process_id,phKernel_val)] = state->last_kernel[hpt_t(hostname,process_id,thread_id)];
  <% end %>
  <%# Save GroupSize %>
  <% if dbt_event.name_unsanitized == "lttng_ust_ze:zeKernelSetGroupSize_#{START}" %>
     std::stringstream groupsize;
     groupsize << "{" << groupSizeX << ","
                      << groupSizeY << ","
                      << groupSizeZ << "}";

     state->kernel_to_groupsize[hp_kernel_t(hostname,process_id,hKernel)] = groupsize.str();
  <% end %>


  <% if dbt_event.name_unsanitized.end_with?(START) and dbt_event.fields_name.include?('hSignalEvent') %>
    std::stringstream metadata;
   <%if dbt_event.fields_name.include?('hKernel') %>
    std::string name  = state->kernel_to_name[hp_kernel_t(hostname,process_id,hKernel)];
    <% if dbt_event.fields_name.include?('pLaunchFuncArgs') %>
    metadata <<  "{" << pLaunchFuncArgs_val->groupCountX << ","
                  << pLaunchFuncArgs_val->groupCountY << ","
                  << pLaunchFuncArgs_val->groupCountZ << "}";
    //# All the kernel should have a GroupSize
    metadata << ", ";
    metadata << state->kernel_to_groupsize[hp_kernel_t(hostname,process_id,hKernel)];
    <% end %>
   <% else %>
    <% if dbt_event.name_striped == "zeCommandListAppendMemoryCopy" %>
    std::stringstream name_;
    name_ << "<%= dbt_event.name_striped %>";
    name_ << "(";
    name_ << memory_location(state, hp_t(hostname.c_str(), process_id), (uintptr_t) srcptr);
    name_ << memory_location(state, hp_t(hostname.c_str(), process_id), (uintptr_t) dstptr);
    name_ << ")";
    std::string name = name_.str();
    <% else %>
    const std::string name{"<%= dbt_event.name_striped %>"};
    <% end %>

   <% end %>
    //Copy the datatranfer
    <% if (dbt_event.name_striped.include?("Alloc") or dbt_event.name_striped.include?("Memory")) and
         dbt_event.fields_name.include? ("size") %>
    create_and_enqueue_traffic_message(hostname.c_str(), process_id, thread_id, name.c_str(),size);
   <% end %>


    //Everything we profile have a command list
    const auto [device, subdevice] =  state->command_list_to_device[hp_command_list_t(hostname,process_id,hCommandList)];
    state->profiled_function_name_dsd_and_ts[hpt_t(hostname,process_id,thread_id)] = fnm_dsd_ts_t(name, metadata.str(), device, subdevice, ns_from_origin);
  <% end %>

  <%#
    _         _                    _                        ___
   |_) ._ _ _|_ o | o ._   _  o   |_ |  _. ._   _  _   _|    | o ._ _   _   _
   |   | (_) |  | | | | | (_| o   |_ | (_| |_) _> (/_ (_|    | | | | | (/_ _>
                           _|              |
   Map [ Tuple[hostname, process, device, subdevice, cl_function_name], elapsed_time ]
  %>

  <%if dbt_event.name_unsanitized == "lttng_ust_ze_profiling:event_profiling" %>
   zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;
   const hostname_t hostname    = borrow_hostname(bt_evt);
   const process_id_t process_id = borrow_process_id(bt_evt);
   const thread_id_t thread_id   = borrow_thread_id(bt_evt);
   const hp_event_t hp_event{hostname,process_id, hEvent};
   auto [function_name, metadata, device, subdevice, ts] = state->profiled_function_name_dsd_and_ts[hpt_t(hostname,process_id,thread_id)];

   if (!state->event_to_function_name_dsd_and_ts.count(hp_event)){
      state->event_to_function_name_dsd_and_ts[hp_event] = tfnm_dsd_ts_t(thread_id, function_name, metadata, device, subdevice, ts);
   } else {
      const auto [start,delta] = state->event_result_to_start_and_delta[hp_event];
      create_and_enqueue_device_message(hostname.c_str(), process_id, thread_id,
                                        hash_device(state, hostname, device),
                                        hash_device(state, hostname, subdevice),
                                        function_name.c_str(), start, delta, delta == 0,
                                        metadata.c_str());

      state->event_to_function_name_dsd_and_ts.erase(hp_event);
   }

  <% elsif dbt_event.name_unsanitized == "lttng_ust_ze_profiling:event_profiling_results" %>
   zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;
   const hostname_t hostname    = borrow_hostname(bt_evt);
   const process_id_t process_id = borrow_process_id(bt_evt);
   const hp_event_t hp_event{hostname,process_id, hEvent};

   if (state->event_to_function_name_dsd_and_ts.count(hp_event)) {
      auto [thread_id, function_name, metadata, device, subdevice, ts] =  state->event_to_function_name_dsd_and_ts[hp_event];
      const hp_device_t hp_device{hostname, process_id, device};
      const uint64_t delta = elapsed_time_ns(state, hp_device, globalStart, globalEnd);
      const uint64_t start = start_time_ns(state, hp_device, globalStart,ts);

      create_and_enqueue_device_message(hostname.c_str(), process_id, thread_id,
                                        hash_device(state, hostname, device),
                                        hash_device(state, hostname, subdevice),
                                        function_name.c_str(),start,delta, delta == 0, metadata.c_str() );

      state->event_to_function_name_dsd_and_ts.erase(hp_event);
   } else {
     <%# Not sure about this one. Need to see when we have native callbacks %>
     const thread_id_t thread_id = borrow_thread_id(bt_evt);
     const auto [function_name, metadata, device,subdevice, ts] = state->profiled_function_name_dsd_and_ts[hpt_t(hostname,process_id,thread_id)];
     (void) subdevice;

     const hp_device_t hp_device{hostname, process_id, device};
     const uint64_t start = start_time_ns(state, hp_device, globalStart,ts);
     const uint64_t delta = elapsed_time_ns(state, hp_device, globalStart, globalEnd);

     state->event_result_to_start_and_delta[hp_event] = sd_t(start,delta);
     state->event_to_function_name_dsd_and_ts[hp_event] = tfnm_dsd_ts_t(thread_id, function_name, metadata, device, subdevice, ts);
  }
  <% end %>
};
<% end %>

<%#
 ___
  |  ._  o _|_ o  _. | o _   _
 _|_ | | |  |_ | (_| | | /_ (/_

%>

void init_zeinterval_callbacks(struct zeinterval_dispatch   *ze_dispatch) {
<% $dbt_events.each do | dbt_event| %>
  zeinterval_register_callback(ze_dispatch, "<%= dbt_event.name_unsanitized %>", (void *) &zeinterval_<%= dbt_event.name %>_callback);
<% end %>
}

void finalize_zeinterval_callbacks(zeinterval_message_iterator *interval_dispatch_iter) {
    zeinterval_callbacks_state* state = (zeinterval_callbacks_state*)  interval_dispatch_iter->callbacks_state;
    auto map = state->host_start;
    for (auto const &[function_name, ts] : map) {
        if (ts != 0) {
            const auto [hostname,process_id, thread_id, f ]  = function_name;
            std::cerr << "THAPI::Warning: " << hostname
                      << " PID " << process_id
                      << " TID " << thread_id
                      << " " << f << " was called but never returned" << std::endl;
        }
    }
}
