#include <iomanip>
#include <iostream>
#include "babeltrace_zeinterval.h"
#include "zeinterval_callbacks.hpp"
#include "xprof_utils.hpp"
#include <babeltrace2/babeltrace.h>

#include <ze_api.h>
#include <ze_ddi.h>
#include <zet_api.h>
#include <zet_ddi.h>
#include <zes_api.h>
#include <zes_ddi.h>
#include <zel_tracepoints.h>

#include <vector>
#include <algorithm>
#include <iostream>
#include <unordered_map>
#include <tuple>
#include <climits>
#include <set>
#include <assert.h>     /* assert */

//Memory interval
static bool contains(const MemoryInterval& m, const uintptr_t val) {
    // if m empty, bein == end	
    const auto it = m.upper_bound(val);
    if (it == m.cbegin())
        return false;
    return (val < (std::prev(it)->second));
}

static uint64_t convert_device_cycle(uint64_t device_cycle, 
				     timestamp_pair_t timestamp_pair_ref, 
				     uint64_t lltng_min, 
				     hDeviceProperty device_property) {

    const auto& [lttng_ref, device_cycle_ref] = timestamp_pair_ref;
 
    assert (valid_bits <= 64);
    const uint64_t max_val_device = (uint64_t) 1 << device_property->valid_bits - 1;

    uint64_t lttng;
    do {
       const uint64_t device = device_cyle * device_property->timerResolution;     
       lttng = device + ( lttng_ref - device_ref )
       device_cycle += max_val_device;

    } while (lttng < lttng_min)
    return lttng;

}

static uint64_t compute_and_convert_delta(uint64_t start, uint64_t end, hDeviceProperty device_property) {

    if (end >= start) {
        return (end - start) * device_property->timerResolution;
    } else {
       <%# We cycle (don't know how many time. Lets assume one) %>
       const uint64_t max_val = ((uint64_t) 1 << device_property->kernelTimestampValidBits) - 1;
       return (max_val - start + end ) * timerResolution;
    }
}

// Hash UUID
static uintptr_t hash_device(zeinterval_callbacks_state* state, const hostname_t hostname, thapi_device_id device) {
    if (!device)
        return 0;

    auto device_uuid = state->device_to_uuid[h_device_t(hostname, device)];

    // Right now we store `ptr` and not `uuid`.
    // we cast `uiid` to `ptr`. This should to the oposite
    uintptr_t device_uuid_hash[2];
    memcpy(&device_uuid_hash[0], &device_uuid, sizeof(device_uuid));
    device_uuid_hash[0]+= device_uuid_hash[1];
    return device_uuid_hash[0];
}

void *init_zeinterval_callbacks_state() {
    zeinterval_callbacks_state *s = new zeinterval_callbacks_state;
    return (void*) s;
}

static void create_and_enqueue_host_message(const char* hostname, const process_id_t process_id, const thread_id_t thread_id, const char* name,
                                            const uint64_t ts, const uint64_t duration, const bool err) {

     /* Message creation */
     bt_message *message = create_host_message(hostname, process_id, thread_id, name, ts, duration, err,
                            zeinterval_iter_g->dispatch->host_event_class,
                            zeinterval_self_message_iterator_g,
                            zeinterval_iter_g->dispatch->stream);

     zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;
     state->downstream_message_queue.push(message);
}

          create_and_enqueue_device_message(hostname, process_id, thread_id, device,
                                            commandname, metadata,
                                            globalStart, globalEnd, lltng_min, timestamp_pair_ref,
                                            state->device_properties, state->subdevice_parent);

static void create_and_enqueue_device_message(const char* hostname, const process_id_t process_id, const thread_id_t thread_id, const thapi_device_id device,
					      const char* commandname, const char* metadata,
					      const uint64_t globalStart,  const uint64_t globalEnd, const uint64_t lltng_min, timestamp_pair_t timestamp_pair_ref,
 					      std::map<hpd_t, deviceproperty> device_properties, 
					      std::map<hp, hDevice> subdevice_parent);

     const hpd_t hpd(hostname,process_id_t, device);
     const auto dp = device_properties[hpd];

     const auto delta = compute_and_convert_delta(globalStart, globalEnd, dp);
     const bool err = (delta != 0);
     const auto start = convert_device_cycle(globalStart, timestamp_pair_ref, lltng_min, dp);

     thapi_device subdevice;
     const auto it1 = subdevice_parent.find(hpd);
     if (it1 != subdevice_parent.cend()) {
         subdevice = device;
         device = it->second;
     }
     // Need to convert the pointer into UUID

     /* Message creation */
     bt_message *message = create_device_message(hostname, process_id, thread_id, device, subdevice, commandname, start, delta, err, metadata,
                                                 zeinterval_iter_g->dispatch->device_event_class,
                                                 zeinterval_self_message_iterator_g,
                                                 zeinterval_iter_g->dispatch->stream);

     /* Set message */
     zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;
     state->downstream_message_queue.push(message);
}

static void create_and_enqueue_traffic_message(const char* hostname, const process_id_t process_id, const thread_id_t thread_id, const char* name,
                                               const uint64_t size) {

     /* Message creation */
     bt_message *message = create_traffic_message(hostname, process_id, thread_id, name, size,
                                                  zeinterval_iter_g->dispatch->traffic_event_class,
                                                  zeinterval_self_message_iterator_g,
                                                  zeinterval_iter_g->dispatch->stream);

     zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;
     state->downstream_message_queue.push(message);
}

<%#
  _                                         _                          _ ___
 | \  _       ._   _ _|_ ._ _   _. ._ _    / \      _       _     /\  |_) |
 |_/ (_) \/\/ | | _>  |_ | (/_ (_| | | |   \_X |_| (/_ |_| (/_   /--\ |  _|_

%>

bool zeinterval_downstream_message_queue_empty(struct zeinterval_message_iterator *interval_dispatch_iter)
{
    zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) interval_dispatch_iter->callbacks_state;
    return state->downstream_message_queue.empty();
}

size_t zeinterval_downstream_message_queue_size(struct zeinterval_message_iterator *interval_dispatch_iter)
{
    zeinterval_callbacks_state* state = (zeinterval_callbacks_state*)  interval_dispatch_iter->callbacks_state;
    return state->downstream_message_queue.size();
}

const bt_message* zeinterval_downstream_message_queue_pop(struct zeinterval_message_iterator *interval_dispatch_iter)
{
    zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) interval_dispatch_iter->callbacks_state;
    const bt_message* m = state->downstream_message_queue.front();
    state->downstream_message_queue.pop();
    return m;
}

void zeinterval_downstream_message_queue_push(struct zeinterval_message_iterator *interval_dispatch_iter, const bt_message *message)
{
    zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) interval_dispatch_iter->callbacks_state;
    state->downstream_message_queue.push(message);
}

<%#
                    ___
   |\/|  _  ._ _     |  ._ _|_  _  ._    _. |
   |  | (/_ | | |   _|_ | | |_ (/_ | \/ (_| |

%>

void remove_memory(zeinterval_callbacks_state* state, hp_t hp, const uintptr_t ptr) {

    auto &rs = state->rangeset_memory_shared[hp];
    auto its = rs.find(ptr);
    if (its != rs.end()) {
         rs.erase(its);
         return;
    }
    auto &rd = state->rangeset_memory_device[hp];
    auto itd = rd.find(ptr);
    if (itd != rd.end()) {
         rd.erase(itd);
         return;
    }

    auto &rh = state->rangeset_memory_host[hp];
    auto ith = rh.find(ptr);
    if (ith != rh.end()) {
         rh.erase(ith);
         return;
    }

    return;
}

const char* memory_location(zeinterval_callbacks_state* state, hp_t hp, const uintptr_t ptr) {
    const auto &rs = state->rangeset_memory_shared[hp];
    if (contains(rs, ptr))
        return "S";

    const auto &rd = state->rangeset_memory_device[hp];
    if (contains(rd, ptr))
        return "D";

    const auto &rh = state->rangeset_memory_host[hp];
    if (contains(rh, ptr))
        return "H";

    return "M";
}

<%#
  _
 /   _. | | |_   _.  _ |   _
 \_ (_| | | |_) (_| (_ |< _>

%>

<% $dbt_events.each do | dbt_event | %>
static void zeinterval_<%= dbt_event.name %>_callback(
   <%= dbt_event.callback_signature %>
){
  <%#                             ___      _
       |   _   _  _. | o _|_       |  ._ _|_ _
       |_ (_) (_ (_| | |  |_ \/   _|_ | | | (_)
                             /
  %>
  <%if dbt_event.name_unsanitized.start_with?('lttng_ust_ze:')  or
       dbt_event.name_unsanitized.start_with?('lttng_ust_zet:') or
       dbt_event.name_unsanitized.start_with?('lttng_ust_zes:') or
       dbt_event.name_unsanitized.start_with?('lttng_ust_zel:')  %>

    const hostname_t   hostname   = borrow_hostname(bt_evt);
    const process_id_t process_id = borrow_process_id(bt_evt);
    const thread_id_t  thread_id  = borrow_thread_id(bt_evt);
    zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;
  <%end %>

  <%#        _ ___
        /\  |_) |     _  _. | |  _
       /--\ |  _|_   (_ (_| | | _>
  %>
  <%if dbt_event.name_unsanitized.start_with?('lttng_ust_ze:')  or
       dbt_event.name_unsanitized.start_with?('lttng_ust_zet:') or
       dbt_event.name_unsanitized.start_with?('lttng_ust_zes:') or
       dbt_event.name_unsanitized.start_with?('lttng_ust_zel:')  %>
    int64_t ns_from_origin;
    bt_clock_snapshot_get_ns_from_origin(bt_clock, &ns_from_origin);
    <%if dbt_event.name_unsanitized.end_with?(START) %>
    state->host_start[hpt_function_name_t(hostname,process_id, thread_id, "<%= dbt_event.name_striped %>")] = ns_from_origin;
    <%elsif dbt_event.name_unsanitized.end_with?(STOP) %>
    uint64_t &start_g = state->host_start.at(hpt_function_name_t(hostname,process_id, thread_id, "<%= dbt_event.name_striped %>"));
     <% if dbt_event.fields_name.include?('zeResult') %>
       <%# In level0 1.0-rev-3  only those use `ZE_RESULT_NOT_READY` %>
       <% if dbt_event.name_striped.include? ('Synchronize') or dbt_event.name_striped.include? ('Query')  %>
    create_and_enqueue_host_message(hostname.c_str(), process_id, thread_id, "<%= dbt_event.name_striped %>", start_g, ns_from_origin-start_g, zeResult != ZE_RESULT_SUCCESS && zeResult != ZE_RESULT_NOT_READY);
       <% else %>
    create_and_enqueue_host_message(hostname.c_str(), process_id, thread_id, "<%= dbt_event.name_striped %>", start_g, ns_from_origin-start_g, zeResult);
       <% end %>
     <% else %>
    create_and_enqueue_host_message(hostname.c_str(), process_id, thread_id, "<%= dbt_event.name_striped %>", start_g, ns_from_origin-start_g, 0);
     <% end %>
    start_g = 0;
   <%end%>
  <%end%>

  <%#
       |\/|  _  ._ _   _  ._      _.  _  _  _   _  _  _   _
       |  | (/_ | | | (_) | \/   (_| (_ (_ (/_ _> _> (/_ _>
                            /
  %>
  <%# Global variable %>
  <% if dbt_event.name_striped == "zeModuleGetGlobalPointer"  and dbt_event.name_unsanitized.end_with?(START) %>
    state->last_module[hpt_t(hostname.c_str(),process_id,thread_id)] = hModule;
  <% elsif dbt_event.name_striped == "zeModuleGetGlobalPointer"  and dbt_event.name_unsanitized.end_with?(STOP) %>
    if ( zeResult == ZE_RESULT_SUCCESS ) {
        ze_module_handle_t hModule = state->last_module[hpt_t(hostname.c_str(),process_id,thread_id)];
        state->module_to_module_globals[hp_module_t(hostname.c_str(), process_id, hModule)].insert((uintptr_t)pptr_val);
        state->rangeset_memory_shared[hp_t(hostname.c_str(), process_id)][(uintptr_t) pptr_val] = (uintptr_t)pptr_val + pSize_val;
    }
  <% elsif dbt_event.name_striped == "zeModulelDestroy" and dbt_event.name_unsanitized.end_with?(START) %>
    auto& s = state->module_to_module_globals;
    auto it = s.find(hp_module_t(hostname.c_str(), process_id, hModule));
    if (it != s.end()) {
        state->rangeset_memory_shared[hp_t(hostname.c_str(), process_id)].erase(it->second.begin());
        s.erase(it);
    }
  <% end %>

  <% if ['zeMemAllocHost','zeMemAllocDevice','zeMemAllocShared'].include? dbt_event.name_striped and dbt_event.name_unsanitized.end_with?(START) %>
    state->last_alloc[hpt_t(hostname.c_str(),process_id,thread_id)] = size;
  <% end %>

  <% if dbt_event.name_striped == "zeMemAllocHost" and dbt_event.name_unsanitized.end_with?(STOP) %>
    if ( zeResult == ZE_RESULT_SUCCESS ) {
        const auto size = state->last_alloc[hpt_t(hostname.c_str(),process_id,thread_id)];
        state->rangeset_memory_host[hp_t(hostname.c_str(), process_id)][(uintptr_t) pptr_val] = (uintptr_t)pptr_val + size;
    }
  <% end %>

  <% if dbt_event.name_striped == "zeMemAllocDevice" and dbt_event.name_unsanitized.end_with?(STOP) %>
    if ( zeResult == ZE_RESULT_SUCCESS ) {
        const auto size = state->last_alloc[hpt_t(hostname.c_str(),process_id,thread_id)];
        state->rangeset_memory_device[hp_t(hostname.c_str(), process_id)][(uintptr_t) pptr_val] = (uintptr_t)pptr_val + size;
    }
  <% end %>

  <% if dbt_event.name_striped == "zeMemAllocShared" and dbt_event.name_unsanitized.end_with?(STOP) %>
    if ( zeResult == ZE_RESULT_SUCCESS ) {
        const auto size = state->last_alloc[hpt_t(hostname.c_str(),process_id,thread_id)];
        state->rangeset_memory_shared[hp_t(hostname.c_str(), process_id)][(uintptr_t) pptr_val] = (uintptr_t)pptr_val + size;
    }
  <% end %>

  <% if dbt_event.name_striped == "zeMemFree" and dbt_event.name_unsanitized.end_with?(START) %>
    state->last_free[hpt_t(hostname.c_str(),process_id,thread_id)] = (uintptr_t)ptr;
  <% end %>
  <% if dbt_event.name_striped == "zeMemFree" and dbt_event.name_unsanitized.end_with?(STOP) %>
    if ( zeResult == ZE_RESULT_SUCCESS ) {
        const auto ptr = state->last_free[hpt_t(hostname.c_str(),process_id,thread_id)];
        remove_memory(state, hp_t(hostname.c_str(), process_id), ptr);
    }
  <% end %>

  <%#  ___                                    __         _
        | o ._ _   _   _ _|_  _. ._ _  ._    (_  |_  o _|_ _|_
        | | | | | (/_ _>  |_ (_| | | | |_)   __) | | |  |   |_
                                     |
  %>
  <%if dbt_event.name_unsanitized == "lttng_ust_ze_properties:device_timer"  %>
    const hostname_t  hostname{borrow_hostname(bt_evt)};
    const process_id_t process_id = borrow_process_id(bt_evt);
    zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;

    int64_t ns_from_origin;
    bt_clock_snapshot_get_ns_from_origin(bt_clock, &ns_from_origin);

    hp_device_t hp_device{hostname, process_id, (thapi_device_id) hDevice};

    const auto& map = state->device_to_timerResolution_kernelTimestampValidBits;
    const auto it = map.find(hp_device);
    if (it != map.cend()) {
        const auto [_timerResolution, _kernelTimestampValidBits] = it->second;
        const uint64_t mask = ((uint64_t) 1 << _kernelTimestampValidBits) - 1;
        //Mapping from lltng time to device time
        state->sync_clock_lttng_device[hp_device] = clock_lttng_device_t{ns_from_origin, (deviceTimestamp & mask )*_timerResolution};
    }
  <% end %>

  <%#
    _         _                    _                                   __          _
   |_) ._ _ _|_ o | o ._   _  o   | \  _     o  _  _     _. ._   _|   (_      |_  | \  _     o  _  _
   |   | (_) |  | | | | | (_| o   |_/ (/_ \/ | (_ (/_   (_| | | (_|   __) |_| |_) |_/ (/_ \/ | (_ (/_
                           _|

                                        | in      | out
```
1. thread_X: zeCommandListAppend        | hDevice |      
2. lttng_ust_ze_properties:device_timer | hDevice | lltngTimestamp, deviceTimestamp
3. thread_X: event_profiling            |         | hEvent
4. thread_Y: event_profiling_result     | hEvent  | globalStart, globalEnd
```
```
1. thread_X: zeCommandListAppend        | hDevice |
2. lttng_ust_ze_properties:device_timer | hDevice | lltngTimestamp, deviceTimestamp
3. thread_Y: event_profiling_result     | hEvent  | globalStart, globalEnd
4. thread_X: event_profiling            |         | hEvent
```

# If the CommandListAppend fail, no event_proffiling will be enable
# Check case where lttng timestamp <= lltngTimestamp (other thread updated it)

Case A:

1. command_partial_payload (contain device, name of the command, lttng timestamp...)
2. device_timestamp_pair[hp_d] = [lltngTimestamp, deviceTimestamp]
3. event_payload[hp_e] = [ command_partial_payload[hpt] (M), 
                           device_timestamp_pair[hp_d], 
                           thread_id ]

4. event_payload[hp_e] (M)
   subdevice_parent[hp_d]
   device_properties[hp_d]	
   [globalStart, globalEnd]

Case B:

1. command_partial_payload (contain device, name of the command, lttng timestamp...)
2. device_timestamp_pair[hp_d] = [lltngTimestamp, deviceTimestamp]
3. event_timer[hp_e] = [globalStart, globalEnd]
4. command_partial_payload[hpt] (M)
   device_timestamp_pair[hpd]
   subdevice_parent[hpd]
   device_properties[hpd]
   event_timer[hp_e] (M)
   %>

  <%# Save devices informations. 
      Map subdevices to their parents %>
  <%if dbt_event.name_unsanitized == "lttng_ust_ze_properties:device" %>
     zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;
     const h_t hostname = borrow_hostname(bt_evt);
     const p_t process_id = borrow_process_id(bt_evt);
     const hpd_t hpd (hostname, process_id, hDevice);

     state->device_properties[hpd] = pDeviceProperties_val;
  <%elsif dbt_event.name_unsanitized == "lttng_ust_ze_properties:subdevice" %>
     zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;
     const h_t hostname = borrow_hostname(bt_evt);
     const p_t process_id = borrow_process_id(bt_evt);
     const hpd_t hpd (hostname, process_id, hSubDevice);

     state->device_properties[hpd] = pDeviceProperties_val;
     state->subdevice_parent[hpd] = hDevice;
  <% end %>

  <%# Map command list to it device %>
  <% if ['zeCommandListCreate','zeCommandListCreateImmediate'].include? dbt_event.name_striped %>
    <% if dbt_event.name_unsanitized.end_with?(START) %>
     state->start_device[hpt_t(hostname,process_id,thread_id) ] = hDevice;
    <% elsif dbt_event.name_unsanitized.end_with?(STOP) %>
     const auto device = state->start_device[hpt_t(hostname, process_id,thread_id) ];
     state->command_list_device[hp_command_list_t(hostname,process_id,phCommandList_val)] = device;
    <% end %>
  <% end %>

  <%#
    _         _                    _
   |_) ._ _ _|_ o | o ._   _  o   |_    ._   _ _|_ o  _  ._    ._   _. ._ _   _
   |   | (_) |  | | | | | (_| o   | |_| | | (_  |_ | (_) | |   | | (_| | | | (/_
                           _|
  %>
  <%# Map kernel to name and group size %>
  <% if dbt_event.name_unsanitized == "lttng_ust_ze:zeKernelCreate_#{START}" %>
     state->last_kernel[hpt_t(hostname,process_id,thread_id)] = std::string{desc__pKernelName_val};
  <% elsif dbt_event.name_unsanitized == "lttng_ust_ze:zeKernelCreate_#{STOP}" %>
     state->kernel_name[hpk_t(hostname,process_id,phKernel_val)] = state->last_kernel[hpt_t(hostname,process_id,thread_id)];
  <% elsif dbt_event.name_unsanitized == "lttng_ust_ze:zeKernelSetGroupSize_#{START}" %>
     std::stringstream groupsize;
     groupsize << "{" << groupSizeX << ","
                      << groupSizeY << ","
                      << groupSizeZ << "}";
     state->kernel_groupsize_str[hp_kernel_t(hostname,process_id,hKernel)] = groupsize.str();
  <% end %>

  <%#
    _         _                    _                             
   |_) ._ _ _|_ o | o ._   _  o   /   _  ._ _  ._ _   _. ._   _| 
   |   | (_) |  | | | | | (_| o   \_ (_) | | | | | | (_| | | (_| 
                           _|                                    
  %>
  <%# Map last command partial payload %>
  <% if dbt_event.name_unsanitized.end_with?(START) and dbt_event.fields_name.include?('hSignalEvent') %>
     std::stringstream metadata;
    <%if dbt_event.fields_name.include?('hKernel') %>
     const auto hpk hpk_t(hostname,process_id,hKernel);	    
     std::string name  = state->kernel_to_name[hpk];
      <% if dbt_event.fields_name.include?('pLaunchFuncArgs') %>
     metadata <<  "{" << pLaunchFuncArgs_val->groupCountX << ","
                      << pLaunchFuncArgs_val->groupCountY << ","
		      << pLaunchFuncArgs_val->groupCountZ << "}";
      <% end %>
     metadata << ", ";
     metadata << state->kernel_groupsize_str[hpk];
    <% elsif dbt_event.name_striped == "zeCommandListAppendMemoryCopy" %>
     const hp_t hp((hostname, process_id);
     std::stringstream name_;
     name_ << "<%= dbt_event.name_striped %>";
     name_ << "(";
     name_ << memory_location(state, hp, (uintptr_t) srcptr);
     name_ << memory_location(state, hp, (uintptr_t) dstptr);
     name_ << ")";
     std::string name = name_.str();
    <% else %>
     const std::string name{"<%= dbt_event.name_striped %>"};
    <% end %>
     const auto device = state->command_list_device[hp_command_list_t(hostname,process_id,hCommandList)];
     state->command_partial_payload[hpt_t(hostname,process_id,thread_id)] = fnm_dsd_ts_t(name, metadata.str(), device, ns_from_origin);
  <% end %>

  <%#
    _         _                    _                 
   |_) ._ _ _|_ o | o ._   _  o   |_     _  ._ _|_   
   |   | (_) |  | | | | | (_| o   |_ \/ (/_ | | |_   
                           _|                        
  %>
  <%if dbt_event.name_unsanitized == "lttng_ust_ze_profiling:event_profiling" %>
     zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;
     const hostname_t hostname = borrow_hostname(bt_evt);
     const process_id_t process_id = borrow_process_id(bt_evt);
     const thread_id_t thread_id = borrow_thread_id(bt_evt);
     const hpe_t hpe(hostname, process_id, hEvent);
     const hpt_t hpt(hostname, process_id, thread_id);
   
     const auto& partial_payload = state->command_partial_payload[hpt];
     const hpd_t hpd(hostname, process_id, std::get<2>(partial_payload));

     // Got the timestamp pair referance
     timestamp_pair_t timestamp_pair_ref;
     const auto& m0 = state->device_timestamps_pair_ref;
     const auto it0 = m0.find(hpd);
     if (it0 != m0.cend())
          timestamp_pair_ref = it->second;

     if (!state->event_device_timers.count(hp_event)){
          // The `event_profiling_results` didn't generate populate the `>event_device_timers` we are the first to use it.
          state->event_payload[hp_event] = std::tuple_cat(thread_id, partial_payload, timestamp_pair_ref);
     } else {
	  auto& [commandname, metadata, device, lltng_min] = partial_payload;
	  const auto& [globalStart, globalEnd] = state->event_timestamp_pair[hp_event];

          create_and_enqueue_device_message(hostname, process_id, thread_id, device,
					    commandname, metadata,
                                            globalStart, globalEnd, lltng_min, timestamp_pair_ref,
                                            state->device_properties, state->subdevice_parent);
     }
  <% elsif dbt_event.name_unsanitized == "lttng_ust_ze_profiling:event_profiling_results" %>
     zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;
     const hostname_t hostname = borrow_hostname(bt_evt);
     const process_id_t process_id = borrow_process_id(bt_evt);
     const hpe_t hpe(hostname,process_id, hEvent);

     if (state->event_payload.count(hp_event)) {
          const auto [thread_id, commandname, metadata, device, lltng_min, timestamp_pair_ref] = state->event_payload[hpe];
	  create_and_enqueue_device_message(hostname, process_id, thread_id, device,
                                            commandname, metadata, 
 					    globalStart, globalEnd, lltng_min, timestamp_pair_ref,
				            state->device_properties, state->subdevice_parent); 
     } else {
          state->event_timestamp_pair[hpe] = timestamp_pair_t(globalStart,globalEnd);
     }

  <% end %>
};
<% end %>

<%#
 ___
  |  ._  o _|_ o  _. | o _   _
 _|_ | | |  |_ | (_| | | /_ (/_

%>

void init_zeinterval_callbacks(struct zeinterval_dispatch   *ze_dispatch) {
<% $dbt_events.each do | dbt_event| %>
  zeinterval_register_callback(ze_dispatch, "<%= dbt_event.name_unsanitized %>", (void *) &zeinterval_<%= dbt_event.name %>_callback);
<% end %>
}

void finalize_zeinterval_callbacks(zeinterval_message_iterator *interval_dispatch_iter) {
    zeinterval_callbacks_state* state = (zeinterval_callbacks_state*)  interval_dispatch_iter->callbacks_state;
    auto map = state->host_start;
    for (auto const &[function_name, ts] : map) {
        if (ts != 0) {
            const auto [hostname,process_id, thread_id, f ]  = function_name;
            std::cerr << "THAPI::Warning: " << hostname
                      << " PID " << process_id
                      << " TID " << thread_id
                      << " " << f << " was called but never returned" << std::endl;
        }
    }
}
