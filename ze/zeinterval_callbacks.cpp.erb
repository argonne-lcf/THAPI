#include <iomanip>
#include <iostream>
#include "babeltrace_zeinterval.h"
#include "zeinterval_callbacks.hpp"
#include "xprof_utils.hpp"
#include <babeltrace2/babeltrace.h>

#include <ze_api.h>
#include <ze_ddi.h>
#include <zet_api.h>
#include <zet_ddi.h>
#include <zes_api.h>
#include <zes_ddi.h>
#include <zel_tracepoints.h>

#include <vector>
#include <algorithm>
#include <iostream>
#include <unordered_map>
#include <tuple>
#include <climits>
#include <set>
#include <assert.h>     /* assert */

<%# Should pass device_to_timerResolution_kernelTimestampValidBits %>
static inline uint64_t corrected_l1(const uint64_t d1, const uint64_t l0, const uint64_t d0, const uint64_t l1_min, const uint64_t valid_bits) {
    /*
    d1 is the device time we want to convert to the lttng time (l1)
    l0 and d0 are a lttng and device timestamp who are synchronized
    l1_min is the minimun approximation of l1

    lttng timer (l*) is assumed to be monotonic, where the device term can overflow and loop arround
    */

    const int64_t l1_nocycle = d1 + l0 - d0;
    return l1_nocycle;

    assert (valid_bits <= 64);
    const uint64_t max_val = (uint64_t) 1 << valid_bits;
    const unsigned n = ( (l1_min - l1_nocycle) >> valid_bits ) + 1 ;
    return max_val*n + l1_nocycle;
}

static inline uint64_t elapsed_time_ns(zeinterval_callbacks_state* state, hp_device_t hp_device, uint64_t start, uint64_t end) {
    static bool is_ns = true;
    uint64_t timerResolution = 1;
    uint64_t kernelTimestampValidBits = 32;
    auto map = state->device_to_timerResolution_kernelTimestampValidBits;
    auto it = map.find(hp_device);
    if (it == map.end()) {
        if (is_ns) {
            std::cerr << "No timerResolution have been found for a device."
                      << "Data will be displayed as cycle" << std::endl;
            is_ns = false;
        }
    } else {
        const auto [timerResolution_,kernelTimestampValidBits_] = it->second;
        timerResolution = timerResolution_;
        kernelTimestampValidBits = kernelTimestampValidBits_;
    }
    if (end >= start) {
        return (end - start) * timerResolution;
    } else {
       <%# We cycle (don't know how many time. Lets assume one) %>
       const uint64_t max_val = ((uint64_t) 1 << kernelTimestampValidBits) - 1;
       return (max_val - start + end ) * timerResolution;
    }
}

static inline uint64_t start_time_ns(zeinterval_callbacks_state* state, hp_device_t hp_device, uint64_t start, uint64_t born_min) {

    static bool WarningOnce= true;

    auto map_sync = state->sync_clock_lttng_device;
    auto it_sync = map_sync.find(hp_device);

    auto map_timer = state->device_to_timerResolution_kernelTimestampValidBits;
    auto it_timer = map_timer.find(hp_device);

    if (it_timer != map_timer.end() && it_sync != map_sync.end()) {
        const auto [l0,d0] = it_sync->second;
        const auto [_timerResolution, _kernelTimestampValidBits] = it_timer->second;
        const uint64_t start_ns = start * _timerResolution;
        return corrected_l1(start_ns, l0, d0, born_min, _kernelTimestampValidBits);
    } else {
        if (WarningOnce) {
            std::cerr << "THAPI::Warning No host-device clock synchronization have been found. "
                      << "Kernel start time will be a lowerbound"<< std::endl;
            WarningOnce = false;
        }
        return born_min;
    }
}

void *init_zeinterval_callbacks_state() {
    zeinterval_callbacks_state *s = new zeinterval_callbacks_state;
    return (void*) s;
}

static void create_and_enqueue_host_message(const char* hostname, const process_id_t process_id, const thread_id_t thread_id, const char* name,
                                            const uint64_t ts, const uint64_t duration, const bool err) {

     /* Message creation */
     bt_message *message = create_host_message(hostname, process_id, thread_id, name, ts, duration, err,
                            zeinterval_iter_g->dispatch->host_event_class,
                            zeinterval_self_message_iterator_g,
                            zeinterval_iter_g->dispatch->stream);

     zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;
     state->downstream_message_queue.push(message);
}

void create_and_enqueue_device_message(const char* hostname, const process_id_t process_id, const thread_id_t thread_id,
                                       const thapi_device_id device_id, const thapi_device_id subdevice_id,
                                       const char* name, const uint64_t ts, const uint64_t duration, const bool err) {

     /* Message creation */
     bt_message *message = create_device_message(hostname, process_id, thread_id, device_id, subdevice_id, name, ts, duration, err,
                            zeinterval_iter_g->dispatch->device_event_class,
                            zeinterval_self_message_iterator_g,
                            zeinterval_iter_g->dispatch->stream);


     /* Set message */
     zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;
     state->downstream_message_queue.push(message);
}

static void create_and_enqueue_traffic_message(const char* hostname, const process_id_t process_id, const thread_id_t thread_id, const char* name,
                                               const uint64_t size) {

     /* Message creation */
     bt_message *message = create_traffic_message(hostname, process_id, thread_id, name, size,
                                                  zeinterval_iter_g->dispatch->traffic_event_class,
                                                  zeinterval_self_message_iterator_g,
                                                  zeinterval_iter_g->dispatch->stream);

     zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;
     state->downstream_message_queue.push(message);
}

<%#
  _                                         _                          _ ___
 | \  _       ._   _ _|_ ._ _   _. ._ _    / \      _       _     /\  |_) |
 |_/ (_) \/\/ | | _>  |_ | (/_ (_| | | |   \_X |_| (/_ |_| (/_   /--\ |  _|_

%>

bool zeinterval_downstream_message_queue_empty(struct zeinterval_message_iterator *interval_dispatch_iter)
{
    zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) interval_dispatch_iter->callbacks_state;
    return state->downstream_message_queue.empty();
}

size_t zeinterval_downstream_message_queue_size(struct zeinterval_message_iterator *interval_dispatch_iter)
{
    zeinterval_callbacks_state* state = (zeinterval_callbacks_state*)  interval_dispatch_iter->callbacks_state;
    return state->downstream_message_queue.size();
}

const bt_message* zeinterval_downstream_message_queue_pop(struct zeinterval_message_iterator *interval_dispatch_iter)
{
    zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) interval_dispatch_iter->callbacks_state;
    const bt_message* m = state->downstream_message_queue.front();
    state->downstream_message_queue.pop();
    return m;
}

void zeinterval_downstream_message_queue_push(struct zeinterval_message_iterator *interval_dispatch_iter, const bt_message *message)
{
    zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) interval_dispatch_iter->callbacks_state;
    state->downstream_message_queue.push(message);
}

<%#
  _
 /   _. | | |_   _.  _ |   _
 \_ (_| | | |_) (_| (_ |< _>

%>

<% $dbt_events.each do | dbt_event | %>
static void zeinterval_<%= dbt_event.name %>_callback(
   <%= dbt_event.callback_signature %>
){
  <%#                             ___      _
       |   _   _  _. | o _|_       |  ._ _|_ _
       |_ (_) (_ (_| | |  |_ \/   _|_ | | | (_)
                             /
  %>
  <%if dbt_event.name_unsanitized.start_with?('lttng_ust_ze:')  or
       dbt_event.name_unsanitized.start_with?('lttng_ust_zet:') or
       dbt_event.name_unsanitized.start_with?('lttng_ust_zes:') or
       dbt_event.name_unsanitized.start_with?('lttng_ust_zel:')  %>

    const hostname_t   hostname   = borrow_hostname(bt_evt);
    const process_id_t process_id = borrow_process_id(bt_evt);
    const thread_id_t  thread_id  = borrow_thread_id(bt_evt);
    zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;
  <%end %>

  <%#        _ ___
        /\  |_) |     _  _. | |  _
       /--\ |  _|_   (_ (_| | | _>
  %>
  <%if dbt_event.name_unsanitized.start_with?('lttng_ust_ze:')  or
       dbt_event.name_unsanitized.start_with?('lttng_ust_zet:') or
       dbt_event.name_unsanitized.start_with?('lttng_ust_zes:') or
       dbt_event.name_unsanitized.start_with?('lttng_ust_zel:')  %>
    int64_t ns_from_origin;
    bt_clock_snapshot_get_ns_from_origin(bt_clock, &ns_from_origin);
    <%if dbt_event.name_unsanitized.end_with?(START) %>
    state->host_start[hpt_function_name_t(hostname,process_id, thread_id, "<%= dbt_event.name_striped %>")] = ns_from_origin;
    <%elsif dbt_event.name_unsanitized.end_with?(STOP) %>
    uint64_t &start_g = state->host_start.at(hpt_function_name_t(hostname,process_id, thread_id, "<%= dbt_event.name_striped %>"));
     <% if dbt_event.fields_name.include?('zeResult') %>
       <%# In level0 1.0-rev-3  only those use `ZE_RESULT_NOT_READY` %>
       <% if dbt_event.name_striped.include? ('Synchronize') or dbt_event.name_striped.include? ('Query')  %>
    create_and_enqueue_host_message(hostname.c_str(), process_id, thread_id, "<%= dbt_event.name_striped %>", start_g, ns_from_origin-start_g, zeResult != ZE_RESULT_SUCCESS && zeResult != ZE_RESULT_NOT_READY);
       <% else %>
    create_and_enqueue_host_message(hostname.c_str(), process_id, thread_id, "<%= dbt_event.name_striped %>", start_g, ns_from_origin-start_g, zeResult);
       <% end %>
     <% else %>
    create_and_enqueue_host_message(hostname.c_str(), process_id, thread_id, "<%= dbt_event.name_striped %>", start_g, ns_from_origin-start_g, 0);
     <% end %>
    start_g = 0;
   <%end%>
  <%end%>

  <%#
       |\/|  _  ._ _   _  ._      _.  _  _  _   _  _  _   _
       |  | (/_ | | | (_) | \/   (_| (_ (_ (/_ _> _> (/_ _>
                            /
  %>
  <% if (dbt_event.name_striped.include?("Alloc") or dbt_event.name_striped.include?("Memory")) and
         dbt_event.fields_name.include? ("size") %>
  create_and_enqueue_traffic_message(hostname.c_str(), process_id, thread_id, "<%= dbt_event.name_striped %>",size);
  <% end %>

  <%#  ___                                    __         _
        | o ._ _   _   _ _|_  _. ._ _  ._    (_  |_  o _|_ _|_
        | | | | | (/_ _>  |_ (_| | | | |_)   __) | | |  |   |_
                                     |
  %>
  <%if dbt_event.name_unsanitized == "lttng_ust_ze_properties:device_timer"  %>
    const hostname_t  hostname{borrow_hostname(bt_evt)};
    const process_id_t process_id = borrow_process_id(bt_evt);
    zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;

    int64_t ns_from_origin;
    bt_clock_snapshot_get_ns_from_origin(bt_clock, &ns_from_origin);

    hp_device_t hp_device{hostname,process_id, (thapi_device_id) hDevice};

    auto map = state->device_to_timerResolution_kernelTimestampValidBits;
    auto it = map.find(hp_device);

    if (it != map.end()) {
        const auto [_timerResolution, _kernelTimestampValidBits] = it->second;
        const uint64_t mask = ((uint64_t) 1 << _kernelTimestampValidBits) - 1;
        state->sync_clock_lttng_device[hp_device] = clock_lttng_device_t{ns_from_origin, (deviceTimestamp & mask )*_timerResolution};
    }
  <% end %>


  <%#
    _         _                    _                                   __          _
   |_) ._ _ _|_ o | o ._   _  o   | \  _     o  _  _     _. ._   _|   (_      |_  | \  _     o  _  _
   |   | (_) |  | | | | | (_| o   |_/ (/_ \/ | (_ (/_   (_| | | (_|   __) |_| |_) |_/ (/_ \/ | (_ (/_
                           _|
   Map [ Tuple [ Hostnane, process, cl_command_queue ], Tuple [ device, subdevice] ]
  %>

  <%# Map [ Tuple [hostname, process, device_or_subdevice], device] ] %>
  <% if dbt_event.name_unsanitized == "lttng_ust_ze:zeDeviceGet_#{STOP}" %>
    if (phDevices_vals != nullptr) {
        for (unsigned int i=0; i < pCount_val; i++ ) {
            const thapi_device_id d = (thapi_device_id) phDevices_vals[i];
            state->device_to_rootdevice[hp_device_t(hostname,process_id, d) ] = d;
        }
    }
  <% elsif dbt_event.name_unsanitized == "lttng_ust_ze:zeDeviceGetSubDevices_#{START}" %>
    state->start_device[hpt_t(hostname,process_id,thread_id) ] = (thapi_device_id) hDevice;
  <% elsif dbt_event.name_unsanitized == "lttng_ust_ze:zeDeviceGetSubDevices_#{STOP}" %>
    const thapi_device_id device = state->start_device[hpt_t(hostname,process_id,thread_id) ];
    const thapi_device_id root_device = state->device_to_rootdevice[hp_device_t(hostname,process_id, device) ];
    if (phSubdevices_vals != nullptr) {
        for (unsigned int i=0; i < pCount_val; i++ ) {
            const thapi_device_id d = (thapi_device_id) phSubdevices_vals[i];
            state->device_to_rootdevice[hp_device_t(hostname,process_id, d) ] = root_device;
        }
    }
  <% end %>

  <%# Map [ Tuple [ Hostnane, process, cl_command_queue ], Tuple [ device, subdevice] ] %>
  <% if ['zeCommandListCreate','zeCommandListCreateImmediate'].include? dbt_event.name_striped %>
       <% if dbt_event.name_unsanitized.end_with?(START) %>
    state->start_device[hpt_t(hostname,process_id,thread_id) ] =  (thapi_device_id) hDevice;
       <% elsif dbt_event.name_unsanitized.end_with?(STOP) %>
    const thapi_device_id device = state->start_device[hpt_t(hostname,process_id,thread_id) ];
    const thapi_device_id root_device = state->device_to_rootdevice[hp_device_t(hostname,process_id, device) ];
    state->command_list_to_device[hp_command_list_t(hostname,process_id,phCommandList_val)]=  dsd_t(root_device, device);
       <% else %>
           <% raise "Dont know what kind of commandListCreate events this is"%>
       <% end %>
  <% end %>

  <%#
    _         _                    _
   |_) ._ _ _|_ o | o ._   _  o   |_    ._   _ _|_ o  _  ._    ._   _. ._ _   _
   |   | (_) |  | | | | | (_| o   | |_| | | (_  |_ | (_) | |   | | (_| | | | (/_
                           _|
   Map [ Tuple [ Hostnane, process, thread, function_name], Tuple [ device, subdevice] ]
  %>
  <%# Save kernel name %>
  <% if dbt_event.name_unsanitized == "lttng_ust_ze:zeKernelCreate_#{START}" %>
    state->last_kernel[hpt_t(hostname,process_id,thread_id)] = std::string{desc__pKernelName_val};
  <% elsif dbt_event.name_unsanitized == "lttng_ust_ze:zeKernelCreate_#{STOP}" %>
    state->kernel_to_name[hp_kernel_t(hostname,process_id,phKernel_val)] = state->last_kernel[hpt_t(hostname,process_id,thread_id)];
  <% end %>

  <% if dbt_event.name_unsanitized.end_with?(START) and dbt_event.fields_name.include?('hSignalEvent') %>
   <%if dbt_event.fields_name.include?('hKernel') %>
    const thapi_function_name name = state->kernel_to_name[hp_kernel_t(hostname,process_id,hKernel)];
   <% else %>
    constexpr char name[] = "<%= dbt_event.name_striped %>";
   <% end %>
    state->profiled_function_name_and_ts[hpt_t(hostname,process_id,thread_id)] = fn_ts_t(name,ns_from_origin);
   <% if dbt_event.name_unsanitized.end_with?(START) and dbt_event.fields_name.include?('hCommandList') %>
    state->function_name_to_dsd[hpt_function_name_t(hostname,process_id,thread_id,name)] = state->command_list_to_device[hp_command_list_t(hostname,process_id,hCommandList)];
   <% end %>
  <% end %>

  <%#
    _         _                    _                        ___
   |_) ._ _ _|_ o | o ._   _  o   |_ |  _. ._   _  _   _|    | o ._ _   _   _
   |   | (_) |  | | | | | (_| o   |_ | (_| |_) _> (/_ (_|    | | | | | (/_ _>
                           _|              |
   Map [ Tuple[hostname, process, device, subdevice, cl_function_name], elapsed_time ]
  %>

  <%# Getting timer resultion of each device %>
  <%if dbt_event.name_unsanitized == "lttng_ust_ze_properties:device" %>
   zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;
   const hostname_t hostname    = borrow_hostname(bt_evt);
   const process_id_t process_id = borrow_process_id(bt_evt);
   const auto t = timerResolution_kernelTimestampValidBits_t( pDeviceProperties_val->timerResolution, pDeviceProperties_val->kernelTimestampValidBits);
   state->device_to_timerResolution_kernelTimestampValidBits[hp_device_t(hostname,process_id, (thapi_device_id) hDevice)] = t ;

  <%elsif dbt_event.name_unsanitized == "lttng_ust_ze_profiling:event_profiling" %>
   zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;
   const hostname_t hostname    = borrow_hostname(bt_evt);
   const process_id_t process_id = borrow_process_id(bt_evt);
   const thread_id_t thread_id   = borrow_thread_id(bt_evt);
   const hp_event_t hp_event{hostname,process_id, hEvent};
   const auto [function_name,ts] = state->profiled_function_name_and_ts[hpt_t(hostname,process_id,thread_id)];
   if (!state->event_to_function_name_and_ts.count(hp_event)){
      state->event_to_function_name_and_ts[hp_event] = tfn_ts_t(thread_id, function_name, ts);
   } else {
      const auto [start,delta] = state->event_result_to_start_and_delta[hp_event];
      const auto [device,subdevice] = state->function_name_to_dsd[hpt_function_name_t(hostname,process_id,thread_id, function_name)];
      create_and_enqueue_device_message(hostname.c_str(),process_id,thread_id,device,subdevice,function_name.c_str(),start,delta, delta == 0 );
      state->event_to_function_name_and_ts.erase(hp_event);
   }

  <% elsif dbt_event.name_unsanitized == "lttng_ust_ze_profiling:event_profiling_results" %>
   zeinterval_callbacks_state* state = (zeinterval_callbacks_state*) zeinterval_iter_g->callbacks_state;
   const hostname_t hostname    = borrow_hostname(bt_evt);
   const process_id_t process_id = borrow_process_id(bt_evt);
   const hp_event_t hp_event{hostname,process_id, hEvent};

   if (state->event_to_function_name_and_ts.count(hp_event)) {
      const auto [thread_id,function_name,ts] =  state->event_to_function_name_and_ts[hp_event];
      const auto [device,subdevice] = state->function_name_to_dsd[hpt_function_name_t(hostname,process_id,thread_id, function_name)];
      const hp_device_t hp_device{hostname, process_id, device};

      const uint64_t delta = elapsed_time_ns(state, hp_device, globalStart, globalEnd);
      const uint64_t start = start_time_ns(state, hp_device, globalStart,ts);

      create_and_enqueue_device_message(hostname.c_str(),process_id,thread_id,device,subdevice,function_name.c_str(),start,delta, delta == 0 );

      state->event_to_function_name_and_ts.erase(hp_event);
   } else {
     <%# Not sure about this one. Need to see when we have native callbacks %>
     const thread_id_t thread_id = borrow_thread_id(bt_evt);
     const auto [function_name, ts] = state->profiled_function_name_and_ts[hpt_t(hostname,process_id,thread_id)];
     const auto [device,subdevice] = state->function_name_to_dsd[hpt_function_name_t(hostname,process_id,thread_id, function_name)];
     (void) subdevice;

     const hp_device_t hp_device{hostname, process_id, device};
     const uint64_t start = start_time_ns(state, hp_device, globalStart,ts);
     const uint64_t delta = elapsed_time_ns(state, hp_device, globalStart, globalEnd);

     state->event_result_to_start_and_delta[hp_event] = sd_t(start,delta);
     state->event_to_function_name_and_ts[hp_event] = tfn_ts_t(thread_id, function_name,ts);
  }
  <% end %>
};
<% end %>

<%#
 ___
  |  ._  o _|_ o  _. | o _   _
 _|_ | | |  |_ | (_| | | /_ (/_

%>

void init_zeinterval_callbacks(struct zeinterval_dispatch   *ze_dispatch) {
<% $dbt_events.each do | dbt_event| %>
  zeinterval_register_callback(ze_dispatch, "<%= dbt_event.name_unsanitized %>", (void *) &zeinterval_<%= dbt_event.name %>_callback);
<% end %>
}

void finalize_zeinterval_callbacks(zeinterval_message_iterator *interval_dispatch_iter) {
    zeinterval_callbacks_state* state = (zeinterval_callbacks_state*)  interval_dispatch_iter->callbacks_state;
    auto map = state->host_start;
    for (auto const [function_name, ts] : map) {
        if (ts != 0) {
            const auto [hostname,process_id, thread_id, f ]  = function_name;
            std::cerr << "THAPI::Warning: " << hostname
                      << " PID " << process_id
                      << " TID " << thread_id
                      << " " << f << " was called but never returned" << std::endl;
        }
    }
}
