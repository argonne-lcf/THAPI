#!/usr/bin/env ruby
DATADIR = File.join('@prefix@', 'share')
$:.unshift(DATADIR) if File.directory?(DATADIR)
require 'optparse'
require 'babeltrace2'
require 'find'

module MyRefinement

  refine(BT2::BTComponentClass) do
      attr_accessor :plugin
  end

  refine(BT2::BTPlugin.singleton_class) do

    def find_all_from_dir(path, recurse: false, fail_on_load_error: true)
        # I guess print a warning if recurse?
        ps = super
        ps.each { |p|
          p.path = path
        }
        ps
    end

  end

  refine(BT2::BTPlugin) do

    attr_accessor :path

    def get_source_component_class_by_name(name)
      c = super
      c.plugin = self if c
      c
    end

    def get_filter_component_class_by_name(name)
      c = super
      c.plugin = self if c
      c
    end

    def get_sink_component_class_by_name(name)
      c = super
      c.plugin = self if c
      c
    end

    def source_component_classes
      cs = super
      cs.each { |c| c.plugin = self }
      cs
    end

    def filter_component_classes
      cs = super
      cs.each { |c| c.plugin = self }
      cs
    end

    def sink_component_classes
      cs = super
      cs.each { |c| c.plugin = self }
      cs
    end

  end
  refine(BT2::BTGraph.singleton_class) do

    def new(handle = nil, retain: true, auto_release: true,
                   mip_version: 0)
      obj = super
      obj.plugins_path = []
      obj.cli_v = []
      obj
    end

  end

  refine(BT2::BTGraph) do
    attr_accessor :plugins_path, :cli_v

    def add_component(component_class, name, params: {},
                      logging_level: BT2::BTLogging.default_level,
                      initialize_method_data: nil)

      @plugins_path << component_class.plugin.path
      @cli_v << "--component #{name}:#{component_class.type.to_s.split('_').last.downcase}.#{component_class.plugin.name}.#{component_class.name}"
      str_params = params.filter_map { |k,v| "#{k}=#{v}" unless v.class == String && v.empty? }.join(",")
      @cli_v << "--params #{str_params.dump}" unless str_params.empty?
      super
    end

    def connect_ports(upstream_port, downstream_port)
      @cli_v << "--connect \"#{upstream_port.component.name}.#{upstream_port.name}:#{downstream_port.component.name}.#{downstream_port.name}\""
      super
    end

    def cli
      l = ["babeltrace2"]
      ps_u = @plugins_path.uniq.compact.sort
      l << "--plugin-path=#{ps_u.join(",")}" unless ps_u.empty?
      l << "run"
      l += @cli_v
      l.join(" \\\n")
    end

  end
end

using MyRefinement

# Don't complain about broken pipe
Signal.trap('SIGPIPE', 'SYSTEM_DEFAULT')

subtext = <<~HELP
  Commonly used command are:
     trace:     Display the trace
     tally:     Display the tally
     timeline:  Dump the timeline

  See 'babeltrace_thapi COMMAND --help' for more information on a specific command.
HELP

$options = { backends: %w[omp cl ze cuda hip] }
$options_tally = {
  'display' => [String, 'compact'],
  'name' => [String, 'demangle'],
  'display_mode' => [String, 'human'],
  'display_metadata' => [FalseClass, false],
  'display_name_max_size' => [Integer, 80],
  'display_kernel_verbose' => [FalseClass, false],
  'backend_level' => [String, ''],
}

def common_options(opts)
  opts.on('-b', '--backend BACKEND', Array) do |v|
    $options[:backends] = v
  end

  opts.on('--debug') do |v|
    $options[:debug] = true
  end

  opts.on('-v', '--version', 'Print the version string') do
    puts File.read(File.join(DATADIR, 'version'))
    exit
  end
end

subcommands = {
  'trace' =>
    OptionParser.new do |opts|
      opts.banner = 'Usage: babeltrace_thapi [OPTIONS] trace_directory...'
      common_options(opts)

      opts.on('-c', '--[no-]context', 'Add context information') do |context|
        $options[:context] = context
      end

      opts.on('-r', '--[no-]restrict', 'Restrict output to recognized events') do |restrict|
        $options[:restrict] = restrict
      end

      opts.on('-h', '--help', 'Prints this help') do
        puts opts
        exit
      end

      opts.on('--live', 'Enable live display of the trace') do
        $options[:live] = true
      end
    end,
  'aggreg_live' =>
    OptionParser.new do |opts|
      opts.banner = 'Usage: aggreg_live [OPTIONS]'
      common_options(opts)

      opts.on('--inputs=INPUTS') do |inputs|
        $options[:inputs] =  [inputs]
      end

      opts.on('--output=OUTPUT') do |output|
        $options[:output] = output
      end

    end,
  'tally' =>
    OptionParser.new do |opts|
      opts.banner = 'Usage: tally [OPTIONS] trace_directory...'
      common_options(opts)

      opts.on('--live', 'Enable live display of the trace') do
        $options[:live] = true
      end

      $options_tally.each do |k, (t, _)|
        opts.on("--#{k}=VALUE", t) do |v|
          $options_tally[k] = [t, v]
        end
      end
    end,
  'timeline' =>
    OptionParser.new do |opts|
      opts.banner = 'Usage: timeline [OPTIONS] trace_directory...'
      common_options(opts)
    end,
}

$options.merge!($options_tally)
if ARGV.empty? || ARGV[0] == '--help'
  puts subtext
  exit
end

ARGV.insert(0, 'trace') unless subcommands.include?(ARGV.first)
command = ARGV.shift
subcommands[command].order!
# Fix segfault
ARGV.uniq!

# BT "native" component classes
components_classes = {
  'source.ctf.fs' => BT2::BTPlugin.find('ctf').get_source_component_class_by_name('fs'),
  'source.ctf.lttng_live' => BT2::BTPlugin.find('ctf').get_source_component_class_by_name('lttng-live'),
  'filter.utils.muxer' => BT2::BTPlugin.find('utils').get_filter_component_class_by_name('muxer'),
  'sink.text.pretty' => BT2::BTPlugin.find('text').get_sink_component_class_by_name('pretty'),
  'sink.ctf.fs' => BT2::BTPlugin.find('ctf').get_sink_component_class_by_name('fs'),
}

# THAPI components
thapi_plugins = BT2::BTPlugin.find_all_from_dir(File.join('@prefix@', 'lib'))
thapi_plugins.map do |pg|
  pg.source_component_classes.each { |c| components_classes["source.#{pg.name}.#{c.name}"] = c }
  pg.filter_component_classes.each { |c| components_classes["filter.#{pg.name}.#{c.name}"] = c }
  pg.sink_component_classes.each { |c| components_classes["sink.#{pg.name}.#{c.name}"] = c }
end

graph = BT2::BTGraph.new

# Source components
case command
when 'aggreg_live'
  ctf_lttng_live = components_classes.fetch('source.ctf.lttng_live')
  comp_sources = [ graph.add_component(ctf_lttng_live, "source_live",
                      params: { 'inputs' => $options[:inputs], 'session-not-found-action' => 'end' }) ]
else
  ctf_fs = components_classes.fetch('source.ctf.fs')

  trace_locations =
    Find.find(*ARGV).reject do |path|
      FileTest.directory?(path)
    end.select do |path|
      File.basename(path) == 'metadata'
    end.collect do |path|
      File.dirname(path)
    end.select do |path|
      qe = BT2::BTQueryExecutor.new(component_class: ctf_fs, object_name: 'babeltrace.support-info',
                                    params: { 'input' => path, 'type' => 'directory' })
      qe.query.value['weight'] > 0.5
    end

  comp_sources = trace_locations.each_with_index.map do |trace_location, i|
    graph.add_component(ctf_fs, "source_#{i}", params: { 'inputs' => [trace_location] })
  end
end

# Muxer components
comp_muxer = graph.add_component(components_classes.fetch('filter.utils.muxer'), 'muxer')

# Sources to muxer connection
comp_sources.flat_map(&:output_ports).each_with_index do |op, i|
  ip = comp_muxer.input_port(i)
  graph.connect_ports(op, ip)
end

# Rest of graph components
comps = []
case command
when 'trace'
  # Yaml and event_lambdas are required by babeltrace*_lib
  $event_lambdas = {}
  require 'yaml'
  require 'babeltrace_omp_lib' if $options[:backends].include?('omp')
  require 'babeltrace_opencl_lib' if $options[:backends].include?('cl')
  require 'babeltrace_ze_lib' if $options[:backends].include?('ze')
  require 'babeltrace_cuda_lib' if $options[:backends].include?('cuda')
  require 'babeltrace_hip_lib' if $options[:backends].include?('hip')

  consume = lambda { |iterator, _|
    iterator.next_messages.each do |m|
      next unless m.type == :BT_MESSAGE_TYPE_EVENT

      e = m.event
      l = $event_lambdas[e.name]
      next unless l || !$options[:restrict]

      str = "#{Time.at(0, m.get_default_clock_snapshot.ns_from_origin, :nsec).strftime('%H:%M:%S.%9L')}"
      if $options[:context]
        str << " - #{e.stream.trace.get_environment_entry_value_by_name('hostname')}"
        str << ' - ' << e.get_common_context_field.value.collect do |k, v|
          "#{k}: #{v}"
        end.join(', ')
      end
      str << " - #{e.name}: "
      str << (l ? l.call(e.payload_field.value) : e.payload_field.to_s)
      puts str
    end
  }
  comps << graph.add_simple_sink('babeltrace_thapi', consume)
when 'tally'
  $options[:backends].each do |name|
    comps << graph.add_component(components_classes.fetch("filter.#{name}interval.interval"), "#{name}interval")
  end
  comps << graph.add_component(components_classes.fetch('filter.btx_aggreg.aggreg'), 'aggreg')
  comps << graph.add_component(components_classes.fetch('sink.btx_tally.tally'), 'tally',
                               params: $options_tally.transform_values { |_, v| v })
when 'tally'
  $options[:backends].each do |name|
    comps << graph.add_component(components_classes.fetch("filter.#{name}interval.interval"), "#{name}interval")
  end
  comps << graph.add_component(components_classes.fetch('filter.btx_aggreg.aggreg'), 'aggreg')
  comps << graph.add_component(components_classes.fetch('sink.btx_tally.tally'), 'tally',
                               params: $options_tally.transform_values { |_, v| v })
when 'aggreg_live'
  $options[:backends].each do |name|
    comps << graph.add_component(components_classes.fetch("filter.#{name}interval.interval"), "#{name}interval")
  end
  comps << graph.add_component(components_classes.fetch('sink.ctf.fs'), 'ctf_sink',
                               params: {"path" => $options[:output]})
end

# Muxer to serial part
[comp_muxer, comps].flatten.each_cons(2) do |_out, _in|
  op = _out.output_port(0)
  ip = _in.input_port(0)
  graph.connect_ports(op, ip)
end

if $options[:debug]
  cli = graph.cli
  #puts cli
  puts "babeltrace_thapi: babeltrace2 cli command will be saved in ./babeltrace_thapi_cli.sh"
  $stdout.flush
  File::open('babeltrace_thapi_cli.sh','w') { |f| f.write(cli) }
end

graph.run
