#include <string>
#include <iomanip>
#include <climits>
#include <unordered_map>
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>

#include "babeltrace2/babeltrace.h"

typedef intptr_t    process_id_t;
typedef uintptr_t   thread_id_t;
typedef std::string hostname_t;
typedef std::string thapi_function_name;
typedef uintptr_t   thapi_device_id;

<%# Represent a device and a sub device %>
typedef std::tuple<thapi_device_id, thapi_device_id> dsd_t;

<%# Represent a start and a timestamp %>
typedef std::tuple<thapi_function_name, size_t> fn_ts_t;
typedef std::tuple<thread_id_t, thapi_function_name, size_t> tfn_ts_t;

typedef std::tuple<hostname_t, process_id_t> hp_t;
typedef std::tuple<hostname_t, process_id_t, thread_id_t> hpt_t;
typedef std::tuple<hostname_t, process_id_t, thread_id_t, thapi_function_name> hpt_function_name_t;
typedef std::tuple<thread_id_t, thapi_function_name> t_function_name_t;
typedef std::tuple<hostname_t, process_id_t, thread_id_t, thapi_device_id, thapi_device_id> hpt_dsd_t;
typedef std::tuple<hostname_t, process_id_t, thread_id_t, thapi_device_id, thapi_device_id, thapi_function_name> hpt_device_function_name_t;
typedef std::tuple<hostname_t, process_id_t, thapi_device_id> hp_device_t;
typedef std::tuple<hostname_t, process_id_t, thapi_device_id, thapi_device_id> hp_dsd_t;

typedef std::tuple<hostname_t, process_id_t, cl_command_queue> hp_command_queue_t;
typedef std::tuple<hostname_t, process_id_t, cl_event> hp_event_t;
typedef std::tuple<hostname_t, process_id_t, cl_kernel> hp_kernel_t;
typedef std::tuple<uint64_t, uint64_t> sd_t; // Start, Duration

// https://stackoverflow.com/questions/7110301/generic-hash-for-tuples-in-unordered-map-unordered-set
// Hash of std tuple
namespace std{
    namespace
    {
        // Code from boost
        // Reciprocal of the golden ratio helps spread entropy
        //     and handles duplicates.
        // See Mike Seymour in magic-numbers-in-boosthash-combine:
        //     https://stackoverflow.com/questions/4948780
        template <class T>
        inline void hash_combine(std::size_t& seed, T const& v)
        {
            seed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);
        }

        // Recursive template code derived from Matthieu M.
        template <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>
        struct HashValueImpl
        {
          static void apply(size_t& seed, Tuple const& tuple)
          {
            HashValueImpl<Tuple, Index-1>::apply(seed, tuple);
            hash_combine(seed, get<Index>(tuple));
          }
        };

        template <class Tuple>
        struct HashValueImpl<Tuple,0>
        {
          static void apply(size_t& seed, Tuple const& tuple)
          {
            hash_combine(seed, get<0>(tuple));
          }
        };
    }

    template <typename ... TT>
    struct hash<std::tuple<TT...>>
    {
        size_t
        operator()(std::tuple<TT...> const& tt) const
        {
            size_t seed = 0;
            HashValueImpl<std::tuple<TT...> >::apply(seed, tt);
            return seed;
        }

    };
}

/*
Utils function
*/
const hostname_t borrow_hostname(const bt_event *event){
    const bt_stream *stream = bt_event_borrow_stream_const(event);
    const bt_trace *trace = bt_stream_borrow_trace_const(stream);
    const bt_value *host_name_str = bt_trace_borrow_environment_entry_value_by_name_const(trace, "hostname");
    return  bt_value_string_get(host_name_str);
}

process_id_t borrow_process_id(const bt_event *event){
    const bt_field *common_context_field = bt_event_borrow_common_context_field_const(event);
    const bt_field *field = bt_field_structure_borrow_member_field_by_index_const(common_context_field, 0);
    return bt_field_integer_signed_get_value(field);
}

thread_id_t borrow_thread_id(const bt_event *event){
    const bt_field *common_context_field = bt_event_borrow_common_context_field_const(event);
    const bt_field *field = bt_field_structure_borrow_member_field_by_index_const(common_context_field, 1);
    return bt_field_integer_unsigned_get_value(field);
}

template <typename T>
std::string to_string_with_precision(const T a_value, const std::string extension, const int n = 2)
{
    std::ostringstream out;
    out.precision(n);
    out << std::fixed << a_value << extension;
    return out.str();
}

template <typename T>
std::string format_byte(const T duration) {
<%[  ['TB',  '1e+12'],
     ['GB', '1e+9'],
     ['MB',   '1e+6'],
     ['kB',   '1e+3'],
     ['B', '1']].each do | unit, factor |  %>
    const double <%= unit %> = duration / <%= factor %>;
    if (<%= unit %> >= 1.) {
        return  to_string_with_precision(<%= unit %>, "<%= unit %>");
    }
<% end %>
    return "";
}


template <typename T>
std::string format_time(const T duration) {
<% [['h',  '3.6e+12'],
    ['min', '6e+10'],
    ['s', '1e+9'],
    ['ms', '1e+6'],
    ['us', '1e+3'],
    ['ns', '1']].each do | unit, factor |  %>
    const double <%= unit %> = duration / <%= factor %>;
    if (<%= unit %> >= 1.) {
        return  to_string_with_precision(<%= unit %>, "<%= unit %>");
    }
<% end %>
    return "";
}

/*
Class for time
 */

struct StatIprof_string {
    std::string time;
    std::string time_ratio;
    std::string count;
    std::string avg;
    std::string min;
    std::string max;
    std::string error;
};

class StatIprof {
    uint64_t _start;

  public:
    uint64_t _total_time{1};
    void start(const int64_t);
    void stop(const int64_t);
    void delta(const uint64_t);
    void merge(StatIprof);
    void set_error(void);
    StatIprof_string to_string(const uint64_t);

    //Used in merge
    uint64_t _count{0};
    uint64_t _min{ULONG_MAX};
    uint64_t _max{0};
    uint64_t _time{0};
    bool _finished{true};
    uint64_t _error{0};
    
};

void StatIprof::start(const int64_t start) {
   _start  = start;
   _finished = false;
}

void StatIprof::stop(const int64_t stop) {
   const uint64_t  delta = stop - _start;
   _min = std::min(_min,delta);
   _max = std::max(_max,delta);
   _count++;
   _time += delta;
   _finished = true;
}

void StatIprof::set_error() {
    _error++;
}
void StatIprof::delta(const uint64_t delta) {
   _min = std::min(_min,delta);
   _max = std::max(_max,delta);
   _count++;
   _time += delta;
}

void StatIprof::merge(StatIprof st) {
   _min = std::min(_min,st._min);
   _max = std::max(_max,st._max);
   // total can overflow. Need to handle that correctly at some point...
   _count += st._count;
   _time += st._time;
   _finished = _finished && st._finished;
   _error += st._error;
}

<% { "StatTime" => "format_time",
     "StatByte" => "format_byte" }.each do |n,t| %>
class <%= n %>: public StatIprof {
   public:
     StatIprof_string to_string(const uint64_t total_time){
        const double avg = _count ? _time / _count : 0.;
        return StatIprof_string{<%= t %>(_time), // Time
                                to_string_with_precision( (100.*_time / total_time), "%"), // Percent
                                to_string_with_precision(_count,"",0), // Count
                                <%= t %>(avg),
                                <%= t %>(_min != ULONG_MAX ? _min : 0),
                                <%= t %>(_max),
                                to_string_with_precision(_error,"",0)};
    }
};
<% end %>


<%# Glolbal variable %>
std::unordered_map<hpt_device_function_name_t, StatTime> device_id_result;
std::unordered_map<hpt_function_name_t, StatTime> api_call;
std::unordered_map<hpt_function_name_t, StatByte> memory_trafic;
std::unordered_map<hp_device_t, std::string> device_to_name;
std::unordered_map<hp_device_t, thapi_device_id> device_to_rootdevice;

std::unordered_map<hpt_t, thapi_device_id> start_device;
std::unordered_map<hpt_t, thapi_function_name> profiled_function_name;


std::unordered_map<hpt_t, fn_ts_t> profiled_function_name_and_ts;



std::unordered_map<hpt_function_name_t, dsd_t> function_name_to_dsd;
<%#
   _
  |_) ._ o ._ _|_    /\  ._ ._ _.
  |   |  | | | |_   /--\ |  | (_| \/
                                  /
%>

<% l_menbers = ['function_name', 'time','time_ratio','count','avg','min','max','error'] %>
<% d_headers = [ ["StatTime","format_time",  [ 'Name', 'Time', 'Time(%)', 'Calls', 'Average', 'Min', 'Max', 'Failed'] ],
                 ["StatByte", "format_byte", [ 'Name', 'Byte', 'Byte(%)', 'Calls', 'Average', 'Min', 'Max', 'Failed'] ] ]  %>

 <% d_headers.each do | main_type, main_function, l_headers | %>
void print_array(std::unordered_map<thapi_function_name, <%= main_type %> > aggregated, std::string header, unsigned int _print_error= 0) {
    <%# print_error = 0 -> Never print error
                    = 1 -> Print only when error
                    >= 2 -> Always print error
    %>

    uint64_t total_time{0};
    uint64_t total_count{0};
    uint64_t total_error{0};
    for (std::pair<thapi_function_name,  <%= main_type %> > element: aggregated) {
        total_time += element.second._time;
        total_count += element.second._count;
        total_error += element.second._error;
   }
   if (!total_count) {
        return;
   }
   std::cout << header << std::endl;

   bool print_error;
   if (_print_error == 0)
        print_error = false;
   else if (_print_error == 1)
    print_error = total_error != 0;
   else
        print_error = true;

<%# Need to be bigger than the header %>
<% l_menbers.zip(l_headers).each do |v, n| %>
   uint64_t len_max_<%= v %> = <%= n.size() %>;
<% end %>

<%# Need to be bigger than the footer %>
   len_max_function_name = std::max(len_max_function_name,  uint64_t{<%= "Total".size() %>} );
   len_max_time = std::max(len_max_time, <%= main_function %>(total_time).size());
   len_max_count = std::max(len_max_count, to_string_with_precision(total_count,"",0).size() );
   len_max_error = std::max(len_max_error, to_string_with_precision(total_error,"",0).size() );

<%# Need to be bigger than the body %>
   for (std::pair<thapi_function_name,  <%= main_type %> > element: aggregated) {
       len_max_function_name =  std::max(len_max_function_name,  element.first.size());
       const auto [time, time_ratio, count, avg, min, max, error ] = element.second.to_string(total_time);
  <% l_menbers.drop(1).each do |v| %>
       len_max_<%= v %> = std::max(len_max_<%= v %>, <%= v %>.size());
<% end %>
   }

<%# Sort the table %>
   std::vector<std::pair<thapi_function_name,  <%= main_type %> >> array_sorted(aggregated.begin(), aggregated.end());
   std::sort(array_sorted.begin(), array_sorted.end(), [](auto a, auto b) { return a.second._time > b.second._time;} );

<%# Print Header %>
<% l_menbers.zip(l_headers).each do |v, n| %>
    <% if v == "error" %>
   if (print_error)
    <% end %>
   std::cout << std::setw(len_max_<%= v %>) << std::right << "<%= n %>" << " | ";
    
<% end %>
   std::cout << std::endl;

<%# Print Body %>
   for (std::pair<thapi_function_name,  <%= main_type %> > element: array_sorted) {
        const thapi_function_name function_name = element.first;
        const auto [time, time_ratio, count, avg, min, max, error ] = element.second.to_string(total_time);
<% l_menbers.each do |v | %>
    <% if v == "error" %>
        if (print_error)
    <% end %>
        std::cout << std::setw(len_max_<%= v %>) << std::right << <%= v %> << " | ";
<% end %>
        std::cout << std::endl;
    }

<%# Print footer %>
   std::cout << std::setw(len_max_function_name) << std::right << "Total" << " | "
             << std::setw(len_max_time) << std::right << <%= main_function %>(total_time) << " | "
             << std::setw(len_max_time_ratio) << std::right << "100.00%" << " | "
             << std::setw(len_max_count) << std::right <<  to_string_with_precision(total_count,"",0) << " | ";
 if (print_error) {
    std::cout
         <% l_menbers.zip(l_headers).drop(4).each do |v,n| %>
                <% if v == "error" %>
                    << std::setw(len_max_error) << std::right <<  to_string_with_precision(total_error,"",0) << " | "
                <% else %>
                    << std::setw(len_max_<%= v %>) << "" << "   "
                <% end %>
            <% end %>
            ;
 }           
 std::cout << std::endl;
}

<% end %>

<%#
   _
  |_) ._ o ._ _|_    /\  ._ ._ _.
  |   |  | | | |_   /--\ |  | (_| \/
                                  /
%>

   <% output = [ ['StatTime', 'api_call', 'API calls', '1', 'hpt_t',
                    [ ['hostname_t','Hostnames','Hostname'],
                      ['process_id_t','Processes','Process'],
                      ['thread_id_t','Threads','Thread'] ] ],
                 ['StatTime', 'device_id_result','Device profiling', '0', 'hpt_dsd_t',
                    [ ['hostname_t','Hostnames','Hostname'],
                      ['hp_t','Processes','Process'],
                      ['hpt_t','Threads','Thread'] ,
                      ['hp_device_t','Device pointers','Device'],
                      ['hp_dsd_t','SubDevice pointers','SubDevice'] ] ],
                 ['StatByte', 'memory_trafic', 'Explicit memory trafic', '0', 'hpt_t',
                    [ ['hostname_t','Hostnames','Hostname'],
                      ['process_id_t','Processes','Process'],
                      ['thread_id_t','Threads','Thread'] ] ],
   ] %>

<% output.each do |main_type, result,header, error, type, var| %>
void print_compact_<%= result %>(){
   <% var.each do |t,n,_ | %>
   std::set<<%= t %>> s_<%= n.gsub(' ','_') %>;
    <% end %>
    <%# Agreagate API Call Result and compute total time spend %>
   std::unordered_map<thapi_function_name, <%= main_type %> > aggregated;
   for (auto element: <%= result %>)
   {
       auto [ <%= var.map{ |t,n| n.gsub(' ','_')}.join(',') %>,function_name ] = element.first;
       const <%= main_type %> time = element.second;
        if (!time._finished) {
            std::cerr << "Warning: " << function_name << " didn't finish! Therefore it will not be accounted for." << std::endl;
            continue;
        }
    <% if type == "hpt_dsd_t" %>
       s_Hostnames.insert(hostname_t{Hostnames} ) ;
       s_Processes.insert(hp_t{Hostnames,Processes} ) ;
       s_Threads.insert(hpt_t{Hostnames,Processes,Threads} ) ;
       s_Device_pointers.insert(hp_device_t{Hostnames,Processes,Device_pointers} ) ;
       <%# This is apporixmation. Maybe two sub device alias to the same pointer. We cannot post-process that. But good enought to give a name %>
       s_SubDevice_pointers.insert(hp_dsd_t{Hostnames,Processes,Device_pointers,SubDevice_pointers} ) ;
    <% else %>
    <% var.each do | _, n,_ | %>
       s_<%=  n.gsub(' ','_') %>.insert(<%= n.gsub(' ','_') %>) ;
    <% end %>
    <% end %>
       aggregated[function_name].merge(time);
       }
       <% if type == "hpt_dsd_t" %>
        for (auto element: s_SubDevice_pointers) {
            auto [ _a, _b, d1, d2 ] = element;
            (void)_a; (void)_b; <%# Use un-used variable %>
            if ( d1 == d2 ) {
                s_SubDevice_pointers.erase(element);
            }
        }
        
   <% end %>
   std::ostringstream oss;
   oss << "<%= header %>";
   <% var.each do | _, n,_ | %>
   if (s_<%= n.gsub(' ','_') %>.size() != 0)
       oss << " | " << s_<%=  n.gsub(' ','_') %>.size() << " <%= n %>";
   <% end %>
   oss << std::endl;
   print_array(aggregated,oss.str(), <%= error %>);
   std::cout << std::endl;
};


   <% output = [ ['StatTime', 'api_call', 'API calls', '1', 'hpt_t',
                    [ ['hostname_t','Hostnames','Hostname'],
                      ['process_id_t','Processes','Process'],
                      ['thread_id_t','Threads','Thread'] ] ],
                 ['StatTime', 'device_id_result','Device profiling', '0', 'hpt_dsd_t',
                    [ ['hostname_t','Hostnames','Hostname'],
                      ['process_id_t','Processes','Process'],
                      ['thread_id_t','Threads','Thread'] ,
                      ['thapi_device_id','Device pointers','Device'],
                      ['thapi_device_id','SubDevice pointers','SubDevice'] ] ],
                 ['StatByte', 'memory_trafic', 'Explicit memory trafic', '0', 'hpt_t',
                    [ ['hostname_t','Hostnames','Hostname'],
                      ['process_id_t','Processes','Process'],
                      ['thread_id_t','Threads','Thread'] ] ],
   ] %>

void print_extented_<%= result %>(){

  <% args = var.map{ |t,_,n| n}.join(',') %>
  std::unordered_map< <%= type %>, std::unordered_map<thapi_function_name, <%= main_type %> >> d;
  for (auto [s, time]: <%= result %> ) {
    auto [<%= args %>, function_name] = s;
    if (!time._finished) {
        std::cerr << "Warning: " << function_name << " didn't finish! Therefore it will not be accounted for." << std::endl;
        continue;
   }
    d[ <%= type %>( <%= args %> )][function_name].merge(time);
  }

  std::vector<std::pair< <%= type %> , std::unordered_map<thapi_function_name,  <%= main_type %> >>> array_sorted(d.begin(), d.end());
  std::sort(array_sorted.begin(), array_sorted.end(),   [](auto a, auto b) { return a.first > b.first ; } );

  for (auto[s, aggregated]: array_sorted) {
    auto [ <%= args %> ] = s;
    std::ostringstream oss;
    
    <% if type == "hpt_dsd_t" %>
    if  (Device != SubDevice) {
    <% end %> 
    oss <<  "<%= header %>"
    <% var.each do | _,_, n | %>
        << " | <%= n %>: " 
        <% if n.include?('Device') %>
        << std::hex << std::showbase << std::internal << std::setfill('0')
        <% end %>
        << <%= n %>
            <% if n =='Device' and result == 'device_id_result' %>
        <<  " (" << device_to_name[hp_device_t(Hostname,Process,Device)] << ")"
            <% end %>
    <% end %>
        << std::endl;
    <% if type == "hpt_dsd_t" %>
     } else { 
    oss <<  "<%= header %>"
    <% var.map{| _,_, n | n}.filter{ |n| n != 'SubDevice'}.each do |n| %>
        << " | <%= n %>: "
        <% if n == 'Device' %>
        << std::hex << std::showbase << std::internal << std::setfill('0')
        <% end %>
        << <%= n %>
        <% if n =='Device' and result == 'device_id_result' %>
        <<  " (" << device_to_name[hp_device_t(Hostname,Process,Device)] << ")"
        <% end %>
     <% end %>
        << std::endl;
    }
    <% end %>
     print_array(aggregated, oss.str(), <%= error %>);
     std::cout << std::endl;
   }
};
<% end %>
