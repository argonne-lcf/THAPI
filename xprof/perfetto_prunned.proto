// AUTOGENERATED - DO NOT EDIT
// ---------------------------
// This file has been generated by
// AOSP://external/perfetto/tools/gen_merged_protos
// merging the perfetto config protos.
// This fused proto is intended to be copied in:
//  - Android tree, for statsd.
//  - Google internal repos.

syntax = "proto2";

package perfetto_pruned;
// Begin of protos/perfetto/common/track_event_descriptor.proto

message TrackEventCategory {
  optional string name = 1;
  optional string description = 2;
  repeated string tags = 3;
}

message TrackEventDescriptor {
  repeated TrackEventCategory available_categories = 1;
}

// End of protos/perfetto/common/track_event_descriptor.proto

// Begin of protos/perfetto/common/data_source_descriptor.proto

// This message is sent from Producer(s) to the tracing Service when registering
// to advertise their capabilities. It describes the structure of tracing
// protos that will be produced by the data source and the supported filters.
message DataSourceDescriptor {
  // e.g., "linux.ftrace", "chromium.tracing"
  optional string name = 1;

  // When non-zero, this is a unique ID within the scope of the Producer for
  // this data source (it is NOT globally unique). This is useful to
  // differentiate between data sources with matching names when calling
  // UpdateDataSource(). This field has been introduced in November 2021
  // (v22, Android T) and is not supported on older versions.
  optional uint64 id = 7;

  // When true the data source is expected to ack the stop request through the
  // NotifyDataSourceStopped() IPC. This field has been introduced after
  // Android P in Jul 2018 and is not supported on older versions.
  optional bool will_notify_on_stop = 2;

  // When true the data source is expected to ack the start request through the
  // NotifyDataSourceStarted() IPC. This field has been introduced after
  // Android P in March 2019 and is not supported on older versions.
  optional bool will_notify_on_start = 3;

  // If true, opt into receiving the ClearIncrementalState() IPC. This should be
  // set if the data source writes packets that refer to previous trace
  // contents, and knows how to stop referring to the already-emitted data.
  optional bool handles_incremental_state_clear = 4;

  // Optional specification about available GPU counters.
//  optional GpuCounterDescriptor gpu_counter_descriptor = 5 [lazy = true];

  optional TrackEventDescriptor track_event_descriptor = 6 [lazy = true];

  //optional FtraceDescriptor ftrace_descriptor = 8 [lazy = true];
}

// End of protos/perfetto/common/data_source_descriptor.proto

// Begin of protos/perfetto/common/tracing_service_state.proto

// Reports the state of the tracing service. Used to gather details about the
// data sources connected.
// See ConsumerPort::QueryServiceState().
// End of protos/perfetto/common/tracing_service_state.proto

// Begin of protos/perfetto/common/builtin_clock.proto

enum BuiltinClock {
  BUILTIN_CLOCK_UNKNOWN = 0;
  BUILTIN_CLOCK_REALTIME = 1;
  BUILTIN_CLOCK_REALTIME_COARSE = 2;
  BUILTIN_CLOCK_MONOTONIC = 3;
  BUILTIN_CLOCK_MONOTONIC_COARSE = 4;
  BUILTIN_CLOCK_MONOTONIC_RAW = 5;
  BUILTIN_CLOCK_BOOTTIME = 6;
  BUILTIN_CLOCK_MAX_ID = 63;

  reserved 7, 8;

  // An internal CL (ag/16521245) has taken this for BUILTIN_CLOCK_TSC.
  // That might get upstreamed later on. Avoid diverging on this ID in future.
  reserved 9;
}
// Next id: 12
message PerfEvents {
  // What event to sample on, and how often. Commented from the perspective of
  // its use in |PerfEventConfig|.
  message Timebase {
    // How often the per-cpu sampling will occur. Not guaranteed to be honored
    // as the kernel can throttle the sampling rate if it's too high.
    // If unset, an implementation-defined default is used.
    oneof interval {
      // Per-cpu sampling frequency in Hz, as requested from the kernel. Not the
      // same as 1/period.
      // Details: the actual sampling will still be based on a period, but the
      // kernel will dynamically adjust it based on the observed event rate, to
      // approximate this frequency. Works best with steady-rate events like
      // timers.
      uint64 frequency = 2;

      // Per-cpu sampling will occur every |period| counts of |event|.
      // Prefer |frequency| by default, as it's easier to oversample with a
      // fixed period.
      uint64 period = 1;
    }

    // Counting event to use as a timebase for the sampling.
    // If unset, implies the CPU timer (SW_CPU_CLOCK) as the event,
    // which is what you usually want.
    // See common/perf_events.proto for the definitions.
    oneof event {
      Counter counter = 4;
      Tracepoint tracepoint = 3;
      RawEvent raw_event = 5;
    }

    // If set, samples will be timestamped with the given clock.
    // If unset, the clock is chosen by the implementation.
    // For software events, prefer PERF_CLOCK_BOOTTIME. However it cannot be
    // used for hardware events (due to interrupt safety), for which the
    // recommendation is to use one of the monotonic clocks.
    optional PerfClock timestamp_clock = 11;

    // Optional arbitrary name for the event, to identify it in the parsed
    // trace. Does *not* affect the profiling itself. If unset, the trace
    // parser will choose a suitable name.
    optional string name = 10;
  }

  // Builtin counter names from the uapi header. Commented with their perf tool
  // aliases.
  // TODO(rsavitski): consider generating enums for cache events (should be
  // finite), and generally make this list as extensive as possible. Excluding
  // things like dynamic PMUs since those don't fit into a static enum.
  // Next id: 21
  enum Counter {
    UNKNOWN_COUNTER = 0;

    // cpu-clock
    SW_CPU_CLOCK = 1;
    // page-faults, faults
    SW_PAGE_FAULTS = 2;
    // task-clock
    SW_TASK_CLOCK = 3;
    // context-switches, cs
    SW_CONTEXT_SWITCHES = 4;
    // cpu-migrations, migrations
    SW_CPU_MIGRATIONS = 5;
    // minor-faults
    SW_PAGE_FAULTS_MIN = 6;
    // major-faults
    SW_PAGE_FAULTS_MAJ = 7;
    // alignment-faults
    SW_ALIGNMENT_FAULTS = 8;
    // emulation-faults
    SW_EMULATION_FAULTS = 9;
    // dummy
    SW_DUMMY = 20;

    // cpu-cycles, cycles
    HW_CPU_CYCLES = 10;
    // instructions
    HW_INSTRUCTIONS = 11;
    // cache-references
    HW_CACHE_REFERENCES = 12;
    // cache-misses
    HW_CACHE_MISSES = 13;
    // branch-instructions, branches
    HW_BRANCH_INSTRUCTIONS = 14;
    // branch-misses
    HW_BRANCH_MISSES = 15;
    // bus-cycles
    HW_BUS_CYCLES = 16;
    // stalled-cycles-frontend, idle-cycles-frontend
    HW_STALLED_CYCLES_FRONTEND = 17;
    // stalled-cycles-backend, idle-cycles-backend
    HW_STALLED_CYCLES_BACKEND = 18;
    // ref-cycles
    HW_REF_CPU_CYCLES = 19;
  }

  message Tracepoint {
    // Group and name for the tracepoint, acceptable forms:
    // * "sched/sched_switch"
    // * "sched:sched_switch"
    optional string name = 1;

    // Optional field-level filter for the tracepoint. Only events matching this
    // filter will be counted (and therefore contribute to the sampling period).
    // Example: "prev_pid >= 42 && next_pid == 0".
    // For full syntax, see kernel documentation on "Event filtering":
    // https://www.kernel.org/doc/Documentation/trace/events.txt
    optional string filter = 2;
  }

  // Syscall-level description of the event, propagated to the perf_event_attr
  // struct. Primarily for local use-cases, since the event availability and
  // encoding is hardware-specific.
  message RawEvent {
    optional uint32 type = 1;
    optional uint64 config = 2;
    optional uint64 config1 = 3;
    optional uint64 config2 = 4;
  }

  // Subset of clocks that is supported by perf timestamping.
  // CLOCK_TAI is excluded since it's not expected to be used in practice, but
  // would require additions to the trace clock synchronisation logic.
  enum PerfClock {
    UNKNOWN_PERF_CLOCK = 0;
    PERF_CLOCK_REALTIME = 1;
    PERF_CLOCK_MONOTONIC = 2;
    PERF_CLOCK_MONOTONIC_RAW = 3;
    PERF_CLOCK_BOOTTIME = 4;
  }
}

// End of protos/perfetto/common/perf_events.proto

// Begin of protos/perfetto/config/profiling/perf_event_config.proto

// Configuration for the traced_perf profiler.
//
// Example config for basic cpu profiling:
//   perf_event_config {
//     timebase {
//       frequency: 80
//     }
//     callstack_sampling {
//       scope {
//         target_cmdline: "surfaceflinger"
//         target_cmdline: "system_server"
//       }
//       kernel_frames: true
//     }
//   }
//
// Next id: 19
message PerfEventConfig {
  // What event to sample on, and how often.
  // Defined in common/perf_events.proto.
  optional PerfEvents.Timebase timebase = 15;

  // If set, the profiler will sample userspace processes' callstacks at the
  // interval specified by the |timebase|.
  // If unset, the profiler will record only the event counts.
  optional CallstackSampling callstack_sampling = 16;

  //
  // Kernel <-> userspace ring buffer options:
  //

  // How often the per-cpu ring buffers are read by the producer.
  // If unset, an implementation-defined default is used.
  optional uint32 ring_buffer_read_period_ms = 8;

  // Size (in 4k pages) of each per-cpu ring buffer that is filled by the
  // kernel. If set, must be a power of two.
  // If unset, an implementation-defined default is used.
  optional uint32 ring_buffer_pages = 3;

  //
  // Daemon's resource usage limits:
  //

  // Drop samples if the heap memory held by the samples in the unwinder queue
  // is above the given limit. This counts the memory across all concurrent data
  // sources (not just this one's), and there is no fairness guarantee - the
  // whole quota might be used up by a concurrent source.
  optional uint64 max_enqueued_footprint_kb = 17;

  // Stop the data source if traced_perf's combined {RssAnon + Swap} memory
  // footprint exceeds this value.
  optional uint32 max_daemon_memory_kb = 13;

  //
  // Uncommon options:
  //

  // Timeout for the remote /proc/<pid>/{maps,mem} file descriptors for a
  // sampled process. This is primarily for Android, where this lookup is
  // asynchronous. As long as the producer is waiting, the associated samples
  // will be kept enqueued (putting pressure on the capacity of the shared
  // unwinding queue). Once a lookup for a process expires, all associated
  // samples are discarded. However, if the lookup still succeeds after the
  // timeout, future samples will be handled normally.
  // If unset, an implementation-defined default is used.
  optional uint32 remote_descriptor_timeout_ms = 9;

  // Optional period for clearing state cached by the unwinder. This is a heavy
  // operation that is only necessary for traces that target a wide set of
  // processes, and require the memory footprint to be reset periodically.
  // If unset, the cached state will not be cleared.
  optional uint32 unwind_state_clear_period_ms = 10;

  // If set, only profile target if it was installed by a package with one of
  // these names. Special values:
  // * "@system": installed on the system partition
  // * "@product": installed on the product partition
  // * "@null": sideloaded
  // Supported on Android 12+.
  repeated string target_installed_by = 18;

  //
  // Deprecated (superseded by options above):
  //
  // Do not set *any* of these fields in new configs.
  //

  // Note: legacy configs had to set |all_cpus| to true to pass parsing.
  // We rely on this to detect such configs.
  optional bool all_cpus = 1;
  optional uint32 sampling_frequency = 2;
  optional bool kernel_frames = 12;
  repeated int32 target_pid = 4;
  repeated string target_cmdline = 5;
  repeated int32 exclude_pid = 6;
  repeated string exclude_cmdline = 7;
  optional uint32 additional_cmdline_count = 11;
  // previously |tracepoint|
  reserved 14;

  //
  // Sub-messages (nested for generated code namespacing).
  //

  message CallstackSampling {
    // Defines a set of processes for which samples are retained/skipped. If
    // unset, all samples are kept, but beware that it will be very heavy on the
    // stack unwinder, which might start dropping samples due to overload.
    optional Scope scope = 1;

    // If true, callstacks will include the kernel-space frames. Such frames can
    // be identified by a magical "kernel" string as their mapping name.
    // Requires traced_perf to be running as root, or kptr_restrict to have been
    // manually unrestricted. On Android, the platform should do the right thing
    // on debug builds.
    // This does *not* disclose KASLR, as only the function names are emitted.
    optional bool kernel_frames = 2;

    // Whether to record and unwind userspace callstacks. If unset, defaults to
    // including userspace (UNWIND_DWARF) both for backwards compatibility and
    // as the most common default (this defaulting is only applicable if the
    // outer CallstackSampling message is explicitly set).
    optional UnwindMode user_frames = 3;
  }

  message Scope {
    // Process ID (TGID) allowlist. If this list is not empty, only matching
    // samples will be retained. If multiple allow/deny-lists are
    // specified by the config, then all of them are evaluated for each sampled
    // process.
    repeated int32 target_pid = 1;

    // Command line allowlist, matched against the /proc/<pid>/cmdline (not the
    // comm string). The semantics of this field were changed since its original
    // introduction.
    //
    // On Android T+ (13+), this field can specify a single wildcard (*), and
    // the profiler will attempt to match it in two possible ways:
    // * if the pattern starts with a '/', then it is matched against the first
    //   segment of the cmdline (i.e. argv0). For example "/bin/e*" would match
    //   "/bin/echo".
    // * otherwise the pattern is matched against the part of argv0
    //   corresponding to the binary name (this is unrelated to /proc/pid/exe).
    //   For example "echo" would match "/bin/echo".
    //
    // On Android S (12) and below, both this pattern and /proc/pid/cmdline get
    // normalized prior to an exact string comparison. Normalization is as
    // follows: (1) trim everything beyond the first null or "@" byte; (2) if
    // the string contains forward slashes, trim everything up to and including
    // the last one.
    //
    // Implementation note: in either case, at most 511 characters of cmdline
    // are considered.
    repeated string target_cmdline = 2;

    // List of excluded pids.
    repeated int32 exclude_pid = 3;

    // List of excluded cmdlines. See description of |target_cmdline| for how
    // this is handled.
    repeated string exclude_cmdline = 4;

    // Niche features for systemwide callstacks:

    // Number of additional command lines to sample. Only those which are
    // neither explicitly included nor excluded will be considered. Processes
    // are accepted on a first come, first served basis.
    optional uint32 additional_cmdline_count = 5;

    // If set to N, all encountered processes will be put into one of the N
    // possible bins, and only one randomly-chosen bin will be selected for
    // unwinding. The binning is simply "pid % N", under the assumption that
    // low-order bits of pids are roughly uniformly distributed. Other explicit
    // inclusions/exclusions in this |Scope| message are still respected.
    //
    // The profiler will report the chosen shard in PerfSampleDefaults, and the
    // values will be queryable in trace processor under the "stats" table as
    // "perf_process_shard_count" and "perf_chosen_process_shard".
    //
    // NB: all data sources in a config that set |process_shard_count| must set
    // it to the same value. The profiler will choose one bin for all those data
    // sources.
    optional uint32 process_shard_count = 6;
  }

  // Userspace unwinding mode. A possible future addition is kernel-unwound
  // callchains for frame pointer based systems.
  enum UnwindMode {
    UNWIND_UNKNOWN = 0;
    // Do not unwind userspace:
    UNWIND_SKIP = 1;
    // Use libunwindstack (default):
    UNWIND_DWARF = 2;
  }
}

// End of protos/perfetto/config/profiling/perf_event_config.proto

// Begin of protos/perfetto/config/statsd/atom_ids.proto

// This enum is obtained by post-processing
// AOSP/frameworks/proto_logging/stats/atoms.proto through
// AOSP/external/perfetto/tools/update-statsd-descriptor, which extracts one
// enum value for each proto field defined in the upstream atoms.proto.




// Begin of protos/perfetto/config/sys_stats/sys_stats_config.proto

// This file defines the configuration for the Linux /proc poller data source,
// which injects counters in the trace.
// Counters that are needed in the trace must be explicitly listed in the
// *_counters fields. This is to avoid spamming the trace with all counters
// at all times.
// The sampling rate is configurable. All polling rates (*_period_ms) need
// to be integer multiples of each other.
// OK:     [10ms, 10ms, 10ms],  [10ms, 20ms, 10ms],  [10ms, 20ms, 60ms]
// Not OK: [10ms, 10ms, 11ms],  [10ms, 15ms, 20ms]
// End of protos/perfetto/config/sys_stats/sys_stats_config.proto

// Begin of protos/perfetto/config/system_info/system_info.proto

// This data-source does a one-off recording of system information when
// the trace starts.
// Currently this includes:
// - Values of
// /sys/devices/system/cpu/cpu*/cpufreq/scaling_available_frequencies This
// datasource has no configuration options at present.
message SystemInfoConfig {}

// End of protos/perfetto/config/system_info/system_info.proto

// Begin of protos/perfetto/config/test_config.proto

// The configuration for a fake producer used in tests.
message TestConfig {
  message DummyFields {
    optional uint32 field_uint32 = 1;
    optional int32 field_int32 = 2;
    optional uint64 field_uint64 = 3;
    optional int64 field_int64 = 4;
    optional fixed64 field_fixed64 = 5;
    optional sfixed64 field_sfixed64 = 6;
    optional fixed32 field_fixed32 = 7;
    optional sfixed32 field_sfixed32 = 8;
    optional double field_double = 9;
    optional float field_float = 10;
    optional sint64 field_sint64 = 11;
    optional sint32 field_sint32 = 12;
    optional string field_string = 13;
    optional bytes field_bytes = 14;
  }

  // The number of messages the fake producer should send.
  optional uint32 message_count = 1;

  // The maximum number of messages which should be sent each second.
  // The actual obserced speed may be lower if the producer is unable to
  // work fast enough.
  // If this is zero or unset, the producer will send as fast as possible.
  optional uint32 max_messages_per_second = 2;

  // The seed value for a simple multiplicative congruential pseudo-random
  // number sequence.
  optional uint32 seed = 3;

  // The size of each message in bytes. Should be greater than or equal 5 to
  // account for the number of bytes needed to encode the random number and a
  // null byte for the string.
  optional uint32 message_size = 4;

  // Whether the producer should send a event batch when the data source is
  // is initially registered.
  optional bool send_batch_on_register = 5;

  optional DummyFields dummy_fields = 6;
}

// End of protos/perfetto/config/test_config.proto

// Begin of protos/perfetto/config/track_event/track_event_config.proto

message TrackEventConfig {
  // The following fields define the set of enabled trace categories. Each list
  // item is a glob.
  //
  // To determine if category is enabled, it is checked against the filters in
  // the following order:
  //
  //   1. Exact matches in enabled categories.
  //   2. Exact matches in enabled tags.
  //   3. Exact matches in disabled categories.
  //   4. Exact matches in disabled tags.
  //   5. Pattern matches in enabled categories.
  //   6. Pattern matches in enabled tags.
  //   7. Pattern matches in disabled categories.
  //   8. Pattern matches in disabled tags.
  //
  // If none of the steps produced a match, the category is enabled by default.
  //
  // Examples:
  //
  //  - To enable all non-slow/debug categories:
  //
  //       No configuration needed, happens by default.
  //
  //  - To enable a specific category:
  //
  //       disabled_categories = ["*"]
  //       enabled_categories = ["my_category"]
  //
  //  - To enable only categories with a specific tag:
  //
  //       disabled_tags = ["*"]
  //       enabled_tags = ["my_tag"]
  //

  // Default: []
  repeated string disabled_categories = 1;

  // Default: []
  repeated string enabled_categories = 2;

  // Default: ["slow", "debug"]
  repeated string disabled_tags = 3;

  // Default: []
  repeated string enabled_tags = 4;

  // Default: false (i.e. enabled by default)
  optional bool disable_incremental_timestamps = 5;

  // Allows to specify a custom unit different than the default (ns).
  // Also affects thread timestamps if enable_thread_time_sampling = true.
  // A multiplier of 1000 means that a timestamp = 3 should be interpreted as
  // 3000 ns = 3 us.
  // Default: 1 (if unset, it should be read as 1).
  optional uint64 timestamp_unit_multiplier = 6;

  // Default: false (i.e. debug_annotations is NOT filtered out by default)
  // When true, any debug annotations provided as arguments to the
  // TRACE_EVENT macros are not written into the trace. Typed arguments will
  // still be emitted even if set to true.
  optional bool filter_debug_annotations = 7;

  // Default : false (i.e. disabled)
  // When true, the SDK samples and emits the current thread time counter value
  // for each event on the current thread's track. This value represents the
  // total CPU time consumed by that thread since its creation. Note that if a
  // thread is not scheduled by OS for some duration, that time won't be
  // included in thread_time.
  // Learn more : "CLOCK_THREAD_CPUTIME_ID" flag at
  // https://linux.die.net/man/3/clock_gettime
  optional bool enable_thread_time_sampling = 8;

  // Default: false (i.e. dynamic event names are NOT filtered out by default)
  // When true, event_names wrapped in perfetto::DynamicString will be filtered
  // out.
  optional bool filter_dynamic_event_names = 9;
}

// End of protos/perfetto/config/track_event/track_event_config.proto

// Begin of protos/perfetto/config/data_source_config.proto

// The configuration that is passed to each data source when starting tracing.
// Next id: 124
message DataSourceConfig {
  enum SessionInitiator {
    SESSION_INITIATOR_UNSPECIFIED = 0;
    // This trace was initiated from a trusted system app has DUMP and
    // USAGE_STATS permission. This system app is expected to not expose the
    // trace to the user of the device.
    // This is determined by checking the UID initiating the trace.
    SESSION_INITIATOR_TRUSTED_SYSTEM = 1;
  };
  // Data source unique name, e.g., "linux.ftrace". This must match
  // the name passed by the data source when it registers (see
  // RegisterDataSource()).
  optional string name = 1;

  // The index of the logging buffer where TracePacket(s) will be stored.
  // This field doesn't make a major difference for the Producer(s). The final
  // logging buffers, in fact, are completely owned by the Service. We just ask
  // the Producer to copy this number into the chunk headers it emits, so that
  // the Service can quickly identify the buffer where to move the chunks into
  // without expensive lookups on its fastpath.
  optional uint32 target_buffer = 2;

  // Set by the service to indicate the duration of the trace.
  // DO NOT SET in consumer as this will be overridden by the service.
  optional uint32 trace_duration_ms = 3;

  // If true, |trace_duration_ms| should count also time in suspend. This
  // is propagated from TraceConfig.prefer_suspend_clock_for_duration.
  optional bool prefer_suspend_clock_for_duration = 122;

  // Set by the service to indicate how long it waits after StopDataSource.
  // DO NOT SET in consumer as this will be overridden by the service.
  optional uint32 stop_timeout_ms = 7;

  // Set by the service to indicate whether this tracing session has extra
  // guardrails.
  // DO NOT SET in consumer as this will be overridden by the service.
  optional bool enable_extra_guardrails = 6;

  // Set by the service to indicate which user initiated this trace.
  // DO NOT SET in consumer as this will be overridden by the service.
  optional SessionInitiator session_initiator = 8;

  // Set by the service to indicate which tracing session the data source
  // belongs to. The intended use case for this is checking if two data sources,
  // one of which produces metadata for the other one, belong to the same trace
  // session and hence should be linked together.
  // This field was introduced in Aug 2018 after Android P.
  // DO NOT SET in consumer as this will be overridden by the service.
  optional uint64 tracing_session_id = 4;

  // Keeep the lower IDs (up to 99) for fields that are *not* specific to
  // data-sources and needs to be processed by the traced daemon.

  // All data source config fields must be marked as [lazy=true]. This prevents
  // the proto-to-cpp generator from recursing into those when generating the
  // cpp classes and polluting tracing/core with data-source-specific classes.
  // Instead they are treated as opaque strings containing raw proto bytes.

  // Data source name: linux.ftrace
  //optional FtraceConfig ftrace_config = 100 [lazy = true];
  // Data source name: linux.inode_file_map
 // optional InodeFileConfig inode_file_config = 102 [lazy = true];
  // Data source name: linux.process_stats
  //optional ProcessStatsConfig process_stats_config = 103 [lazy = true];
  // Data source name: linux.sys_stats
 // optional SysStatsConfig sys_stats_config = 104 [lazy = true];
  // Data source name: android.heapprofd
  // Introduced in Android 10.
 // optional HeapprofdConfig heapprofd_config = 105 [lazy = true];
  // Data source name: android.java_hprof
  // Introduced in Android 11.
 // optional JavaHprofConfig java_hprof_config = 110 [lazy = true];
  // Data source name: android.power
 // optional AndroidPowerConfig android_power_config = 106 [lazy = true];
  // Data source name: android.log
 // optional AndroidLogConfig android_log_config = 107 [lazy = true];
  // TODO(fmayer): Add data source name for this.
 // optional GpuCounterConfig gpu_counter_config = 108 [lazy = true];
  // Data source name: android.game_interventions
 // optional AndroidGameInterventionListConfig
   //   android_game_intervention_list_config = 116 [lazy = true];
  // Data source name: android.packages_list
 // optional PackagesListConfig packages_list_config = 109 [lazy = true];
  // Data source name: linux.perf
  optional PerfEventConfig perf_event_config = 111 [lazy = true];
  // Data source name: vulkan.memory_tracker
 // optional VulkanMemoryConfig vulkan_memory_config = 112 [lazy = true];
  // Data source name: track_event
  optional TrackEventConfig track_event_config = 113 [lazy = true];
  // Data source name: android.polled_state
  //optional AndroidPolledStateConfig android_polled_state_config = 114
   //    [lazy = true];
  // Data source name: android.system_property
  // optional AndroidSystemPropertyConfig android_system_property_config = 118  [lazy = true];
  // Data source name: android.statsd
  //optional StatsdTracingConfig statsd_tracing_config = 117 [lazy = true];
  // Data source name: linux.system_info
  optional SystemInfoConfig system_info_config = 119;

  // Chrome is special as it doesn't use the perfetto IPC layer. We want to
  // avoid proto serialization and de-serialization there because that would
  // just add extra hops on top of the Mojo ser/des. Instead we auto-generate a
  // C++ class for it so it can pass around plain C++ objets.
  // optional ChromeConfig chrome_config = 101;

  // If an interceptor is specified here, packets for this data source will be
  // rerouted to the interceptor instead of the main trace buffer. This can be
  // used, for example, to write trace data into ETW or for logging trace points
  // to the console.
  //
  // Note that interceptors are only supported by data sources registered
  // through the Perfetto SDK API. Data sources that don't use that API (e.g.,
  // traced_probes) may not support interception.
  // optional InterceptorConfig interceptor_config = 115;

  // Data source name: android.network_packets.
  // Introduced in Android 14 (U).
  //optional NetworkPacketTraceConfig network_packet_trace_config = 120
    //  [lazy = true];

  // Data source name: android.surfaceflinger.layers
  // optional SurfaceFlingerLayersConfig surfaceflinger_layers_config = 121
    //  [lazy = true];

  // Data source name: android.surfaceflinger.transactions
 // optional SurfaceFlingerTransactionsConfig surfaceflinger_transactions_config =
   //   123 [lazy = true];

  // This is a fallback mechanism to send a free-form text config to the
  // producer. In theory this should never be needed. All the code that
  // is part of the platform (i.e. traced service) is supposed to *not* truncate
  // the trace config proto and propagate unknown fields. However, if anything
  // in the pipeline (client or backend) ends up breaking this forward compat
  // plan, this field will become the escape hatch to allow future data sources
  // to get some meaningful configuration.
  optional string legacy_config = 1000;

  // This field is only used for testing.
  optional TestConfig for_testing = 1001;

  // Was |for_testing|. Caused more problems then found.
  reserved 268435455;
}

// End of protos/perfetto/config/data_source_config.proto

// Begin of protos/perfetto/config/trace_config.proto

// The overall config that is used when starting a new tracing session through
// ProducerPort::StartTracing().
// It contains the general config for the logging buffer(s) and the configs for
// all the data source being enabled.
//
// Next id: 38.
message TraceConfig {
  message BufferConfig {
    optional uint32 size_kb = 1;

    // |page_size|, now deprecated.
    reserved 2;

    // |optimize_for|, now deprecated.
    reserved 3;

    enum FillPolicy {
      UNSPECIFIED = 0;

      // Default behavior. The buffer operates as a conventional ring buffer.
      // If the writer is faster than the reader (or if the reader reads only
      // after tracing is stopped) newly written packets will overwrite old
      // packets.
      RING_BUFFER = 1;

      // Behaves like RING_BUFFER as long as there is space in the buffer or
      // the reader catches up with the writer. As soon as the writer hits
      // an unread chunk, it stops accepting new data in the buffer.
      DISCARD = 2;
    }
    optional FillPolicy fill_policy = 4;
  }
  repeated BufferConfig buffers = 1;

  message DataSource {
    // Filters and data-source specific config. It contains also the unique name
    // of the data source, the one passed in the  DataSourceDescriptor when they
    // register on the service.
    optional DataSourceConfig config = 1;

    // Optional. If multiple producers (~processes) expose the same data source
    // and either |producer_name_filter| or |producer_name_regex_filter| is set,
    // the data source is enabled only for producers whose names match any of
    // the filters.
    // |producer_name_filter| has to be an exact match, while
    // |producer_name_regex_filter| is a regular expression.
    // This allows to enable a data source only for specific processes.
    // The "repeated" fields have OR semantics: specifying a filter ["foo",
    // "bar"] will enable data sources on both "foo" and "bar" (if they exist).
    repeated string producer_name_filter = 2;
    repeated string producer_name_regex_filter = 3;
  }
  repeated DataSource data_sources = 2;

  // Config for disabling builtin data sources in the tracing service.
  message BuiltinDataSource {
    // Disable emitting clock timestamps into the trace.
    optional bool disable_clock_snapshotting = 1;

    // Disable echoing the original trace config in the trace.
    optional bool disable_trace_config = 2;

    // Disable emitting system info (build fingerprint, cpuinfo, etc).
    optional bool disable_system_info = 3;

    // Disable emitting events for data-source state changes (e.g. the marker
    // for all data sources having ACKed the start of the trace).
    optional bool disable_service_events = 4;

    // The authoritative clock domain for the trace. Defaults to BOOTTIME. See
    // also ClockSnapshot's primary_trace_clock. The configured value is written
    // into the trace as part of the ClockSnapshots emitted by the service.
    // Trace processor will attempt to translate packet/event timestamps from
    // various data sources (and their chosen clock domains) to this domain
    // during import. Added in Android R.
    optional BuiltinClock primary_trace_clock = 5;

    // Time interval in between snapshotting of sync markers, clock snapshots,
    // stats, and other periodic service-emitted events. Note that the service
    // only keeps track of the first and the most recent snapshot until
    // ReadBuffers() is called.
    optional uint32 snapshot_interval_ms = 6;

    // Hints to the service that a suspend-aware (i.e. counting time in suspend)
    // clock should be used for periodic snapshots of service-emitted events.
    // This means, if a snapshot *should* have happened during suspend, it will
    // happen immediately after the device resumes.
    //
    // Choosing a clock like this is done on best-effort basis; not all
    // platforms (e.g. Windows) expose a clock which can be used for periodic
    // tasks counting suspend. If such a clock is not available, the service
    // falls back to the best-available alternative.
    //
    // Introduced in Android S.
    // TODO(lalitm): deprecate this in T and make this the default if nothing
    // crashes in S.
    optional bool prefer_suspend_clock_for_snapshot = 7;

    // Disables the reporting of per-trace-writer histograms in TraceStats.
    optional bool disable_chunk_usage_histograms = 8;
  }
  optional BuiltinDataSource builtin_data_sources = 20;

  // If specified, the trace will be stopped |duration_ms| after starting.
  // This does *not* count the time the system is suspended, so we will run
  // for duration_ms of system activity, not wall time.
  //
  // However in case of traces with triggers, see
  // TriggerConfig.trigger_timeout_ms instead.
  optional uint32 duration_ms = 3;

  // If true, tries to use CLOCK_BOOTTIME for duration_ms rather than
  // CLOCK_MONOTONIC (which doesn't count time in suspend). Supported only on
  // Linux/Android, no-op on other platforms. This is used when dealing with
  // long (e.g. 24h) traces, where suspend can inflate them to weeks of
  // wall-time, making them more likely to hit device reboots (and hence loss).
  // This option also changes consistently the semantic of
  // TrigerConfig.stop_delay_ms.
  optional bool prefer_suspend_clock_for_duration = 36;

  // This is set when --dropbox is passed to the Perfetto command line client
  // and enables guardrails that limit resource usage for traces requested
  // by statsd.
  optional bool enable_extra_guardrails = 4;

  enum LockdownModeOperation {
    LOCKDOWN_UNCHANGED = 0;
    LOCKDOWN_CLEAR = 1;
    LOCKDOWN_SET = 2;
  }
  // Reject producers that are not running under the same UID as the tracing
  // service.
  optional LockdownModeOperation lockdown_mode = 5;

  message ProducerConfig {
    // Identifies the producer for which this config is for.
    optional string producer_name = 1;

    // Specifies the preferred size of the shared memory buffer. If the size is
    // larger than the max size, the max will be used. If it is smaller than
    // the page size or doesn't fit pages evenly into it, it will fall back to
    // the size specified by the producer or finally the default shared memory
    // size.
    optional uint32 shm_size_kb = 2;

    // Specifies the preferred size of each page in the shared memory buffer.
    // Must be an integer multiple of 4K.
    optional uint32 page_size_kb = 3;
  }

  repeated ProducerConfig producers = 6;

  // Contains statsd-specific metadata about an alert associated with the trace.
  message StatsdMetadata {
    // The identifier of the alert which triggered this trace.
    optional int64 triggering_alert_id = 1;
    // The uid which registered the triggering configuration with statsd.
    optional int32 triggering_config_uid = 2;
    // The identifier of the config which triggered the alert.
    optional int64 triggering_config_id = 3;
    // The identifier of the subscription which triggered this trace.
    optional int64 triggering_subscription_id = 4;
  }

  // Statsd-specific metadata.
  optional StatsdMetadata statsd_metadata = 7;

  // When true && |output_path| is empty, the EnableTracing() request must
  // provide a file descriptor. The service will then periodically read packets
  // out of the trace buffer and store it into the passed file.
  // If |output_path| is not empty no fd should be passed, the service
  // will create a new file and write into that (see comment below).
  optional bool write_into_file = 8;

  // This must point to a non-existing file. If the file exists the service
  // will NOT overwrite and will fail instead as a security precaution.
  // On Android, when this is used with the system traced, the path must be
  // within /data/misc/perfetto-traces/ or the trace will fail.
  // This option has been introduced in Android R. Before R write_into_file
  // can be used only with the "pass a file descriptor over IPC" mode.
  optional string output_path = 29;

  // Optional. If non-zero tunes the write period. A min value of 100ms is
  // enforced (i.e. smaller values are ignored).
  optional uint32 file_write_period_ms = 9;

  // Optional. When non zero the periodic write stops once at most X bytes
  // have been written into the file. Tracing is disabled when this limit is
  // reached, even if |duration_ms| has not been reached yet.
  optional uint64 max_file_size_bytes = 10;

  // Contains flags which override the default values of the guardrails inside
  // Perfetto.
  message GuardrailOverrides {
    // Override the default limit (in bytes) for uploading data to server within
    // a 24 hour period.
    // On R-, this override only affected userdebug builds. Since S, it also
    // affects user builds.
    optional uint64 max_upload_per_day_bytes = 1;

    // Overrides the guardrail for maximum trace buffer size.
    // Available on U+
    optional uint32 max_tracing_buffer_size_kb = 2;
  }
  optional GuardrailOverrides guardrail_overrides = 11;

  // When true, data sources are not started until an explicit call to
  // StartTracing() on the consumer port. This is to support early
  // initialization and fast trace triggering. This can be used only when the
  // Consumer explicitly triggers the StartTracing() method.
  // This should not be used in a remote trace config via statsd, doing so will
  // result in a hung trace session.
  optional bool deferred_start = 12;

  // When set, it periodically issues a Flush() to all data source, forcing them
  // to commit their data into the tracing service. This can be used for
  // quasi-real-time streaming mode and to guarantee some partial ordering of
  // events in the trace in windows of X ms.
  optional uint32 flush_period_ms = 13;

  // Wait for this long for producers to acknowledge flush requests.
  // Default 5s.
  optional uint32 flush_timeout_ms = 14;

  // Wait for this long for producers to acknowledge stop requests.
  // Default 5s.
  optional uint32 data_source_stop_timeout_ms = 23;

  // |disable_clock_snapshotting| moved.
  reserved 15;

  // Android-only. If set, sends an intent to the Traceur system app when the
  // trace ends to notify it about the trace readiness.
  optional bool notify_traceur = 16;

  // This field was introduced in Android S.
  // Android-only. If set to a value > 0, marks the trace session as a candidate
  // for being attached to a bugreport. This field effectively acts as a z-index
  // for bugreports. When Android's dumpstate runs perfetto
  // --save-for-bugreport, traced will pick the tracing session with the highest
  // score (score <= 0 is ignored) and:
  // On Android S, T:  will steal its contents, save the trace into
  //     a known path and stop prematurely.
  // On Android U+: will create a read-only snapshot and save that into a known
  //     path, without stoppin the original tracing session.
  // When this field is set the tracing session becomes eligible to be cloned
  // by other UIDs.
  optional int32 bugreport_score = 30;

  // Triggers allow producers to start or stop the tracing session when an event
  // occurs.
  //
  // For example if we are tracing probabilistically, most traces will be
  // uninteresting. Triggers allow us to keep only the interesting ones such as
  // those traces during which the device temperature reached a certain
  // threshold. In this case the producer can activate a trigger to keep
  // (STOP_TRACING) the trace, otherwise it can also begin a trace
  // (START_TRACING) because it knows something is about to happen.
  message TriggerConfig {
    enum TriggerMode {
      UNSPECIFIED = 0;

      // When this mode is chosen, data sources are not started until one of the
      // |triggers| are received. This supports early initialization and fast
      // starting of the tracing system. On triggering, the session will then
      // record for |stop_delay_ms|. However if no trigger is seen
      // after |trigger_timeout_ms| the session will be stopped and no data will
      // be returned.
      START_TRACING = 1;

      // When this mode is chosen, the session will be started via the normal
      // EnableTracing() & StartTracing(). If no trigger is ever seen
      // the session will be stopped after |trigger_timeout_ms| and no data will
      // be returned. However if triggered the trace will stop after
      // |stop_delay_ms| and any data in the buffer will be returned to the
      // consumer.
      STOP_TRACING = 2;

      // When this mode is chosen, this causes a snapshot of the current tracing
      // session to be created after |stop_delay_ms| while the current tracing
      // session continues undisturbed (% an extra flush). This mode can be
      // used only when the tracing session is handled by the "perfetto" cmdline
      // client (which is true in 90% of cases). Part of the business logic
      // necessary for this behavior, and ensuing file handling, lives in
      // perfetto_cmd.cc . On other consumers, this causes only a notification
      // of the trigger through a CloneTriggerHit ObservableEvent. The custom
      // consumer is supposed to call CloneSession() itself after the event.
      // Use use_clone_snapshot_if_available=true when targeting older versions
      // of perfetto.
      CLONE_SNAPSHOT = 3;

      // NOTE: CLONE_SNAPSHOT should be used only when we targeting Android U+
      // (14+) / Perfetto v34+. A bug in older versions of the tracing service
      // might cause indefinitely long tracing sessions (see b/274931668).
    }
    optional TriggerMode trigger_mode = 1;

    // This flag is really a workaround for b/274931668. This is needed only
    // when deploying configs to different versions of the tracing service.
    // When this is set to true this has the same effect of setting trigger_mode
    // to CLONE_SNAPSHOT on newer versions of the service. This boolean has been
    // introduced to allow to have configs that use CLONE_SNAPSHOT on newer
    // versions of Android and fall back to STOP_TRACING on older versions where
    // CLONE_SNAPSHOT did not exist.
    // When using this flag, trigger_mode must be set to STOP_TRACING.
    optional bool use_clone_snapshot_if_available = 4;

    message Trigger {
      // The producer must specify this name to activate the trigger.
      optional string name = 1;

      // An std::regex that will match the producer that can activate this
      // trigger. This is optional. If unset any producers can activate this
      // trigger.
      optional string producer_name_regex = 2;

      // After a trigger is received either in START_TRACING or STOP_TRACING
      // mode then the trace will end |stop_delay_ms| after triggering.
      // In CLONE_SNAPSHOT mode, this is the delay between the trigger and the
      // snapshot.
      // If |prefer_suspend_clock_for_duration| is set, the duration will be
      // based on wall-clock, counting also time in suspend.
      optional uint32 stop_delay_ms = 3;

      // Limits the number of traces this trigger can start/stop in a rolling
      // 24 hour window. If this field is unset or zero, no limit is applied and
      // activiation of this trigger *always* starts/stops the trace.
      optional uint32 max_per_24_h = 4;

      // A value between 0 and 1 which encodes the probability of skipping a
      // trigger with this name. This is useful for reducing the probability
      // of high-frequency triggers from dominating trace finaization. If this
      // field is unset or zero, the trigger will *never* be skipped. If this
      // field is greater than or equal to 1, this trigger will *always* be
      // skipped i.e. it will be as if this trigger was never included in the
      // first place.
      // This probability check is applied *before* any other limits. For
      // example, if |max_per_24_h| is also set, first we will check if the
      // probability bar is met and only then will we check the |max_per_24_h|
      // limit.
      optional double skip_probability = 5;
    }
    // A list of triggers which are related to this configuration. If ANY
    // trigger is seen then an action will be performed based on |trigger_mode|.
    repeated Trigger triggers = 2;

    // Required and must be positive if a TriggerConfig is specified. This is
    // how long this TraceConfig should wait for a trigger to arrive. After this
    // period of time if no trigger is seen the TracingSession will be cleaned
    // up.
    optional uint32 trigger_timeout_ms = 3;
  }
  optional TriggerConfig trigger_config = 17;

  // When this is non-empty the perfetto command line tool will ignore the rest
  // of this TraceConfig and instead connect to the perfetto service as a
  // producer and send these triggers, potentially stopping or starting traces
  // that were previous configured to use a TriggerConfig.
  repeated string activate_triggers = 18;

  // Configuration for trace contents that reference earlier trace data. For
  // example, a data source might intern strings, and emit packets containing
  // {interned id : string} pairs. Future packets from that data source can then
  // use the interned ids instead of duplicating the raw string contents. The
  // trace parser will then need to use that interning table to fully interpret
  // the rest of the trace.
  message IncrementalStateConfig {
    // If nonzero, notify eligible data sources to clear their incremental state
    // periodically, with the given period. The notification is sent only to
    // data sources that have |handles_incremental_state_clear| set in their
    // DataSourceDescriptor. The notification requests that the data source
    // stops referring to past trace contents. This is particularly useful when
    // tracing in ring buffer mode, where it is not exceptional to overwrite old
    // trace data.
    //
    // Warning: this time-based global clearing is likely to be removed in the
    // future, to be replaced with a smarter way of sending the notifications
    // only when necessary.
    optional uint32 clear_period_ms = 1;
  }
  optional IncrementalStateConfig incremental_state_config = 21;

  // Additional guardrail used by the Perfetto command line client.
  // On user builds when --dropbox is set perfetto will refuse to trace unless
  // this is also set.
  // Added in Q.
  optional bool allow_user_build_tracing = 19;

  // If set the tracing service will ensure there is at most one tracing session
  // with this key.
  optional string unique_session_name = 22;

  // Compress trace with the given method. Best effort.
  enum CompressionType {
    COMPRESSION_TYPE_UNSPECIFIED = 0;
    COMPRESSION_TYPE_DEFLATE = 1;
  }
  optional CompressionType compression_type = 24;

  // Use the legacy codepath that compresses from perfetto_cmd.cc instead of
  // using the new codepath that compresses from tracing_service_impl.cc. This
  // will be removed in the future.
  optional bool compress_from_cli = 37;

  // Android-only. Not for general use. If set, saves the trace into an
  // incident. This field is read by perfetto_cmd, rather than the tracing
  // service. This field must be set when passing the --upload flag to
  // perfetto_cmd.
  message IncidentReportConfig {
    // In this message, either:
    //  * all of |destination_package|, |destination_class| and |privacy_level|
    //    must be set.
    //  * |skip_incidentd| must be explicitly set to true.

    optional string destination_package = 1;
    optional string destination_class = 2;
    // Level of filtering in the requested incident. See |Destination| in
    // frameworks/base/core/proto/android/privacy.proto.
    optional int32 privacy_level = 3;

    // If true, then skips saving the trace to incidentd.
    //
    // This flag is useful in testing (e.g. Perfetto-statsd integration tests)
    // or when we explicitly don't want traces to go to incidentd even when they
    // usually would (e.g. configs deployed using statsd but only used for
    // inclusion in bugreports using |bugreport_score|).
    //
    // The motivation for having this flag, instead of just not setting
    // |incident_report_config|, is prevent accidents where
    // |incident_report_config| is omitted by mistake.
    optional bool skip_incidentd = 5;

    // If true, do not write the trace into dropbox (i.e. incident only).
    // Otherwise, write to both dropbox and incident.
    // TODO(lalitm): remove this field as we no longer use Dropbox.
    optional bool skip_dropbox = 4 [deprecated = true];
  }
  optional IncidentReportConfig incident_report_config = 25;

  enum StatsdLogging {
    STATSD_LOGGING_UNSPECIFIED = 0;
    STATSD_LOGGING_ENABLED = 1;
    STATSD_LOGGING_DISABLED = 2;
  }

  // Android-only. Not for general use. If specified, sets the logging to statsd
  // of guardrails and checkpoints in the tracing service. perfetto_cmd sets
  // this to enabled (if not explicitly set in the config) when specifying
  // --upload.
  optional StatsdLogging statsd_logging = 31;

  // DEPRECATED. Was trace_uuid, use trace_uuid_msb and trace_uuid_lsb instead.
  reserved 26;

  // An identifier clients can use to tie this trace to other logging.
  // DEPRECATED as per v32. See TracePacket.trace_uuid for the authoritative
  // Trace UUID. If this field is set, the tracing service will respect the
  // requested UUID (i.e. TracePacket.trace_uuid == this field) but only if
  // gap-less snapshotting is not used.
  optional int64 trace_uuid_msb = 27 [deprecated = true];
  optional int64 trace_uuid_lsb = 28 [deprecated = true];

  // When set applies a post-filter to the trace contents using the filter
  // provided. The filter is applied at ReadBuffers() time and works both in the
  // case of IPC readback and write_into_file. This filter can be generated
  // using `tools/proto_filter -s schema.proto -F filter_out.bytes` or
  // `-T filter_out.escaped_string` (for .pbtx). See go/trace-filtering for
  // design.
  //
  // Introduced in Android S, but it was broken (b/195065199). Reintroduced in
  // Android T with a different field number. Updated in Android U with a new
  // bytecode version which supports string filtering.
  message TraceFilter {
    // =========================
    // Filter bytecode.
    // =========================

    // The bytecode as implemented in Android T.
    optional bytes bytecode = 1;

    // The bytecode as implemented in Android U. Adds support for string
    // filtering.
    optional bytes bytecode_v2 = 2;

    // =========================
    // String filtering
    // =========================

    // The principles and terminology of string filtering is heavily inspired by
    // iptables. A "rule" decide how strings should be filtered. Each rule
    // contains a "policy" which indicates the algorithm to use for filtering.
    // A "chain" is a list of rules which will be sequentially checked against
    // each string.
    //
    // The first rule which applies to the string terminates filtering for that
    // string. If no rules apply, the string is left unchanged.

    // A policy specifies which algorithm should be used for filtering the
    // string.
    enum StringFilterPolicy {
      SFP_UNSPECIFIED = 0;

      // Tries to match the string field against |regex_pattern|. If it
      // matches, all matching groups are "redacted" (i.e. replaced with a
      // constant string) and filtering is terminated (i.e. no further rules are
      // checked). If it doesn't match, the string is left unchanged and the
      // next rule in chain is considered.
      SFP_MATCH_REDACT_GROUPS = 1;

      // Like |SFP_MATCH_REDACT_GROUPS| but tries to do some pre-work before
      // checking the regex. Specifically, it tries to parse the string field as
      // an atrace tracepoint and checks if the post-tgid field starts with
      // |atrace_post_tgid_starts_with|. The regex matching is only performed if
      // this check succeeds.
      SFP_ATRACE_MATCH_REDACT_GROUPS = 2;

      // Tries to match the string field against |regex_pattern|. If it
      // matches, filtering is terminated (i.e. no further rules are checked).
      // If it doesn't match, the string is left unchanged and the next rule in
      // chain is considered.
      SFP_MATCH_BREAK = 3;

      // Like |SFP_MATCH_BREAK| but tries to do some pre-work before checking
      // the regex. Specifically, it tries to parse the string field as an
      // atrace tracepoint and checks if the post-tgid field starts with
      // |atrace_post_tgid_starts_with|. The regex matching is only performed if
      // this check succeeds.
      SFP_ATRACE_MATCH_BREAK = 4;
    }

    // A rule specifies how strings should be filtered.
    message StringFilterRule {
      // The policy (i.e. algorithm) dictating how strings matching this rule
      // should be handled.
      optional StringFilterPolicy policy = 1;

      // The regex pattern used to match against each string.
      optional string regex_pattern = 2;

      // The string which should appear after the tgid in atrace tracepoint
      // strings.
      optional string atrace_payload_starts_with = 3;
    }

    // A chain is a list of rules which string will be sequentially checked
    // against.
    message StringFilterChain {
      repeated StringFilterRule rules = 1;
    }
    optional StringFilterChain string_filter_chain = 3;
  }
  // old field number for trace_filter
  reserved 32;
  optional TraceFilter trace_filter = 33;

  // Android-only. Not for general use. If set, reports the trace to the
  // Android framework. This field is read by perfetto_cmd, rather than the
  // tracing service. This field must be set when passing the --upload flag to
  // perfetto_cmd.
  message AndroidReportConfig {
    // In this message, either:
    //  * |reporter_service_package| and |reporter_service_class| must be set.
    //  * |skip_reporting| must be explicitly set to true.

    optional string reporter_service_package = 1;
    optional string reporter_service_class = 2;

    // If true, then skips reporting the trace to Android framework.
    //
    // This flag is useful in testing (e.g. Perfetto-statsd integration tests)
    // or when we explicitly don't want to report traces to the framework even
    // when they usually would (e.g. configs deployed using statsd but only
    // used for inclusion in bugreports using |bugreport_score|).
    //
    // The motivation for having this flag, instead of just not setting
    // |framework_report_config|, is prevent accidents where
    // |framework_report_config| is omitted by mistake.
    optional bool skip_report = 3;

    // If true, will direct the Android framework to read the data in trace
    // file and pass it to the reporter class over a pipe instead of passing
    // the file descriptor directly.
    //
    // This flag is needed because the Android test framework does not
    // currently support priv-app helper apps (in terms of SELinux) and we
    // really don't want to add an allow rule for untrusted_app to receive
    // trace fds.
    //
    // Because of this, we instead will direct the framework to create a new
    // pipe and pass this to the reporter process instead. As the pipe is
    // created by the framework, we won't have any problems with SELinux
    // (system_server is already allowed to pass pipe fds, even
    // to untrusted apps).
    //
    // As the name suggests this option *MUST* only be used for testing.
    // Note that the framework will reject (and drop) files which are too
    // large both for simplicity and to be minimize the amount of data we
    // pass to a non-priv app (note that the framework will still check
    // manifest permissions even though SELinux permissions are worked around).
    optional bool use_pipe_in_framework_for_testing = 4;
  }
  optional AndroidReportConfig android_report_config = 34;

  // If set, delays the start of tracing by a random duration. The duration is
  // chosen from a uniform distribution between the specified minimum and
  // maximum.
  // Note: this delay is implemented by perfetto_cmd *not* by traced so will
  // not work if you communicate with traced directly over the consumer API.
  // Introduced in Android T.
  message CmdTraceStartDelay {
    optional uint32 min_delay_ms = 1;
    optional uint32 max_delay_ms = 2;
  }
  optional CmdTraceStartDelay cmd_trace_start_delay = 35;
}

// End of protos/perfetto/config/trace_config.proto

// Begin of protos/perfetto/common/trace_stats.proto

// Statistics for the internals of the tracing service.
//
// Next id: 19.
message TraceStats {
  // From TraceBuffer::Stats.
  //
  // Next id: 20.
  message BufferStats {
    // Size of the circular buffer in bytes.
    optional uint64 buffer_size = 12;

    // Num. bytes written into the circular buffer, including chunk headers.
    optional uint64 bytes_written = 1;

    // Num. bytes overwritten before they have been read (i.e. loss of data).
    optional uint64 bytes_overwritten = 13;

    // Total size of chunks that were fully read from the circular buffer by the
    // consumer. This may not be equal to |bytes_written| either in the middle
    // of tracing, or if |chunks_overwritten| is non-zero. Note that this is the
    // size of the chunks read from the buffer, including chunk headers, which
    // will be different from the total size of packets returned to the
    // consumer.
    //
    // The current utilization of the trace buffer (mid-tracing) can be obtained
    // by subtracting |bytes_read| and |bytes_overwritten| from |bytes_written|,
    // adding the difference of |padding_bytes_written| and
    // |padding_bytes_cleared|, and comparing this sum to the |buffer_size|.
    // Note that this represents the total size of buffered data in the buffer,
    // yet this data may be spread non-contiguously through the buffer and may
    // be overridden before the utilization reaches 100%.
    optional uint64 bytes_read = 14;

    // Num. bytes that were allocated as padding between chunks in the circular
    // buffer.
    optional uint64 padding_bytes_written = 15;

    // Num. of padding bytes that were removed from the circular buffer when
    // they were overwritten.
    //
    // The difference between |padding_bytes_written| and
    // |padding_bytes_cleared| denotes the total size of padding currently
    // present in the buffer.
    optional uint64 padding_bytes_cleared = 16;

    // Num. chunks (!= packets) written into the buffer.
    optional uint64 chunks_written = 2;

    // Num. chunks (!= packets) rewritten into the buffer. This means we rewrote
    // the same chunk with additional packets appended to the end.
    optional uint64 chunks_rewritten = 10;

    // Num. chunks overwritten before they have been read (i.e. loss of data).
    optional uint64 chunks_overwritten = 3;

    // Num. chunks discarded (i.e. loss of data). Can be > 0 only when a buffer
    // is configured with FillPolicy == DISCARD.
    optional uint64 chunks_discarded = 18;

    // Num. chunks (!= packets) that were fully read from the circular buffer by
    // the consumer. This may not be equal to |chunks_written| either in the
    // middle of tracing, or if |chunks_overwritten| is non-zero.
    optional uint64 chunks_read = 17;

    // Num. chunks that were committed out of order.
    optional uint64 chunks_committed_out_of_order = 11;

    // Num. times the ring buffer wrapped around.
    optional uint64 write_wrap_count = 4;

    // Num. out-of-band (OOB) patches that succeeded.
    optional uint64 patches_succeeded = 5;

    // Num. OOB patches that failed (e.g., the chunk to patch was gone).
    optional uint64 patches_failed = 6;

    // Num. readaheads (for large multi-chunk packet reads) that ended up in a
    // successful packet read.
    optional uint64 readaheads_succeeded = 7;

    // Num. readaheads aborted because of missing chunks in the sequence stream.
    // Note that a small number > 0 is totally expected: occasionally, when
    // issuing a read, the very last packet in a sequence might be incomplete
    // (because the producer is still writing it while we read). The read will
    // stop at that point, for that sequence, increasing this counter.
    optional uint64 readaheads_failed = 8;

    // Num. of violations of the SharedMemoryABI found while writing or reading
    // the buffer. This is an indication of either a bug in the producer(s) or
    // malicious producer(s).
    optional uint64 abi_violations = 9;

    // The fields below have been introduced in Android R.

    // Num. of times the service detected packet loss on a trace writer
    // sequence. This is usually caused by exhaustion of available chunks in the
    // writer process's SMB. Note that this relies on the client's TraceWriter
    // indicating this loss to the service -- packets lost for other reasons are
    // not reflected in this stat.
    optional uint64 trace_writer_packet_loss = 19;
  }

  // Stats for the TraceBuffer(s) of the current trace session.
  repeated BufferStats buffer_stats = 1;

  // Per TraceWriter stat. Each {producer, trace writer} tuple is publicly
  // visible as a unique sequence ID in the trace.
  message WriterStats {
    // This matches the TracePacket.trusted_packet_sequence_id and is used to
    // correlate the stats with the actual packet types.
    optional uint64 sequence_id = 1;

    // These two arrays have the same cardinality and match the cardinality of
    // chunk_payload_histogram_def + 1 (for the overflow bucket, see below).
    // `sum` contains the SUM(entries) and `counts` contains the COUNT(entries)
    // for each bucket.
    repeated uint64 chunk_payload_histogram_counts = 2 [packed = true];
    repeated int64 chunk_payload_histogram_sum = 3 [packed = true];
  }

  // The thresholds of each the `writer_stats` histogram buckets. This is
  // emitted only once as all WriterStats share the same bucket layout.
  // This field has the same cardinality of the
  // `writer_stats.chunk_payload_histogram_{counts,sum}` - 1.
  // (The -1 is because the last overflow bucket is not reported in the _def).
  // An array of values [10, 100, 1000] in the _def array means that there are
  // four buckets (3 + the implicit overflow bucket):
  // [0]: x <= 10; [1]: 100 < x <= 1000; [2]: 1000 < x <= 1000; [3]: x > 1000.
  repeated int64 chunk_payload_histogram_def = 17;
  repeated WriterStats writer_stats = 18;

  // Num. producers connected (whether they are involved in the current tracing
  // session or not).
  optional uint32 producers_connected = 2;

  // Num. producers ever seen for all trace sessions since startup (it's a good
  // proxy for inferring num. producers crashed / killed).
  optional uint64 producers_seen = 3;

  // Num. data sources registered for all trace sessions.
  optional uint32 data_sources_registered = 4;

  // Num. data sources ever seen for all trace sessions since startup.
  optional uint64 data_sources_seen = 5;

  // Num. concurrently active tracing sessions.
  optional uint32 tracing_sessions = 6;

  // Num. buffers for all tracing session (not just the current one). This will
  // be >= buffer_stats.size(), because the latter is only about the current
  // session.
  optional uint32 total_buffers = 7;

  // The fields below have been introduced in Android Q.

  // Num. chunks that were discarded by the service before attempting to commit
  // them to a buffer, e.g. because the producer specified an invalid buffer ID.
  optional uint64 chunks_discarded = 8;

  // Num. patches that were discarded by the service before attempting to apply
  // them to a buffer, e.g. because the producer specified an invalid buffer ID.
  optional uint64 patches_discarded = 9;

  // Packets that failed validation of the TrustedPacket. If this is > 0, there
  // is a bug in the producer.
  optional uint64 invalid_packets = 10;

  // This is set only when the TraceConfig specifies a TraceFilter.
  message FilterStats {
    optional uint64 input_packets = 1;
    optional uint64 input_bytes = 2;
    optional uint64 output_bytes = 3;
    optional uint64 errors = 4;
    optional uint64 time_taken_ns = 5;
  }
  optional FilterStats filter_stats = 11;

  // Count of Flush() requests (either from the Consumer, or self-induced
  // periodic flushes). The final Flush() is also included in the count.
  optional uint64 flushes_requested = 12;

  // The count of the Flush() requests that were completed successfully.
  // In a well behaving trace this should always be == `flush_requests`.
  optional uint64 flushes_succeeded = 13;

  // The count of the Flush() requests that failed (in most timed out).
  // In a well behaving trace this should always be == 0.
  optional uint64 flushes_failed = 14;

  enum FinalFlushOutcome {
    FINAL_FLUSH_UNSPECIFIED = 0;
    FINAL_FLUSH_SUCCEEDED = 1;
    FINAL_FLUSH_FAILED = 2;
  }
  optional FinalFlushOutcome final_flush_outcome = 15;
}

// End of protos/perfetto/common/trace_stats.proto

// Begin of protos/perfetto/trace/android/android_game_intervention_list.proto


// End of protos/perfetto/trace/android/android_game_intervention_list.proto

// Begin of protos/perfetto/trace/android/android_log.proto
// End of protos/perfetto/trace/chrome/chrome_trace_event.proto

// Begin of protos/perfetto/trace/clock_snapshot.proto

// A snapshot of clock readings to allow for trace alignment.
message ClockSnapshot {
  message Clock {
    // DEPRECATED. This enum has moved to ../common/builtin_clock.proto.
    enum BuiltinClocks {
      UNKNOWN = 0;
      REALTIME = 1;
      REALTIME_COARSE = 2;
      MONOTONIC = 3;
      MONOTONIC_COARSE = 4;
      MONOTONIC_RAW = 5;
      BOOTTIME = 6;
      BUILTIN_CLOCK_MAX_ID = 63;

      reserved 7, 8;
    }

    // Clock IDs have the following semantic:
    // [1, 63]:    Builtin types, see BuiltinClock from
    //             ../common/builtin_clock.proto.
    // [64, 127]:  User-defined clocks. These clocks are sequence-scoped. They
    //             are only valid within the same |trusted_packet_sequence_id|
    //             (i.e. only for TracePacket(s) emitted by the same TraceWriter
    //             that emitted the clock snapshot).
    // [128, MAX]: Reserved for future use. The idea is to allow global clock
    //             IDs and setting this ID to hash(full_clock_name) & ~127.
    optional uint32 clock_id = 1;

    // Absolute timestamp. Unit is ns unless specified otherwise by the
    // unit_multiplier_ns field below.
    optional uint64 timestamp = 2;

    // When true each TracePacket's timestamp should be interpreted as a delta
    // from the last TracePacket's timestamp (referencing this clock) emitted by
    // the same packet_sequence_id. Should only be used for user-defined
    // sequence-local clocks. The first packet timestamp after each
    // ClockSnapshot that contains this clock is relative to the |timestamp| in
    // the ClockSnapshot.
    optional bool is_incremental = 3;

    // Allows to specify a custom unit different than the default (ns) for this
    // clock domain. A multiplier of 1000 means that a timestamp = 3 should be
    // interpreted as 3000 ns = 3 us. All snapshots for the same clock within a
    // trace need to use the same unit.
    optional uint64 unit_multiplier_ns = 4;
  }
  repeated Clock clocks = 1;

  // The authoritative clock domain for the trace. Defaults to BOOTTIME, but can
  // be overridden in TraceConfig's builtin_data_sources. Trace processor will
  // attempt to translate packet/event timestamps from various data sources (and
  // their chosen clock domains) to this domain during import.
  optional BuiltinClock primary_trace_clock = 2;
}

// End of protos/perfetto/trace/clock_snapshot.proto

// Begin of protos/perfetto/common/descriptor.proto

// The protocol compiler can output a FileDescriptorSet containing the .proto
// files it parses.
message FileDescriptorSet {
  repeated FileDescriptorProto file = 1;
}

// Describes a complete .proto file.
message FileDescriptorProto {
  // file name, relative to root of source tree
  optional string name = 1;
  // e.g. "foo", "foo.bar", etc.
  optional string package = 2;

  // Names of files imported by this file.
  repeated string dependency = 3;
  // Indexes of the public imported files in the dependency list above.
  repeated int32 public_dependency = 10;
  // Indexes of the weak imported files in the dependency list.
  // For Google-internal migration only. Do not use.
  repeated int32 weak_dependency = 11;

  // All top-level definitions in this file.
  repeated DescriptorProto message_type = 4;
  repeated EnumDescriptorProto enum_type = 5;
  repeated FieldDescriptorProto extension = 7;

  reserved 6;
  reserved 8;
  reserved 9;
  reserved 12;
}

// Describes a message type.
message DescriptorProto {
  optional string name = 1;

  repeated FieldDescriptorProto field = 2;
  repeated FieldDescriptorProto extension = 6;

  repeated DescriptorProto nested_type = 3;
  repeated EnumDescriptorProto enum_type = 4;

  reserved 5;

  repeated OneofDescriptorProto oneof_decl = 8;

  reserved 7;

  // Range of reserved tag numbers. Reserved tag numbers may not be used by
  // fields or extension ranges in the same message. Reserved ranges may
  // not overlap.
  message ReservedRange {
    // Inclusive.
    optional int32 start = 1;
    // Exclusive.
    optional int32 end = 2;
  }
  repeated ReservedRange reserved_range = 9;
  // Reserved field names, which may not be used by fields in the same message.
  // A given name may only be reserved once.
  repeated string reserved_name = 10;
}

message FieldOptions {
  // The packed option can be enabled for repeated primitive fields to enable
  // a more efficient representation on the wire. Rather than repeatedly
  // writing the tag and type for each element, the entire array is encoded as
  // a single length-delimited blob. In proto3, only explicit setting it to
  // false will avoid using packed encoding.
  optional bool packed = 2;
}

// Describes a field within a message.
message FieldDescriptorProto {
  enum Type {
    // 0 is reserved for errors.
    // Order is weird for historical reasons.
    TYPE_DOUBLE = 1;
    TYPE_FLOAT = 2;
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
    // negative values are likely.
    TYPE_INT64 = 3;
    TYPE_UINT64 = 4;
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
    // negative values are likely.
    TYPE_INT32 = 5;
    TYPE_FIXED64 = 6;
    TYPE_FIXED32 = 7;
    TYPE_BOOL = 8;
    TYPE_STRING = 9;
    // Tag-delimited aggregate.
    // Group type is deprecated and not supported in proto3. However, Proto3
    // implementations should still be able to parse the group wire format and
    // treat group fields as unknown fields.
    TYPE_GROUP = 10;
    // Length-delimited aggregate.
    TYPE_MESSAGE = 11;

    // New in version 2.
    TYPE_BYTES = 12;
    TYPE_UINT32 = 13;
    TYPE_ENUM = 14;
    TYPE_SFIXED32 = 15;
    TYPE_SFIXED64 = 16;
    // Uses ZigZag encoding.
    TYPE_SINT32 = 17;
    // Uses ZigZag encoding.
    TYPE_SINT64 = 18;
  };

  enum Label {
    // 0 is reserved for errors
    LABEL_OPTIONAL = 1;
    LABEL_REQUIRED = 2;
    LABEL_REPEATED = 3;
  };

  optional string name = 1;
  optional int32 number = 3;
  optional Label label = 4;

  // If type_name is set, this need not be set.  If both this and type_name
  // are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
  optional Type type = 5;

  // For message and enum types, this is the name of the type.  If the name
  // starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
  // rules are used to find the type (i.e. first the nested types within this
  // message are searched, then within the parent, on up to the root
  // namespace).
  optional string type_name = 6;

  // For extensions, this is the name of the type being extended.  It is
  // resolved in the same manner as type_name.
  optional string extendee = 2;

  // For numeric types, contains the original text representation of the value.
  // For booleans, "true" or "false".
  // For strings, contains the default text contents (not escaped in any way).
  // For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
  // TODO(kenton):  Base-64 encode?
  optional string default_value = 7;

  optional FieldOptions options = 8;

  // If set, gives the index of a oneof in the containing type's oneof_decl
  // list.  This field is a member of that oneof.
  optional int32 oneof_index = 9;

  reserved 10;
}

// Describes a oneof.
message OneofDescriptorProto {
  optional string name = 1;
  optional OneofOptions options = 2;
}

// Describes an enum type.
message EnumDescriptorProto {
  optional string name = 1;

  repeated EnumValueDescriptorProto value = 2;

  reserved 3;
  reserved 4;

  // Reserved enum value names, which may not be reused. A given name may only
  // be reserved once.
  repeated string reserved_name = 5;
}

// Describes a value within an enum.
message EnumValueDescriptorProto {
  optional string name = 1;
  optional int32 number = 2;

  reserved 3;
}

message OneofOptions {
  reserved 999;

  // Clients can define custom options in extensions of this message. See above.
  extensions 1000 to max;
}

// End of protos/perfetto/common/descriptor.proto

// Begin of protos/perfetto/trace/extension_descriptor.proto

// This message contains descriptors used to parse extension fields of
// TrackEvent.
//
// See docs/design-docs/extensions.md for more details.
message ExtensionDescriptor {
  optional FileDescriptorSet extension_set = 1;
}
// Trace events emitted by client instrumentation library (TRACE_EVENT macros),
// which describe activity on a track, such as a thread or asynchronous event
// track. The track is specified using separate TrackDescriptor messages and
// referred to via the track's UUID.
//
// A simple TrackEvent packet specifies a timestamp, category, name and type:
// ```protobuf
//   trace_packet {
//     timestamp: 1000
//     track_event {
//       categories: ["my_cat"]
//       name: "my_event"
//       type: TYPE_INSTANT
//      }
//    }
// ```
//
// To associate an event with a custom track (e.g. a thread), the track is
// defined in a separate packet and referred to from the TrackEvent by its UUID:
// ```protobuf
//   trace_packet {
//     track_descriptor {
//       track_uuid: 1234
//       name: "my_track"
//
//       // Optionally, associate the track with a thread.
//       thread_descriptor {
//         pid: 10
//         tid: 10
//         ..
//       }
//     }
//   }
// ```
//
// A pair of TYPE_SLICE_BEGIN and _END events form a slice on the track:
//
// ```protobuf
//   trace_packet {
//     timestamp: 1200
//     track_event {
//       track_uuid: 1234
//       categories: ["my_cat"]
//       name: "my_slice"
//       type: TYPE_SLICE_BEGIN
//     }
//   }
//   trace_packet {
//     timestamp: 1400
//     track_event {
//       track_uuid: 1234
//       type: TYPE_SLICE_END
//     }
//   }
// ```
// TrackEvents also support optimizations to reduce data repetition and encoded
// data size, e.g. through data interning (names, categories, ...) and delta
// encoding of timestamps/counters. For details, see the InternedData message.
// Further, default values for attributes of events on the same sequence (e.g.
// their default track association) can be emitted as part of a
// TrackEventDefaults message.
//
// Next reserved id: 13 (up to 15). Next id: 50.
message TrackEvent {
  // Names of categories of the event. In the client library, categories are a
  // way to turn groups of individual events on or off.
  // interned EventCategoryName.
  repeated uint64 category_iids = 3;
  // non-interned variant.
  repeated string categories = 22;

  // Optional name of the event for its display in trace viewer. May be left
  // unspecified for events with typed arguments.
  //
  // Note that metrics should not rely on event names, as they are prone to
  // changing. Instead, they should use typed arguments to identify the events
  // they are interested in.
  oneof name_field {
    // interned EventName.
    uint64 name_iid = 10;
    // non-interned variant.
    string name = 23;
  }

  // TODO(eseckler): Support using binary symbols for category/event names.

  // Type of the TrackEvent (required if |phase| in LegacyEvent is not set).
  enum Type {
    TYPE_UNSPECIFIED = 0;

    // Slice events are events that have a begin and end timestamp, i.e. a
    // duration. They can be nested similar to a callstack: If, on the same
    // track, event B begins after event A, but before A ends, B is a child
    // event of A and will be drawn as a nested event underneath A in the UI.
    // Note that child events should always end before their parents (e.g. B
    // before A).
    //
    // Each slice event is formed by a pair of BEGIN + END events. The END event
    // does not need to repeat any TrackEvent fields it has in common with its
    // corresponding BEGIN event. Arguments and debug annotations of the BEGIN +
    // END pair will be merged during trace import.
    //
    // Note that we deliberately chose not to support COMPLETE events (which
    // would specify a duration directly) since clients would need to delay
    // writing them until the slice is completed, which can result in reordered
    // events in the trace and loss of unfinished events at the end of a trace.
    TYPE_SLICE_BEGIN = 1;
    TYPE_SLICE_END = 2;

    // Instant events are nestable events without duration. They can be children
    // of slice events on the same track.
    TYPE_INSTANT = 3;

    // Event that provides a value for a counter track. |track_uuid| should
    // refer to a counter track and |counter_value| set to the new value. Note
    // that most other TrackEvent fields (e.g. categories, name, ..) are not
    // supported for TYPE_COUNTER events. See also CounterDescriptor.
    TYPE_COUNTER = 4;
  }
  optional Type type = 9;

  // Identifies the track of the event. The default value may be overridden
  // using TrackEventDefaults, e.g., to specify the track of the TraceWriter's
  // sequence (in most cases sequence = one thread). If no value is specified
  // here or in TrackEventDefaults, the TrackEvent will be associated with an
  // implicit trace-global track (uuid 0). See TrackDescriptor::uuid.
  optional uint64 track_uuid = 11;

  // A new value for a counter track. |track_uuid| should refer to a track with
  // a CounterDescriptor, and |type| should be TYPE_COUNTER. For a more
  // efficient encoding of counter values that are sampled at the beginning/end
  // of a slice, see |extra_counter_values| and |extra_counter_track_uuids|.
  // Counter values can optionally be encoded in as delta values (positive or
  // negative) on each packet sequence (see CounterIncrementalBase).
  oneof counter_value_field {
    int64 counter_value = 30;
    double double_counter_value = 44;
  }

  // To encode counter values more efficiently, we support attaching additional
  // counter values to a TrackEvent of any type. All values will share the same
  // timestamp specified in the TracePacket. The value at
  // extra_counter_values[N] is for the counter track referenced by
  // extra_counter_track_uuids[N].
  //
  // |extra_counter_track_uuids| may also be set via TrackEventDefaults. There
  // should always be equal or more uuids than values. It is valid to set more
  // uuids (e.g. via defaults) than values. If uuids are specified in
  // TrackEventDefaults and a TrackEvent, the TrackEvent uuids override the
  // default uuid list.
  //
  // For example, this allows snapshotting the thread time clock at each
  // thread-track BEGIN and END event to capture the cpu time delta of a slice.
  repeated uint64 extra_counter_track_uuids = 31;
  repeated int64 extra_counter_values = 12;

  // Counter snapshots using floating point instead of integer values.
  repeated uint64 extra_double_counter_track_uuids = 45;
  repeated double extra_double_counter_values = 46;

  // IDs of flows originating, passing through, or ending at this event.
  // Flow IDs are global within a trace.
  //
  // A flow connects a sequence of TrackEvents within or across tracks, e.g.
  // an input event may be handled on one thread but cause another event on
  // a different thread - a flow between the two events can associate them.
  //
  // The direction of the flows between events is inferred from the events'
  // timestamps. The earliest event with the same flow ID becomes the source
  // of the flow. Any events thereafter are intermediate steps of the flow,
  // until the flow terminates at the last event with the flow ID.
  //
  // Flows can also be explicitly terminated (see |terminating_flow_ids|), so
  // that the same ID can later be reused for another flow.
  // DEPRECATED. Only kept for backwards compatibility. Use |flow_ids|.
  repeated uint64 flow_ids_old = 36 [deprecated = true];
  // TODO(b/204341740): replace "flow_ids_old" with "flow_ids" to reduce memory
  // consumption.
  repeated fixed64 flow_ids = 47;

  // List of flow ids which should terminate on this event, otherwise same as
  // |flow_ids|.
  // Any one flow ID should be either listed as part of |flow_ids| OR
  // |terminating_flow_ids|, not both.
  // DEPRECATED. Only kept for backwards compatibility.  Use
  // |terminating_flow_ids|.
  repeated uint64 terminating_flow_ids_old = 42 [deprecated = true];
  // TODO(b/204341740): replace "terminating_flow_ids_old" with
  // "terminating_flow_ids" to reduce memory consumption.
  repeated fixed64 terminating_flow_ids = 48;

  // ---------------------------------------------------------------------------
  // TrackEvent arguments:
  // ---------------------------------------------------------------------------

 // This field is used only if the source location represents the function that
  // executes during this event.
  oneof source_location_field {
    // Non-interned field.
    //SourceLocation source_location = 33;
    // Interned field.
    uint64 source_location_iid = 34;
  }
  // Extension range for future use.
  extensions 1000 to 9899;
  // Reserved for Perfetto unit and integration tests.
  extensions 9900 to 10000;

  // ---------------------------------------------------------------------------
  // Deprecated / legacy event fields, which will be removed in the future:
  // ---------------------------------------------------------------------------

  // Deprecated. Use the |timestamp| and |timestamp_clock_id| fields in
  // TracePacket instead.
  //
  // Timestamp in microseconds (usually CLOCK_MONOTONIC).
  oneof timestamp {
    // Delta timestamp value since the last TrackEvent or ThreadDescriptor. To
    // calculate the absolute timestamp value, sum up all delta values of the
    // preceding TrackEvents since the last ThreadDescriptor and add the sum to
    // the |reference_timestamp| in ThreadDescriptor. This value should always
    // be positive.
    int64 timestamp_delta_us = 1;
    // Absolute value (e.g. a manually specified timestamp in the macro).
    // This is a one-off value that does not affect delta timestamp computation
    // in subsequent TrackEvents.
    int64 timestamp_absolute_us = 16;
  }

  // Deprecated. Use |extra_counter_values| and |extra_counter_track_uuids| to
  // encode thread time instead.
  //
  // CPU time for the current thread (e.g., CLOCK_THREAD_CPUTIME_ID) in
  // microseconds.
  oneof thread_time {
    // Delta timestamp value since the last TrackEvent or ThreadDescriptor. To
    // calculate the absolute timestamp value, sum up all delta values of the
    // preceding TrackEvents since the last ThreadDescriptor and add the sum to
    // the |reference_timestamp| in ThreadDescriptor. This value should always
    // be positive.
    int64 thread_time_delta_us = 2;
    // This is a one-off absolute value that does not affect delta timestamp
    // computation in subsequent TrackEvents.
    int64 thread_time_absolute_us = 17;
  }

  // Deprecated. Use |extra_counter_values| and |extra_counter_track_uuids| to
  // encode thread instruction count instead.
  //
  // Value of the instruction counter for the current thread.
  oneof thread_instruction_count {
    // Same encoding as |thread_time| field above.
    int64 thread_instruction_count_delta = 8;
    int64 thread_instruction_count_absolute = 20;
  }

  // Apart from {category, time, thread time, tid, pid}, other legacy trace
  // event attributes are initially simply proxied for conversion to a JSON
  // trace. We intend to gradually transition these attributes to similar native
  // features in TrackEvent (e.g. async + flow events), or deprecate them
  // without replacement where transition is unsuitable.
  //
  // Next reserved id: 16 (up to 16).
  // Next id: 20.
  message LegacyEvent {
    // Deprecated, use TrackEvent::name(_iid) instead.
    // interned EventName.
    optional uint64 name_iid = 1;
    optional int32 phase = 2;
    optional int64 duration_us = 3;
    optional int64 thread_duration_us = 4;

    // Elapsed retired instruction count during the event.
    optional int64 thread_instruction_delta = 15;

    // used to be |flags|.
    reserved 5;

    oneof id {
      uint64 unscoped_id = 6;
      uint64 local_id = 10;
      uint64 global_id = 11;
    }
    // Additional optional scope for |id|.
    optional string id_scope = 7;

    // Consider the thread timestamps for async BEGIN/END event pairs as valid.
    optional bool use_async_tts = 9;

    // Idenfifies a flow. Flow events with the same bind_id are connected.
    optional uint64 bind_id = 8;
    // Use the enclosing slice as binding point for a flow end event instead of
    // the next slice. Flow start/step events always bind to the enclosing
    // slice.
    optional bool bind_to_enclosing = 12;

    enum FlowDirection {
      FLOW_UNSPECIFIED = 0;
      FLOW_IN = 1;
      FLOW_OUT = 2;
      FLOW_INOUT = 3;
    }
    optional FlowDirection flow_direction = 13;

    enum InstantEventScope {
      SCOPE_UNSPECIFIED = 0;
      SCOPE_GLOBAL = 1;
      SCOPE_PROCESS = 2;
      SCOPE_THREAD = 3;
    }
    optional InstantEventScope instant_event_scope = 14;

    // Override the pid/tid if the writer needs to emit events on behalf of
    // another process/thread. This should be the exception. Normally, the
    // pid+tid from ThreadDescriptor is used.
    optional int32 pid_override = 18;
    optional int32 tid_override = 19;
  }

  optional LegacyEvent legacy_event = 6;
}

// Default values for fields of all TrackEvents on the same packet sequence.
// Should be emitted as part of TracePacketDefaults whenever incremental state
// is cleared. It's defined here because field IDs should match those of the
// corresponding fields in TrackEvent.
message TrackEventDefaults {
  optional uint64 track_uuid = 11;
  repeated uint64 extra_counter_track_uuids = 31;
  repeated uint64 extra_double_counter_track_uuids = 45;

  // TODO(eseckler): Support default values for more TrackEvent fields.
}

// --------------------
// Interned data types:
// --------------------

message EventCategory {
  optional uint64 iid = 1;
  optional string name = 2;
}

message EventName {
  optional uint64 iid = 1;
  optional string name = 2;
}
message PerfSample {
  optional uint32 cpu = 1;
  optional uint32 pid = 2;
  optional uint32 tid = 3;

  // Execution state that the process was sampled at.
 // optional Profiling.CpuMode cpu_mode = 5;

  // Value of the timebase counter (since the event was configured, no deltas).
  optional uint64 timebase_count = 6;

  // Unwound callstack. Might be partial, in which case a synthetic "error"
  // frame is appended, and |unwind_error| is set accordingly.
  optional uint64 callstack_iid = 4;

  // If set, stack unwinding was incomplete due to an error.
  // Unset values should be treated as UNWIND_ERROR_NONE.
 // oneof optional_unwind_error { Profiling.StackUnwindError unwind_error = 16; };

  // If set, indicates that this message is not a sample, but rather an
  // indication of data loss in the ring buffer allocated for |cpu|. Such data
  // loss occurs when the kernel has insufficient ring buffer capacity to write
  // a record (which gets discarded). A record in this context is an individual
  // ring buffer entry, and counts more than just sample records.
  //
  // The |timestamp| of the packet corresponds to the time that the producer
  // wrote the packet for trace-sorting purposes alone, and should not be
  // interpreted relative to the sample timestamps. This field is sufficient to
  // detect that *some* kernel data loss happened within the trace, but not the
  // specific time bounds of that loss (which would require tracking precedessor
  // & successor timestamps, which is not deemed necessary at the moment).
  optional uint64 kernel_records_lost = 17;

  // If set, indicates that the profiler encountered a sample that was relevant,
  // but was skipped.
  enum SampleSkipReason {
    PROFILER_SKIP_UNKNOWN = 0;
    PROFILER_SKIP_READ_STAGE = 1;
    PROFILER_SKIP_UNWIND_STAGE = 2;
    PROFILER_SKIP_UNWIND_ENQUEUE = 3;
  }
  oneof optional_sample_skipped_reason {
    SampleSkipReason sample_skipped_reason = 18;
  };

  // A notable event within the sampling implementation.
  message ProducerEvent {
    enum DataSourceStopReason {
      PROFILER_STOP_UNKNOWN = 0;
      PROFILER_STOP_GUARDRAIL = 1;
    }
    oneof optional_source_stop_reason {
      DataSourceStopReason source_stop_reason = 1;
    }
  }
  optional ProducerEvent producer_event = 19;
}

// Submessage for TracePacketDefaults.
message PerfSampleDefaults {
  // The sampling timebase. Might not be identical to the data source config if
  // the implementation decided to default/override some parameters.
  optional PerfEvents.Timebase timebase = 1;

  // If the config requested process sharding, report back the count and which
  // of those bins was selected. Never changes for the duration of a trace.
  optional uint32 process_shard_count = 2;
  optional uint32 chosen_process_shard = 3;
}

// End of protos/perfetto/trace/profiling/profile_packet.proto

// Begin of protos/perfetto/trace/profiling/smaps.proto

// End of protos/perfetto/trace/profiling/smaps.proto

// Begin of protos/perfetto/trace/ps/process_stats.proto

// Per-process periodically sampled stats. These samples are wrapped in a
// dedicated message (as opposite to be fields in process_tree.proto) because
// they are dumped at a different rate than cmdline and thread list.
// Note: not all of these stats will be present in every ProcessStats message
// and sometimes processes may be missing . This is because counters are
// cached to reduce emission of counters which do not change.
message ProcessStats {
  // Per-thread periodically sampled stats.
  // Note: not all of these stats will be present in every message. See the note
  // for ProcessStats.
  message Thread {
    optional int32 tid = 1;

    // DEPRECATED cpu_freq_indices
    reserved 2;

    // DEPRECATED cpu_freq_ticks
    reserved 3;

    // DEPRECATED cpu_freq_full
    reserved 4;
  }

  message FDInfo {
    optional uint64 fd = 1;
    optional string path = 2;
  }

  message Process {
    optional int32 pid = 1;

    // See /proc/[pid]/status in `man 5 proc` for a description of these fields.
    optional uint64 vm_size_kb = 2;
    optional uint64 vm_rss_kb = 3;
    optional uint64 rss_anon_kb = 4;
    optional uint64 rss_file_kb = 5;
    optional uint64 rss_shmem_kb = 6;
    optional uint64 vm_swap_kb = 7;
    optional uint64 vm_locked_kb = 8;
    optional uint64 vm_hwm_kb = 9;
    // When adding a new field remember to update kProcMemCounterSize in
    // the trace processor.

    optional int64 oom_score_adj = 10;

    repeated Thread threads = 11;

    // The peak resident set size is resettable in newer Posix kernels.
    // This field specifies if reset is supported and if the writer had reset
    // the peaks after each process stats recording.
    optional bool is_peak_rss_resettable = 12;

    // Private, shared and swap footprint of the process as measured by
    // Chrome. To know more about these metrics refer to:
    // https://docs.google.com/document/d/1_WmgE1F5WUrhwkPqJis3dWyOiUmQKvpXp5cd4w86TvA
    optional uint32 chrome_private_footprint_kb = 13;
    optional uint32 chrome_peak_resident_set_kb = 14;

    repeated FDInfo fds = 15;

    // These fields are set only when scan_smaps_rollup=true
    optional uint64 smr_rss_kb = 16;
    optional uint64 smr_pss_kb = 17;
    optional uint64 smr_pss_anon_kb = 18;
    optional uint64 smr_pss_file_kb = 19;
    optional uint64 smr_pss_shmem_kb = 20;
  }
  repeated Process processes = 1;

  // The time at which we finish collecting this batch of samples;
  // the top-level packet timestamp is the time at which
  // we begin collection.
  optional uint64 collection_end_timestamp = 2;
}

// End of protos/perfetto/trace/ps/process_stats.proto

// Begin of protos/perfetto/trace/ps/process_tree.proto

// Metadata about the processes and threads in the trace.
// Note: this proto was designed to be filled in by traced_probes and should
// only be populated with accurate information coming from the system. Other
// trace writers should prefer to fill ThreadDescriptor and ProcessDescriptor
// in TrackDescriptor.
message ProcessTree {
  // Representation of a thread.
  message Thread {
    // The thread ID (as per gettid()) in the root PID namespace.
    optional int32 tid = 1;

    // Thread group id (i.e. the PID of the process, == TID of the main thread)
    optional int32 tgid = 3;

    // The name of the thread.
    optional string name = 2;

    // The non-root-level thread IDs if the thread runs in a PID namespace. Read
    // from the NSpid entry of /proc/<tid>/status, with the first element (root-
    // level thread ID) omitted.
    repeated int32 nstid = 4;
  }

  // Representation of a process.
  message Process {
    // The UNIX process ID, aka thread group ID (as per getpid()) in the root
    // PID namespace.
    optional int32 pid = 1;

    // The parent process ID, as per getppid().
    optional int32 ppid = 2;

    // The command line for the process, as per /proc/pid/cmdline.
    // If it is a kernel thread there will only be one cmdline field
    // and it will contain /proc/pid/comm.
    repeated string cmdline = 3;

    // No longer used as of Apr 2018, when the dedicated |threads| field was
    // introduced in ProcessTree.
    repeated Thread threads_deprecated = 4 [deprecated = true];

    // The uid for the process, as per /proc/pid/status.
    optional int32 uid = 5;

    // The non-root-level process IDs if the process runs in a PID namespace.
    // Read from the NSpid entry of /proc/<pid>/status, with the first element (
    // root-level process ID) omitted.
    repeated int32 nspid = 6;
  }

  // List of processes and threads in the client. These lists are incremental
  // and not exhaustive. A process and its threads might show up separately in
  // different ProcessTree messages. A thread might event not show up at all, if
  // no sched_switch activity was detected, for instance:
  // #0 { processes: [{pid: 10, ...}], threads: [{pid: 11, tgid: 10}] }
  // #1 { threads: [{pid: 12, tgid: 10}] }
  // #2 { processes: [{pid: 20, ...}], threads: [{pid: 13, tgid: 10}] }
  repeated Process processes = 1;
  repeated Thread threads = 2;

  // The time at which we finish collecting this process tree;
  // the top-level packet timestamp is the time at which
  // we begin collection.
  optional uint64 collection_end_timestamp = 3;
}

// End of protos/perfetto/trace/ps/process_tree.proto

// Begin of protos/perfetto/trace/statsd/statsd_atom.proto

// Deliberate empty message. See comment on StatsdAtom#atom below.
message Atom {}

// One or more statsd atoms. This must continue to match:
// perfetto/protos/third_party/statsd/shell_data.proto
// So that we can efficiently add data from statsd directly to the
// trace.
message StatsdAtom {
  // Atom should be filled with an Atom proto from:
  // https://cs.android.com/android/platform/superproject/+/master:frameworks/proto_logging/stats/atoms.proto?q=f:stats%2Fatoms.proto$%20message%5C%20Atom
  // We don't reference Atom directly here since we don't want to import
  // Atom.proto and all its transitive dependencies into Perfetto.
  // atom and timestamp_nanos have the same cardinality
  repeated Atom atom = 1;
  repeated int64 timestamp_nanos = 2;
}

// End of protos/perfetto/trace/statsd/statsd_atom.proto

// Begin of protos/perfetto/trace/sys_stats/sys_stats.proto

// Various Linux system stat counters from /proc.
// The fields in this message can be reported at different rates and with
// different granularity. See sys_stats_config.proto.
// End of protos/perfetto/trace/sys_stats/sys_stats.proto

// Begin of protos/perfetto/trace/system_info.proto

message Utsname {
  optional string sysname = 1;
  optional string version = 2;
  optional string release = 3;
  optional string machine = 4;
}

message SystemInfo {
  optional Utsname utsname = 1;
  optional string android_build_fingerprint = 2;

  // Ticks per second - sysconf(_SC_CLK_TCK).
  optional int64 hz = 3;

  // The version of traced (the same returned by `traced --version`).
  // This is a human readable string with and its format varies depending on
  // the build system and the repo (standalone vs AOSP).
  // This is intended for human debugging only.
  optional string tracing_service_version = 4;

  // The Android SDK vesion (e.g. 21 for L, 31 for S etc).
  // Introduced in Android T.
  optional uint64 android_sdk_version = 5;

  // Kernel page size - sysconf(_SC_PAGESIZE).
  optional uint32 page_size = 6;
}

// End of protos/perfetto/trace/system_info.proto

// Begin of protos/perfetto/trace/system_info/cpu_info.proto

// Information about CPUs from procfs and sysfs.
message CpuInfo {
  // Information about a single CPU.
  message Cpu {
    // Value of "Processor" field from /proc/cpuinfo for this CPU.
    // Example: "AArch64 Processor rev 12 (aarch64)"
    optional string processor = 1;

    // Frequencies from
    // /sys/devices/system/cpu/cpuX/cpufreq/scaling_available_frequencies
    // where X is the index of this CPU.
    repeated uint32 frequencies = 2;
  }

  // Describes available CPUs, one entry per CPU.
  repeated Cpu cpus = 1;
}

// End of protos/perfetto/trace/system_info/cpu_info.proto

// Begin of protos/perfetto/trace/test_event.proto

// Event used by testing code.
message TestEvent {
  // Arbitrary string used in tests.
  optional string str = 1;

  // The current value of the random number sequence used in tests.
  optional uint32 seq_value = 2;

  // Monotonically increased on each packet.
  optional uint64 counter = 3;

  // No more packets should follow (from the current sequence).
  optional bool is_last = 4;

  message TestPayload {
    repeated string str = 1;
    repeated TestPayload nested = 2;

    optional string single_string = 4;

    optional int32 single_int = 5;
    repeated int32 repeated_ints = 6;

    // When 0 this is the bottom-most nested message.
    optional uint32 remaining_nesting_depth = 3;

    //repeated DebugAnnotation debug_annotations = 7;
  }
  optional TestPayload payload = 5;
}

// End of protos/perfetto/trace/test_event.proto

// Begin of protos/perfetto/trace/trace_packet_defaults.proto

// Default values for TracePacket fields that hold for a particular TraceWriter
// packet sequence. This message contains a subset of the TracePacket fields
// with matching IDs. When provided, these fields define the default values
// that should be applied, at import time, to all TracePacket(s) with the same
// |trusted_packet_sequence_id|, unless otherwise specified in each packet.
//
// Should be reemitted whenever incremental state is cleared on the sequence.
message TracePacketDefaults {
  optional uint32 timestamp_clock_id = 58;

  // Default values for TrackEvents (e.g. default track).
  optional TrackEventDefaults track_event_defaults = 11;

  // Defaults for perf profiler packets (PerfSample).
  optional PerfSampleDefaults perf_sample_defaults = 12;
}
// End of protos/perfetto/trace/trace_packet_defaults.proto

// Begin of protos/perfetto/trace/trace_uuid.proto

// A random unique ID that identifies the trace.
// This message has been introduced in v32. Prior to that, the UUID was
// only (optionally) present in the TraceConfig.trace_uuid_msb/lsb fields.
// This has been moved to a standalone packet to deal with new use-cases for
// go/gapless-aot, where the same tracing session can be serialized several
// times, in which case the UUID is changed on each snapshot and does not match
// the one in the TraceConfig.
message TraceUuid {
  optional int64 msb = 1;
  optional int64 lsb = 2;
}

// End of protos/perfetto/trace/trace_uuid.proto

// Begin of protos/perfetto/trace/track_event/process_descriptor.proto

// Describes a process's attributes. Emitted as part of a TrackDescriptor,
// usually by the process's main thread.
//
// Next id: 9.
message ProcessDescriptor {
  optional int32 pid = 1;
  repeated string cmdline = 2;
  optional string process_name = 6;

  optional int32 process_priority = 5;
  // Process start time in nanoseconds.
  // The timestamp refers to the trace clock by default. Other clock IDs
  // provided in TracePacket are not supported.
  optional int64 start_timestamp_ns = 7;

  // ---------------------------------------------------------------------------
  // Deprecated / legacy fields, which will be removed in the future:
  // ---------------------------------------------------------------------------

  // See chromium's content::ProcessType.
  enum ChromeProcessType {
    PROCESS_UNSPECIFIED = 0;
    PROCESS_BROWSER = 1;
    PROCESS_RENDERER = 2;
    PROCESS_UTILITY = 3;
    PROCESS_ZYGOTE = 4;
    PROCESS_SANDBOX_HELPER = 5;
    PROCESS_GPU = 6;
    PROCESS_PPAPI_PLUGIN = 7;
    PROCESS_PPAPI_BROKER = 8;
  }
  optional ChromeProcessType chrome_process_type = 4;

  // To support old UI. New UI should determine default sorting by process_type.
  optional int32 legacy_sort_index = 3;

  // Labels can be used to further describe properties of the work performed by
  // the process. For example, these can be used by Chrome renderer process to
  // provide titles of frames being rendered.
  repeated string process_labels = 8;
}

// End of protos/perfetto/trace/track_event/process_descriptor.proto

// Begin of protos/perfetto/trace/track_event/range_of_interest.proto

// This message specifies the "range of interest" for track events. With the
// `drop_track_event_data_before` option set to `kTrackEventRangeOfInterest`,
// Trace Processor drops track events outside of this range.
message TrackEventRangeOfInterest {
  optional int64 start_us = 1;
}
// End of protos/perfetto/trace/track_event/range_of_interest.proto

// Begin of protos/perfetto/trace/track_event/thread_descriptor.proto

// Describes a thread's attributes. Emitted as part of a TrackDescriptor,
// usually by the thread's trace writer.
//
// Next id: 9.
message ThreadDescriptor {
  optional int32 pid = 1;
  optional int32 tid = 2;

  optional string thread_name = 5;

  // ---------------------------------------------------------------------------
  // Deprecated / legacy fields, which will be removed in the future:
  // ---------------------------------------------------------------------------

  optional int64 reference_timestamp_us = 6;

  // Absolute reference values. Clock values in subsequent TrackEvents can be
  // encoded accumulatively and relative to these. This reduces their var-int
  // encoding size.
  // TODO(eseckler): Deprecated. Replace these with ClockSnapshot encoding.
  optional int64 reference_thread_time_us = 7;
  optional int64 reference_thread_instruction_count = 8;

  // To support old UI. New UI should determine default sorting by thread_type.
  optional int32 legacy_sort_index = 3;
}

// End of protos/perfetto/trace/track_event/thread_descriptor.proto

// Begin of protos/perfetto/trace/track_event/chrome_process_descriptor.proto

// Describes the attributes for a Chrome process. Must be paired with a
// ProcessDescriptor in the same TrackDescriptor.
//
// Next id: 6.
// End of protos/perfetto/trace/track_event/chrome_process_descriptor.proto

// Begin of protos/perfetto/trace/track_event/chrome_thread_descriptor.proto

// Describes a Chrome thread's attributes. Emitted as part of a TrackDescriptor,
// usually by the thread's trace writer. Must be paired with a ThreadDescriptor
// in the same TrackDescriptor.
//
// Next id: 3.
// End of protos/perfetto/trace/track_event/chrome_thread_descriptor.proto

// Begin of protos/perfetto/trace/track_event/counter_descriptor.proto

// Defines properties of a counter track, e.g. for built-in counters (thread
// time, instruction count, ..) or user-specified counters (e.g. memory usage of
// a specific app component).
//
// Counter tracks only support TYPE_COUNTER track events, which specify new
// values for the counter. For counters that require per-slice values, counter
// values can instead be provided in a more efficient encoding via TrackEvent's
// |extra_counter_track_uuids| and |extra_counter_values| fields. However,
// slice-type events cannot be emitted onto a counter track.
//
// Values for counters that are only emitted on a single packet sequence can
// optionally be delta-encoded, see |is_incremental|.
//
// Next id: 7.
message CounterDescriptor {
  // Built-in counters, usually with special meaning in the client library,
  // trace processor, legacy JSON format, or UI. Trace processor will infer a
  // track name from the enum value if none is provided in TrackDescriptor.
  enum BuiltinCounterType {
    COUNTER_UNSPECIFIED = 0;

    // Thread-scoped counters. The thread's track should be specified via
    // |parent_uuid| in the TrackDescriptor for such a counter.

    // implies UNIT_TIME_NS.
    COUNTER_THREAD_TIME_NS = 1;

    // implies UNIT_COUNT.
    COUNTER_THREAD_INSTRUCTION_COUNT = 2;
  }

  // Type of the values for the counters - to supply lower granularity units,
  // see also |unit_multiplier|.
  enum Unit {
    UNIT_UNSPECIFIED = 0;
    UNIT_TIME_NS = 1;
    UNIT_COUNT = 2;
    UNIT_SIZE_BYTES = 3;
    // TODO(eseckler): Support more units as necessary.
  }

  // For built-in counters (e.g. thread time). Custom user-specified counters
  // (e.g. those emitted by TRACE_COUNTER macros of the client library)
  // shouldn't set this, and instead provide a counter name via TrackDescriptor.
  optional BuiltinCounterType type = 1;

  // Names of categories of the counter (usually for user-specified counters).
  // In the client library, categories are a way to turn groups of individual
  // counters (or events) on or off.
  repeated string categories = 2;

  // Type of the counter's values. Built-in counters imply a value for this
  // field.
  optional Unit unit = 3;

  // In order to use a unit not defined as a part of |Unit|, a free-form unit
  // name can be used instead.
  optional string unit_name = 6;

  // Multiplication factor of this counter's values, e.g. to supply
  // COUNTER_THREAD_TIME_NS timestamps in microseconds instead.
  optional int64 unit_multiplier = 4;

  // Whether values for this counter are provided as delta values. Only
  // supported for counters that are emitted on a single packet-sequence (e.g.
  // thread time). Counter values in subsequent packets on the current packet
  // sequence will be interpreted as delta values from the sequence's most
  // recent value for the counter. When incremental state is cleared, the
  // counter value is considered to be reset to 0. Thus, the first value after
  // incremental state is cleared is effectively an absolute value.
  optional bool is_incremental = 5;

  // TODO(eseckler): Support arguments describing the counter (?).
  // repeated DebugAnnotation debug_annotations;
}

// End of protos/perfetto/trace/track_event/counter_descriptor.proto

// Begin of protos/perfetto/trace/track_event/track_descriptor.proto

// Defines a track for TrackEvents. Slices and instant events on the same track
// will be nested based on their timestamps, see TrackEvent::Type.
//
// A TrackDescriptor only needs to be emitted by one trace writer / producer and
// is valid for the entirety of the trace. To ensure the descriptor isn't lost
// when the ring buffer wraps, it should be reemitted whenever incremental state
// is cleared.
//
// As a fallback, TrackEvents emitted without an explicit track association will
// be associated with an implicit trace-global track (uuid = 0), see also
// |TrackEvent::track_uuid|. It is possible but not necessary to emit a
// TrackDescriptor for this implicit track.
//
// Next id: 10.
message TrackDescriptor {
  // Unique ID that identifies this track. This ID is global to the whole trace.
  // Producers should ensure that it is unlikely to clash with IDs emitted by
  // other producers. A value of 0 denotes the implicit trace-global track.
  //
  // For example, legacy TRACE_EVENT macros may use a hash involving the async
  // event id + id_scope, pid, and/or tid to compute this ID.
  optional uint64 uuid = 1;

  // A parent track reference can be used to describe relationships between
  // tracks. For example, to define an asynchronous track which is scoped to a
  // specific process, specify the uuid for that process's process track here.
  // Similarly, to associate a COUNTER_THREAD_TIME_NS counter track with a
  // thread, specify the uuid for that thread's thread track here.
  optional uint64 parent_uuid = 5;

  // Name of the track. Optional - if unspecified, it may be derived from the
  // process/thread name (process/thread tracks), the first event's name (async
  // tracks), or counter name (counter tracks).
  optional string name = 2;

  // Associate the track with a process, making it the process-global track.
  // There should only be one such track per process (usually for instant
  // events; trace processor uses this fact to detect pid reuse). If you need
  // more (e.g. for asynchronous events), create child tracks using parent_uuid.
  //
  // Trace processor will merge events on a process track with slice-type events
  // from other sources (e.g. ftrace) for the same process into a single
  // timeline view.
  optional ProcessDescriptor process = 3;
 // optional ChromeProcessDescriptor chrome_process = 6;

  // Associate the track with a thread, indicating that the track's events
  // describe synchronous code execution on the thread. There should only be one
  // such track per thread (trace processor uses this fact to detect tid reuse).
  //
  // Trace processor will merge events on a thread track with slice-type events
  // from other sources (e.g. ftrace) for the same thread into a single timeline
  // view.
  optional ThreadDescriptor thread = 4;
 // optional ChromeThreadDescriptor chrome_thread = 7;

  // Descriptor for a counter track. If set, the track will only support
  // TYPE_COUNTER TrackEvents (and values provided via TrackEvent's
  // |extra_counter_values|).
  optional CounterDescriptor counter = 8;

  // If true, forces Trace Processor to use separate tracks for track events
  // and system events for the same thread.
  // Track events timestamps in Chrome have microsecond resolution, while
  // system events use nanoseconds. It results in broken event nesting when
  // track events and system events share a track.
  optional bool disallow_merging_with_system_tracks = 9;
}

// End of protos/perfetto/trace/track_event/track_descriptor.proto

// Begin of protos/perfetto/trace/translation/translation_table.proto

// Translation rules for the trace processor.
// See the comments for each rule type for specific meaning.
message TranslationTable {
  oneof table {
    ChromeHistorgramTranslationTable chrome_histogram = 1;
    //ChromeUserEventTranslationTable chrome_user_event = 2;
    ChromePerformanceMarkTranslationTable chrome_performance_mark = 3;
    SliceNameTranslationTable slice_name = 4;
  }
}

// Chrome histogram sample hash -> name translation rules.
message ChromeHistorgramTranslationTable {
  map<uint64, string> hash_to_name = 1;
}

// Chrome user event action hash -> name translation rules.
//message ChromeUserEventTranslationTable {
 // map<uint64, string> action_hash_to_name = 1;
//}

// Chrome performance mark translation rules.
message ChromePerformanceMarkTranslationTable {
  map<uint32, string> site_hash_to_name = 1;
  map<uint32, string> mark_hash_to_name = 2;
};

// Raw -> deobfuscated slice name translation rules.
message SliceNameTranslationTable {
  map<string, string> raw_to_deobfuscated_name = 1;
};

// End of protos/perfetto/trace/translation/translation_table.proto

// Begin of protos/perfetto/trace/trigger.proto

// When a TracingSession receives a trigger it records the boot time nanoseconds
// in the TracePacket's timestamp field as well as the name of the producer that
// triggered it. We emit this data so filtering can be done on triggers received
// in the trace.
message Trigger {
  // Name of the trigger which was received.
  optional string trigger_name = 1;
  // The actual producer that activated |trigger|.
  optional string producer_name = 2;
  // The verified UID of the producer.
  optional int32 trusted_producer_uid = 3;
}

// End of protos/perfetto/trace/trigger.proto

// Begin of protos/perfetto/trace/ui_state.proto

// Common state for UIs visualizing Perfetto traces.
// This message can be appended as a TracePacket by UIs to save the
// visible state (e.g. scroll position/zoom state) for future opening
// of the trace.
// Design doc: go/trace-ui-state.
message UiState {
  // The start and end bounds of the viewport of the UI in nanoseconds.
  //
  // This is the absolute time associated to slices and other events in
  // trace processor tables (i.e. the |ts| column of most tables)
  optional int64 timeline_start_ts = 1;
  optional int64 timeline_end_ts = 2;

  // Indicates that the given process should be highlighted by the UI.
  message HighlightProcess {
    oneof selector {
      // The pid of the process to highlight. This is useful for UIs to focus
      // on tracks of a particular process in the trace.
      //
      // If more than one process in a trace has the same pid, it is UI
      // implementation specific how the process to be focused will be
      // chosen.
      uint32 pid = 1;

      // The command line of the process to highlight; for most Android apps,
      // this is the package name of the app. This is useful for UIs to focus
      // on a particular app in the trace.
      //
      // If more than one process hasthe same cmdline, it is UI implementation
      // specific how the process to be focused will be chosen.
      string cmdline = 2;
    }
  }
  optional HighlightProcess highlight_process = 3;
}
// End of protos/perfetto/trace/ui_state.proto

// Begin of protos/perfetto/trace/trace_packet.proto

// TracePacket is the root object of a Perfetto trace.
// A Perfetto trace is a linear sequence of TracePacket(s).
//
// The tracing service guarantees that all TracePacket(s) written by a given
// TraceWriter are seen in-order, without gaps or duplicates. If, for any
// reason, a TraceWriter sequence becomes invalid, no more packets are returned
// to the Consumer (or written into the trace file).
// TracePacket(s) written by different TraceWriter(s), hence even different
// data sources, can be seen in arbitrary order.
// The consumer can re-establish a total order, if interested, using the packet
// timestamps, after having synchronized the different clocks onto a global
// clock.
//
// The tracing service is agnostic of the content of TracePacket, with the
// exception of few fields (e.g.. trusted_*, trace_config) that are written by
// the service itself.
//
// See the [Buffers and Dataflow](/docs/concepts/buffers.md) doc for details.
//
// Next reserved id: 14 (up to 15).
// Next id: 95.
message TracePacket {
  // The timestamp of the TracePacket.
  // By default this timestamps refers to the trace clock (CLOCK_BOOTTIME on
  // Android). It can be overridden using a different timestamp_clock_id.
  // The clock domain definition in ClockSnapshot can also override:
  // - The unit (default: 1ns).
  // - The absolute vs delta encoding (default: absolute timestamp).
  optional uint64 timestamp = 8;

  // Specifies the ID of the clock used for the TracePacket |timestamp|. Can be
  // one of the built-in types from ClockSnapshot::BuiltinClocks, or a
  // producer-defined clock id.
  // If unspecified and if no default per-sequence value has been provided via
  // TracePacketDefaults, it defaults to BuiltinClocks::BOOTTIME.
  optional uint32 timestamp_clock_id = 58;

  oneof data {
    ProcessTree process_tree = 2;
    ProcessStats process_stats = 9;
    //InodeFileMap inode_file_map = 4;
    //ChromeEventBundle chrome_events = 5;
    ClockSnapshot clock_snapshot = 6;
    //SysStats sys_stats = 7;
    TrackEvent track_event = 11;

    // IDs up to 15 are reserved. They take only one byte to encode their
    // preamble so should be used for frequent events.

    TraceUuid trace_uuid = 89;
    TraceConfig trace_config = 33;
    //FtraceStats ftrace_stats = 34;
    TraceStats trace_stats = 35;
    //ProfilePacket profile_packet = 37;
    //StreamingAllocation streaming_allocation = 74;
    //StreamingFree streaming_free = 75;
    //BatteryCounters battery = 38;
    //PowerRails power_rails = 40;
    //AndroidLogPacket android_log = 39;
    SystemInfo system_info = 45;
    Trigger trigger = 46;
    //PackagesList packages_list = 47;
    //ChromeBenchmarkMetadata chrome_benchmark_metadata = 48;
    //PerfettoMetatrace perfetto_metatrace = 49;
    //ChromeMetadataPacket chrome_metadata = 51;
    //GpuCounterEvent gpu_counter_event = 52;
    //GpuRenderStageEvent gpu_render_stage_event = 53;
    //StreamingProfilePacket streaming_profile_packet = 54;
    //HeapGraph heap_graph = 56;
    //GraphicsFrameEvent graphics_frame_event = 57;
    //VulkanMemoryEvent vulkan_memory_event = 62;
    //GpuLog gpu_log = 63;
    //VulkanApiEvent vulkan_api_event = 65;
    PerfSample perf_sample = 66;
    CpuInfo cpu_info = 67;
    //SmapsPacket smaps_packet = 68;
    //TracingServiceEvent service_event = 69;
    //InitialDisplayState initial_display_state = 70;
    //GpuMemTotalEvent gpu_mem_total_event = 71;
    //MemoryTrackerSnapshot memory_tracker_snapshot = 73;
    //FrameTimelineEvent frame_timeline_event = 76;
    //AndroidEnergyEstimationBreakdown android_energy_estimation_breakdown = 77;
    UiState ui_state = 78;
    //AndroidCameraFrameEvent android_camera_frame_event = 80;
    //AndroidCameraSessionStats android_camera_session_stats = 81;
    TranslationTable translation_table = 82;
    //AndroidGameInterventionList android_game_intervention_list = 83;
    StatsdAtom statsd_atom = 84;
    //AndroidSystemProperty android_system_property = 86;
    //EntityStateResidency entity_state_residency = 91;

    // Only used in profile packets.
    //ProfiledFrameSymbols profiled_frame_symbols = 55;
    //ModuleSymbols module_symbols = 61;
    //DeobfuscationMapping deobfuscation_mapping = 64;

    // Only used by TrackEvent.
    TrackDescriptor track_descriptor = 60;

    // Deprecated, use TrackDescriptor instead.
    ProcessDescriptor process_descriptor = 43;

    // Deprecated, use TrackDescriptor instead.
    ThreadDescriptor thread_descriptor = 44;

    // Events from the Linux kernel ftrace infrastructure.
    //FtraceEventBundle ftrace_events = 1;

    // This field is emitted at periodic intervals (~10s) and
    // contains always the binary representation of the UUID
    // {82477a76-b28d-42ba-81dc-33326d57a079}. This is used to be able to
    // efficiently partition long traces without having to fully parse them.
    bytes synchronization_marker = 36;

    // Zero or more proto encoded trace packets compressed using deflate.
    // Each compressed_packets TracePacket (including the two field ids and
    // sizes) should be less than 512KB.
    bytes compressed_packets = 50;

    // Data sources can extend the trace proto with custom extension protos (see
    // docs/design-docs/extensions.md). When they do that, the descriptor of
    // their extension proto descriptor is serialized in this packet. This
    // allows trace_processor to deserialize extended messages using reflection
    // even if the extension proto is not checked in the Perfetto repo.
    ExtensionDescriptor extension_descriptor = 72;

    // Represents a single packet sent or received by the network.
    //NetworkPacketEvent network_packet = 88;

    // Represents one or more packets sent or received by the network.
    //NetworkPacketBundle network_packet_bundle = 92;

    // The "range of interest" for track events. See the message definition
    // comments for more details.
    TrackEventRangeOfInterest track_event_range_of_interest = 90;

    // Winscope traces
    //LayersSnapshotProto surfaceflinger_layers_snapshot = 93;
    //TransactionTraceEntry surfaceflinger_transactions = 94;

    // This field is only used for testing.
    // In previous versions of this proto this field had the id 268435455
    // This caused many problems:
    // - protozero decoder does not handle field ids larger than 999.
    // - old versions of protoc produce Java bindings with syntax errors when
    //   the field id is large enough.
    TestEvent for_testing = 900;
  // gpu_freq.Packet gpu_freq_packet = 1001;
  }

  // Trusted user id of the producer which generated this packet. Keep in sync
  // with TrustedPacket.trusted_uid.
  //
  // TODO(eseckler): Emit this field in a PacketSequenceDescriptor message
  // instead.
  oneof optional_trusted_uid { int32 trusted_uid = 3; };

  // Service-assigned identifier of the packet sequence this packet belongs to.
  // Uniquely identifies a producer + writer pair within the tracing session. A
  // value of zero denotes an invalid ID. Keep in sync with
  // TrustedPacket.trusted_packet_sequence_id.
  oneof optional_trusted_packet_sequence_id {
    uint32 trusted_packet_sequence_id = 10;
  }

  // Trusted process id of the producer which generated this packet, written by
  // the service.
  optional int32 trusted_pid = 79;

  // Incrementally emitted interned data, valid only on the packet's sequence
  // (packets with the same |trusted_packet_sequence_id|). The writer will
  // usually emit new interned data in the same TracePacket that first refers to
  // it (since the last reset of interning state). It may also be emitted
  // proactively in advance of referring to them in later packets.
 // optional InternedData interned_data = 12;

  enum SequenceFlags {
    SEQ_UNSPECIFIED = 0;

    // Set by the writer to indicate that it will re-emit any incremental data
    // for the packet's sequence before referring to it again. This includes
    // interned data as well as periodically emitted data like
    // Process/ThreadDescriptors. This flag only affects the current packet
    // sequence (see |trusted_packet_sequence_id|).
    //
    // When set, this TracePacket and subsequent TracePackets on the same
    // sequence will not refer to any incremental data emitted before this
    // TracePacket. For example, previously emitted interned data will be
    // re-emitted if it is referred to again.
    //
    // When the reader detects packet loss (|previous_packet_dropped|), it needs
    // to skip packets in the sequence until the next one with this flag set, to
    // ensure intact incremental data.
    SEQ_INCREMENTAL_STATE_CLEARED = 1;

    // This packet requires incremental state, such as TracePacketDefaults or
    // InternedData, to be parsed correctly. The trace reader should skip this
    // packet if incremental state is not valid on this sequence, i.e. if no
    // packet with the SEQ_INCREMENTAL_STATE_CLEARED flag has been seen on the
    // current |trusted_packet_sequence_id|.
    SEQ_NEEDS_INCREMENTAL_STATE = 2;
  };
  optional uint32 sequence_flags = 13;

  // DEPRECATED. Moved to SequenceFlags::SEQ_INCREMENTAL_STATE_CLEARED.
  optional bool incremental_state_cleared = 41;

  // Default values for fields of later TracePackets emitted on this packet's
  // sequence (TracePackets with the same |trusted_packet_sequence_id|).
  // It must be reemitted when incremental state is cleared (see
  // |incremental_state_cleared|).
  // Requires that any future packet emitted on the same sequence specifies
  // the SEQ_NEEDS_INCREMENTAL_STATE flag.
  // TracePacketDefaults always override the global defaults for any future
  // packet on this sequence (regardless of SEQ_NEEDS_INCREMENTAL_STATE).
  optional TracePacketDefaults trace_packet_defaults = 59;

  // Flag set by the service if, for the current packet sequence (see
  // |trusted_packet_sequence_id|), either:
  // * this is the first packet, or
  // * one or multiple packets were dropped since the last packet that the
  //   consumer read from the sequence. This can happen if chunks in the trace
  //   buffer are overridden before the consumer could read them when the trace
  //   is configured in ring buffer mode.
  //
  // When packet loss occurs, incrementally emitted data (including interned
  // data) on the sequence should be considered invalid up until the next packet
  // with SEQ_INCREMENTAL_STATE_CLEARED set.
  optional bool previous_packet_dropped = 42;

  // Flag set by a producer (starting from SDK v29) if, for the current packet
  // sequence (see |trusted_packet_sequence_id|), this is the first packet.
  //
  // This flag can be used for distinguishing the two situations when
  // processing the trace:
  // 1. There are no prior events for the sequence because of data loss, e.g.
  //    due to ring buffer wrapping.
  // 2. There are no prior events for the sequence because it didn't start
  //    before this packet (= there's definitely no preceeding data loss).
  //
  // Given that older SDK versions do not support this flag, this flag not
  // being present for a particular sequence does not necessarily imply data
  // loss.
  optional bool first_packet_on_sequence = 87;
}

// End of protos/perfetto/trace/trace_packet.proto

// Begin of protos/perfetto/trace/trace.proto

message Trace {
  repeated TracePacket packet = 1;

  // Do NOT add any other field here. This is just a convenience wrapper for
  // the use case of a trace being saved to a file. There are other cases
  // (streaming) where TracePacket are directly streamed without being wrapped
  // in a Trace proto. Nothing should ever rely on the full trace, all the
  // logic should be based on TracePacket(s).
}

// End of protos/perfetto/trace/trace.proto
