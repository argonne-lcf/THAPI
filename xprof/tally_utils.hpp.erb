#pragma once

#include <string>
#include <iomanip>
#include <climits>
#include <unordered_map>
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <regex>
#include "xprof_utils.hpp"
#include "my_demangle.h"
#include <json.hpp>

using nlohmann::json;

template <typename T>
std::string to_string_with_precision(const T a_value, const std::string extension, const int n = 2)
{
   std::ostringstream out;
   out.precision(n);
   out << std::fixed << a_value << extension;
   return out.str();
}

template <typename T>
std::string format_byte(const T duration) {
<%[  ['TB', '1e+12'],
     ['GB', '1e+9'],
     ['MB', '1e+6'],
     ['kB', '1e+3'],
     ['B', '1']].each do | unit, factor |  %>
   const double <%= unit %> = duration / <%= factor %>;
   if (<%= unit %> >= 1.) {
      return to_string_with_precision(<%= unit %>, "<%= unit %>");
   }
<% end %>
   return "";
}

template <typename T>
std::string format_time(const T duration) {
<% [['h', '3.6e+12'],
    ['min', '6e+10'],
    ['s', '1e+9'],
    ['ms', '1e+6'],
    ['us', '1e+3'],
    ['ns', '1']].each do | unit, factor |  %>
   const double <%= unit %> = duration / <%= factor %>;
   if (<%= unit %> >= 1.) {
      return to_string_with_precision(<%= unit %>, "<%= unit %>");
   }
<% end %>
   return "";
}

thapi_function_name f_demangle_name(thapi_function_name mangle_name) {
   std::string result = mangle_name;

   // C++ don't handle PCRE, hence and lazy/non-greedy and $.
   const std::regex base_regex("__omp_offloading_[^_]+_[^_]+_(.*?)_[^_]+$");
   std::smatch base_match;
   if (std::regex_match(mangle_name, base_match, base_regex) && base_match.size() == 2)
      result = base_match[1].str();

   const char* demangle = my_demangle(result.c_str());
   if (demangle) {
       thapi_function_name s{demangle};
       /* We name the kernels after the type that gets passed in the first 
          template parameter to the sycl_kernel function in order to prevent 
          it from conflicting with any actual function name.  
          The result is the demangling will always be something like, “typeinfo for...”. 
       */
       if (s.rfind("typeinfo name for ") == 0) 
           return s.substr(<%= "typeinfo name for ".size %>, s.size());
       return s;
   }
   return mangle_name;
};

/*
Class for time
 */

struct StatIprof_string {
   std::string time;
   std::string time_ratio;
   std::string count;
   std::string avg;
   std::string min;
   std::string max;
   std::string error;
};

class StatIprof {

  public:
    void delta(const uint64_t, const bool);
    void merge(StatIprof);
    StatIprof_string to_string(const uint64_t);
    void finalize(const uint64_t total_time);

    //Used in merge
    uint64_t _start;
    uint64_t _count{0};
    uint64_t _min{ULONG_MAX};
    uint64_t _max{0};
    uint64_t _time{0};
    uint64_t _error{0};
    double _time_ratio{0};
    double _avg{0};
};

void StatIprof::delta(const uint64_t delta,const bool error) {
   _min = std::min(_min,delta);
   _max = std::max(_max,delta);
   _count++;
   // total can overflow. Need to handle that correctly at some point...
   _time += delta;
   if (error) {
       _error += 1;
   }
}

void StatIprof::merge(StatIprof st) {
   _min = std::min(_min,st._min);
   _max = std::max(_max,st._max);
   // total can overflow. Need to handle that correctly at some point...
   _count += st._count;
   _time += st._time;
   _error += st._error;
}

void StatIprof::finalize(const uint64_t total_time){
    _avg = _count ? static_cast<double>(_time) / _count : 0.;
    _time_ratio = static_cast<double>(_time) / total_time;
}

<% { "StatTime" => "format_time",
     "StatByte" => "format_byte" }.each do |n,t| %>
class <%= n %>: public StatIprof {
   public:
     StatIprof_string to_string(const uint64_t total_time){
        finalize(total_time);
        return StatIprof_string{<%= t %>(_time), // Time
                                to_string_with_precision( (100.*_time_ratio), "%"), // Percent
                                to_string_with_precision(_count,"",0), // Count
                                <%= t %>(_avg),
                                <%= t %>(_min != ULONG_MAX ? _min : 0),
                                <%= t %>(_max),
                                to_string_with_precision(_error,"",0)};
    }
};

void to_json(json& j, const <%= n %>& p) {
    <% if n == "StatTime" %>
   j = json{{"time", p._time}, {"call", p._count},
            {"min", p._min}, {"max", p._max} };
   <% else %>
   j = json{{"size", p._time}, {"call", p._count},
            {"min", p._min}, {"max", p._max} };
   <% end %>
   if (p._error != 0)
     j["error"] = p._error; 
}

<% end %>

<%#
   _                              _   
  /   _  ._ _  ._   _.  _ _|_ o _|_   
  \_ (_) | | | |_) (_| (_  |_ |  | \/ 
               |                   /  
%>
// `2 Hostnames | 2 Processes | 9 Threads | 0 Device | 0 SubDevice`
typedef std::tuple<int,int,int, int, int> condensed_header_t;

void to_json(json& j, const condensed_header_t& h) {
   j = json{ {"hostname", std::get<0>(h) },
             {"process",  std::get<1>(h) },
             {"thread",   std::get<2>(h) } };
   if (std::get<3>(h) != 0)
      j["device"] = std::get<3>(h);
   if (std::get<4>(h) != 0)
      j["subdevice"] = std::get<4>(h);
}

   <% output = [ ['StatTime', 'std::unordered_map<hpt_function_name_t, StatTime>', 'host', 'API calls', '1', 'hpt_t',
                    [ ['hostname_t','Hostnames','Hostname'],
                      ['process_id_t','Processes','Process'],
                      ['thread_id_t','Threads','Thread'] ] ],
   ['StatTime', 'std::unordered_map<hpt_device_function_name_t, StatTime>', 'device','Device profiling', '0', 'hpt_dsd_t',
                    [ ['hostname_t','Hostnames','Hostname'],
                      ['hp_t','Processes','Process'],
                      ['hpt_t','Threads','Thread'] ,
                      ['hp_device_t','Device pointers','Device'],
                      ['hp_dsd_t','SubDevice pointers','SubDevice'] ] ],
   ['StatByte', 'std::unordered_map<hpt_function_name_t, StatByte>', 'traffic', 'Explicit memory traffic', '0', 'hpt_t',
                    [ ['hostname_t','Hostnames','Hostname'],
                      ['process_id_t','Processes','Process'],
                      ['thread_id_t','Threads','Thread'] ] ],
   ] %>

<% output.each do |main_type, tuple_typle, result,header, error, type, var| %>
std::pair<condensed_header_t, std::unordered_map<thapi_function_name, <%= main_type %>> >  condensed_tally_<%= result %>( <%=tuple_typle %>  <%=result%> ){
   condensed_header_t count;
   <% var.each do |t,n,_ | %>
   std::set<<%= t %>> s_<%= n.gsub(' ','_') %>;
   <% end %>
   <%# Agreagate API Call Result and compute total time spend %>
   std::unordered_map<thapi_function_name, <%= main_type %> > aggregated;
   for (auto element: <%= result %>)
   {
       auto [ <%= var.map{ |t,n| n.gsub(' ','_')}.join(',') %>,function_name ] = element.first;
       const <%= main_type %> time = element.second;
    <% if type == "hpt_dsd_t" %>
       s_Hostnames.insert(hostname_t{Hostnames} ) ;
       s_Processes.insert(hp_t{Hostnames,Processes} ) ;
       s_Threads.insert(hpt_t{Hostnames,Processes,Threads} ) ;
       s_Device_pointers.insert(hp_device_t{Hostnames,Processes,Device_pointers} ) ;
       <%# This is apporixmation. Maybe two sub device alias to the same pointer. We cannot post-process that. But good enought to give a name %>
       s_SubDevice_pointers.insert(hp_dsd_t{Hostnames,Processes,Device_pointers,SubDevice_pointers} ) ;
    <% else %>
    <% var.each do | _, n,_ | %>
       s_<%=  n.gsub(' ','_') %>.insert(<%= n.gsub(' ','_') %>) ;
    <% end %>
    <% end %>
       aggregated[function_name].merge(time);
   }
    <% if type == "hpt_dsd_t" %>
   {
       std::set<hp_dsd_t> s_ToDelete;
       for (auto element: s_SubDevice_pointers) {
           auto [ _a, _b, d1, d2 ] = element;
           (void)_a; (void)_b; <%# Use un-used variable %>
           if ( d1 == d2 ) {
             s_ToDelete.insert(element);
           }
       }
       for (auto element: s_ToDelete)
           s_SubDevice_pointers.erase(element);
   }
    <% end%>

    <% var.each_with_index do |(_,n,_),i | %>
      std::get<<%= i%>>(count) = s_<%= n.gsub(' ','_') %>.size();
    <% end %>
    return std::make_pair(count, aggregated);
}
<% end %>
   
<%#
   _
  |_) ._ o ._ _|_    /\  ._ ._ _.
  |   |  | | | |_   /--\ |  | (_| \/
                                  /
%>

<% l_menbers = ['function_name', 'time','time_ratio','count','avg','min','max','error'] %>
<% d_headers = [ ["StatTime","format_time",  [ 'Name', 'Time', 'Time(%)', 'Calls', 'Average', 'Min', 'Max', 'Failed'] ],
                 ["StatByte", "format_byte", [ 'Name', 'Byte', 'Byte(%)', 'Calls', 'Average', 'Min', 'Max', 'Failed'] ] ]  %>

<% d_headers.each do | main_type, main_function, l_headers | %>
bool print_array(std::unordered_map<thapi_function_name, <%= main_type %> > aggregated, 
                 std::string header, 
                 unsigned int _print_error = 0,
                 bool demangle_name = false) {
    <%# print_error = 0 -> Never print error
                    = 1 -> Print only when error
                    >= 2 -> Always print error
    %>

    uint64_t total_time{0};
    uint64_t total_count{0};
    uint64_t total_error{0};
    for (std::pair<thapi_function_name,  <%= main_type %> > element: aggregated) {
        total_time += element.second._time;
        total_count += element.second._count;
        total_error += element.second._error;
   }
   if (!total_count)
        return true;

   std::cout << header << std::endl;

   bool print_error;
   if (_print_error == 0)
        print_error = false;
   else if (_print_error == 1)
        print_error = total_error != 0;
   else
        print_error = true;

   <%# Sort the table by time %>
   <%# Need to do map -> vector for that... %>
   std::vector<std::pair<thapi_function_name, <%= main_type %> >> array_sorted;
   array_sorted.reserve(aggregated.size());
   for (std::pair<thapi_function_name, <%= main_type %> > element: aggregated) {
      if (demangle_name) {
         array_sorted.push_back(std::make_pair(f_demangle_name(element.first), element.second));
      } else {
         array_sorted.push_back(element);
      }
   }
   std::sort(array_sorted.begin(), array_sorted.end(), [](auto a, auto b) { return a.second._time > b.second._time;} );


<%# Need to be bigger than the header %>
<% l_menbers.zip(l_headers).each do |v, n| %>
   uint64_t len_max_<%= v %> = <%= n.size() %>;
<% end %>

<%# Need to be bigger than the footer %>
   len_max_function_name = std::max(len_max_function_name,  uint64_t{<%= "Total".size() %>} );
   len_max_time = std::max(len_max_time, <%= main_function %>(total_time).size());
   len_max_count = std::max(len_max_count, to_string_with_precision(total_count,"",0).size() );
   len_max_error = std::max(len_max_error, to_string_with_precision(total_error,"",0).size() );

<%# Need to be bigger than the body %>
   for (std::pair<thapi_function_name,  <%= main_type %> > element: array_sorted) {
       len_max_function_name = std::max(len_max_function_name, element.first.size());
       const auto [time, time_ratio, count, avg, min, max, error ] = element.second.to_string(total_time);
  <% l_menbers.drop(1).each do |v| %>
       len_max_<%= v %> = std::max(len_max_<%= v %>, <%= v %>.size());
<% end %>
   }

<%# Print Header %>
<% l_menbers.zip(l_headers).each do |v, n| %>
    <% if v == "error" %>
   if (print_error)
    <% end %>
   std::cout << std::setw(len_max_<%= v %>) << std::right << "<%= n %>" << " | ";
    
<% end %>
   std::cout << std::endl;

<%# Print Body %>
   for (std::pair<thapi_function_name,  <%= main_type %> > element: array_sorted) {
        const thapi_function_name function_name = element.first;
        const auto [time, time_ratio, count, avg, min, max, error ] = element.second.to_string(total_time);
<% l_menbers.each do |v | %>
    <% if v == "error" %>
        if (print_error)
    <% end %>
        std::cout << std::setw(len_max_<%= v %>) << std::right << <%= v %> << " | ";
<% end %>
        std::cout << std::endl;
    }

<%# Print footer %>
   std::cout << std::setw(len_max_function_name) << std::right << "Total" << " | "
             << std::setw(len_max_time) << std::right << <%= main_function %>(total_time) << " | "
             << std::setw(len_max_time_ratio) << std::right << "100.00%" << " | "
             << std::setw(len_max_count) << std::right <<  to_string_with_precision(total_count,"",0) << " | ";
 if (print_error) {
    std::cout
         <% l_menbers.zip(l_headers).drop(4).each do |v,n| %>
                <% if v == "error" %>
                    << std::setw(len_max_error) << std::right <<  to_string_with_precision(total_error,"",0) << " | "
                <% else %>
                    << std::setw(len_max_<%= v %>) << "" << "   "
                <% end %>
            <% end %>
            ;
 }           
 std::cout << std::endl;
 return false;
}

<% end %>

<% d_headers.each do | main_type, main_function, l_headers | %>
void to_json(json& j, const std::unordered_map<thapi_function_name, <%= main_type %> > aggregated) {
   for (std::pair<thapi_function_name,  <%= main_type %> > element: aggregated)
   {
     auto [name, info] = element;
     j[name] = info;
   } 
}
<% end %>

<% output.each do |main_type, tuple_typle, result,header, error, type, var| %>
   <% if result != 'device' %>
void print_compact_<%= result %>( <%=tuple_typle %>  <%=result%> ){
   <% else %>
void print_compact_<%= result %>( <%=tuple_typle %>  <%=result%>, bool demangle_name ){
   <% end %>

   auto [header_count, aggregated] = condensed_tally_<%= result %>(<%=result%>);
  
   std::ostringstream oss;
   oss << "<%= header %>";
   <% var.each_with_index do | (_,n,_),i | %>
   if (std::get< <%= i %> >(header_count) != 0)
       oss << " | " << std::get< <%= i %> >(header_count) << " <%= n %>";
   <% end %>

   oss << std::endl;
   <% if result != 'device' %>
   const bool empty = print_array(aggregated, oss.str(), <%= error %>);
   <% else %>
   const bool empty = print_array(aggregated, oss.str(), <%= error %>, demangle_name);
    <% end %>
   if (!empty)
      std::cout << std::endl;
}

json json_compact_<%= result %>( <%=tuple_typle %>  <%=result%> ) {
   auto [header_count, aggregated] = condensed_tally_<%= result %>(<%=result%>);

   uint64_t total_time{0};
   uint64_t total_count{0};
   uint64_t total_error{0};
   for (std::pair<thapi_function_name,  <%= main_type %> > element: aggregated) {
        total_time += element.second._time;
        total_count += element.second._count;
        total_error += element.second._error;
   }

   json j;
   j["data"] = aggregated;

   //Automatic to_json doesn't work with typedef.
   json j2;
   to_json(j2, header_count);
   j["aggregate"] = j2;
   <% if main_type == "StatTime" %>
   j["aggregate"]["time"] = total_time;
   <% else %>
   j["aggregate"]["size"] = total_time;
   <% end %>
   j["aggregate"]["call"] = total_count;
   if (total_error != 0)
      j["aggregate"]["error"] = total_error;

   return j;
}

   <% if result != 'device' %>
void print_extented_<%= result %>( <%=tuple_typle %> <%=result%> ){
   <% else %>
void print_extented_<%= result %>( <%=tuple_typle %> <%=result%>, std::unordered_map<hp_device_t, std::string> device_to_name, bool demangle_name ){
   <% end  %>

   <% args = var.map{ |t,_,n| n}.join(',') %>
   std::unordered_map< <%= type %>, std::unordered_map<thapi_function_name, <%= main_type %> >> d;
   for (auto [s, time]: <%= result %> ) {
     auto [<%= args %>, function_name] = s;
     d[ <%= type %>( <%= args %> )][function_name].merge(time);
   }

   std::vector<std::pair< <%= type %> , std::unordered_map<thapi_function_name,  <%= main_type %> >>> array_sorted(d.begin(), d.end());
   std::sort(array_sorted.begin(), array_sorted.end(),   [](auto a, auto b) { return a.first > b.first ; } );

   for (auto[s, aggregated]: array_sorted) {
    auto [ <%= args %> ] = s;
    std::ostringstream oss;
    
    <% if type == "hpt_dsd_t" %>
    if (Device != SubDevice) {
    <% end %> 
    oss <<  "<%= header %>"
    <% var.each do | _,_, n | %>
        << " | <%= n %>: " 
        <% if n.include?('Device') %>
        << std::hex << std::showbase << std::internal << std::setfill('0')
        <% end %>
        << <%= n %>
        <% if n =='Device' and result == 'device' %>
        <<  " (" << device_to_name[hp_device_t(Hostname,Process,Device)] << ")"
        <% end %>
    <% end %>
        << std::endl;
    <% if type == "hpt_dsd_t" %>
    } else { 
    oss <<  "<%= header %>"
    <% var.map{| _,_, n | n}.filter{ |n| n != 'SubDevice'}.each do |n| %>
        << " | <%= n %>: "
        <% if n == 'Device' %>
        << std::hex << std::showbase << std::internal << std::setfill('0')
        <% end %>
        << <%= n %>
        <% if n =='Device' and result == 'device' %>
        <<  " (" << device_to_name[hp_device_t(Hostname,Process,Device)] << ")"
        <% end %>
     <% end %>
        << std::endl;
    }
    <% end %>
<% if result != 'device' %>
    const bool empty = print_array(aggregated, oss.str(), <%= error %>);
<% else %>
    const bool empty = print_array(aggregated, oss.str(), <%= error %>, demangle_name);
<% end %>
    if (!empty)
       std::cout << std::endl;
  }
};
<% end %>

