// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_EVENT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_EVENT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/field_writer.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class AllocPagesIommuEndFtraceEvent;
class AllocPagesIommuFailFtraceEvent;
class AllocPagesIommuStartFtraceEvent;
class AllocPagesSysEndFtraceEvent;
class AllocPagesSysFailFtraceEvent;
class AllocPagesSysStartFtraceEvent;
class BinderLockFtraceEvent;
class BinderLockedFtraceEvent;
class BinderSetPriorityFtraceEvent;
class BinderTransactionAllocBufFtraceEvent;
class BinderTransactionFtraceEvent;
class BinderTransactionReceivedFtraceEvent;
class BinderUnlockFtraceEvent;
class BlockBioBackmergeFtraceEvent;
class BlockBioBounceFtraceEvent;
class BlockBioCompleteFtraceEvent;
class BlockBioFrontmergeFtraceEvent;
class BlockBioQueueFtraceEvent;
class BlockBioRemapFtraceEvent;
class BlockDirtyBufferFtraceEvent;
class BlockGetrqFtraceEvent;
class BlockPlugFtraceEvent;
class BlockRqAbortFtraceEvent;
class BlockRqCompleteFtraceEvent;
class BlockRqInsertFtraceEvent;
class BlockRqIssueFtraceEvent;
class BlockRqRemapFtraceEvent;
class BlockRqRequeueFtraceEvent;
class BlockSleeprqFtraceEvent;
class BlockSplitFtraceEvent;
class BlockTouchBufferFtraceEvent;
class BlockUnplugFtraceEvent;
class CdevUpdateFtraceEvent;
class CgroupAttachTaskFtraceEvent;
class CgroupDestroyRootFtraceEvent;
class CgroupMkdirFtraceEvent;
class CgroupReleaseFtraceEvent;
class CgroupRemountFtraceEvent;
class CgroupRenameFtraceEvent;
class CgroupRmdirFtraceEvent;
class CgroupSetupRootFtraceEvent;
class CgroupTransferTasksFtraceEvent;
class ClkDisableFtraceEvent;
class ClkEnableFtraceEvent;
class ClkSetRateFtraceEvent;
class ClockDisableFtraceEvent;
class ClockEnableFtraceEvent;
class ClockSetRateFtraceEvent;
class ConsoleFtraceEvent;
class CpuFrequencyFtraceEvent;
class CpuFrequencyLimitsFtraceEvent;
class CpuIdleFtraceEvent;
class CpuhpEnterFtraceEvent;
class CpuhpExitFtraceEvent;
class CpuhpLatencyFtraceEvent;
class CpuhpMultiEnterFtraceEvent;
class CpuhpPauseFtraceEvent;
class CrosEcSensorhubDataFtraceEvent;
class DmaAllocContiguousRetryFtraceEvent;
class DmaFenceEmitFtraceEvent;
class DmaFenceInitFtraceEvent;
class DmaFenceSignaledFtraceEvent;
class DmaFenceWaitEndFtraceEvent;
class DmaFenceWaitStartFtraceEvent;
class DmaHeapStatFtraceEvent;
class DpuTracingMarkWriteFtraceEvent;
class DrmRunJobFtraceEvent;
class DrmSchedJobFtraceEvent;
class DrmSchedProcessJobFtraceEvent;
class DrmVblankEventDeliveredFtraceEvent;
class DrmVblankEventFtraceEvent;
class Ext4AllocDaBlocksFtraceEvent;
class Ext4AllocateBlocksFtraceEvent;
class Ext4AllocateInodeFtraceEvent;
class Ext4BeginOrderedTruncateFtraceEvent;
class Ext4CollapseRangeFtraceEvent;
class Ext4DaReleaseSpaceFtraceEvent;
class Ext4DaReserveSpaceFtraceEvent;
class Ext4DaUpdateReserveSpaceFtraceEvent;
class Ext4DaWriteBeginFtraceEvent;
class Ext4DaWriteEndFtraceEvent;
class Ext4DaWritePagesExtentFtraceEvent;
class Ext4DaWritePagesFtraceEvent;
class Ext4DirectIOEnterFtraceEvent;
class Ext4DirectIOExitFtraceEvent;
class Ext4DiscardBlocksFtraceEvent;
class Ext4DiscardPreallocationsFtraceEvent;
class Ext4DropInodeFtraceEvent;
class Ext4EsCacheExtentFtraceEvent;
class Ext4EsFindDelayedExtentRangeEnterFtraceEvent;
class Ext4EsFindDelayedExtentRangeExitFtraceEvent;
class Ext4EsInsertExtentFtraceEvent;
class Ext4EsLookupExtentEnterFtraceEvent;
class Ext4EsLookupExtentExitFtraceEvent;
class Ext4EsRemoveExtentFtraceEvent;
class Ext4EsShrinkCountFtraceEvent;
class Ext4EsShrinkFtraceEvent;
class Ext4EsShrinkScanEnterFtraceEvent;
class Ext4EsShrinkScanExitFtraceEvent;
class Ext4EvictInodeFtraceEvent;
class Ext4ExtConvertToInitializedEnterFtraceEvent;
class Ext4ExtConvertToInitializedFastpathFtraceEvent;
class Ext4ExtHandleUnwrittenExtentsFtraceEvent;
class Ext4ExtInCacheFtraceEvent;
class Ext4ExtLoadExtentFtraceEvent;
class Ext4ExtMapBlocksEnterFtraceEvent;
class Ext4ExtMapBlocksExitFtraceEvent;
class Ext4ExtPutInCacheFtraceEvent;
class Ext4ExtRemoveSpaceDoneFtraceEvent;
class Ext4ExtRemoveSpaceFtraceEvent;
class Ext4ExtRmIdxFtraceEvent;
class Ext4ExtRmLeafFtraceEvent;
class Ext4ExtShowExtentFtraceEvent;
class Ext4FallocateEnterFtraceEvent;
class Ext4FallocateExitFtraceEvent;
class Ext4FindDelallocRangeFtraceEvent;
class Ext4ForgetFtraceEvent;
class Ext4FreeBlocksFtraceEvent;
class Ext4FreeInodeFtraceEvent;
class Ext4GetImpliedClusterAllocExitFtraceEvent;
class Ext4GetReservedClusterAllocFtraceEvent;
class Ext4IndMapBlocksEnterFtraceEvent;
class Ext4IndMapBlocksExitFtraceEvent;
class Ext4InsertRangeFtraceEvent;
class Ext4InvalidatepageFtraceEvent;
class Ext4JournalStartFtraceEvent;
class Ext4JournalStartReservedFtraceEvent;
class Ext4JournalledInvalidatepageFtraceEvent;
class Ext4JournalledWriteEndFtraceEvent;
class Ext4LoadInodeBitmapFtraceEvent;
class Ext4LoadInodeFtraceEvent;
class Ext4MarkInodeDirtyFtraceEvent;
class Ext4MbBitmapLoadFtraceEvent;
class Ext4MbBuddyBitmapLoadFtraceEvent;
class Ext4MbDiscardPreallocationsFtraceEvent;
class Ext4MbNewGroupPaFtraceEvent;
class Ext4MbNewInodePaFtraceEvent;
class Ext4MbReleaseGroupPaFtraceEvent;
class Ext4MbReleaseInodePaFtraceEvent;
class Ext4MballocAllocFtraceEvent;
class Ext4MballocDiscardFtraceEvent;
class Ext4MballocFreeFtraceEvent;
class Ext4MballocPreallocFtraceEvent;
class Ext4OtherInodeUpdateTimeFtraceEvent;
class Ext4PunchHoleFtraceEvent;
class Ext4ReadBlockBitmapLoadFtraceEvent;
class Ext4ReadpageFtraceEvent;
class Ext4ReleasepageFtraceEvent;
class Ext4RemoveBlocksFtraceEvent;
class Ext4RequestBlocksFtraceEvent;
class Ext4RequestInodeFtraceEvent;
class Ext4SyncFileEnterFtraceEvent;
class Ext4SyncFileExitFtraceEvent;
class Ext4SyncFsFtraceEvent;
class Ext4TrimAllFreeFtraceEvent;
class Ext4TrimExtentFtraceEvent;
class Ext4TruncateEnterFtraceEvent;
class Ext4TruncateExitFtraceEvent;
class Ext4UnlinkEnterFtraceEvent;
class Ext4UnlinkExitFtraceEvent;
class Ext4WriteBeginFtraceEvent;
class Ext4WriteEndFtraceEvent;
class Ext4WritepageFtraceEvent;
class Ext4WritepagesFtraceEvent;
class Ext4WritepagesResultFtraceEvent;
class Ext4ZeroRangeFtraceEvent;
class F2fsDoSubmitBioFtraceEvent;
class F2fsEvictInodeFtraceEvent;
class F2fsFallocateFtraceEvent;
class F2fsGetDataBlockFtraceEvent;
class F2fsGetVictimFtraceEvent;
class F2fsIgetExitFtraceEvent;
class F2fsIgetFtraceEvent;
class F2fsNewInodeFtraceEvent;
class F2fsReadpageFtraceEvent;
class F2fsReserveNewBlockFtraceEvent;
class F2fsSetPageDirtyFtraceEvent;
class F2fsSubmitWritePageFtraceEvent;
class F2fsSyncFileEnterFtraceEvent;
class F2fsSyncFileExitFtraceEvent;
class F2fsSyncFsFtraceEvent;
class F2fsTruncateBlocksEnterFtraceEvent;
class F2fsTruncateBlocksExitFtraceEvent;
class F2fsTruncateDataBlocksRangeFtraceEvent;
class F2fsTruncateFtraceEvent;
class F2fsTruncateInodeBlocksEnterFtraceEvent;
class F2fsTruncateInodeBlocksExitFtraceEvent;
class F2fsTruncateNodeFtraceEvent;
class F2fsTruncateNodesEnterFtraceEvent;
class F2fsTruncateNodesExitFtraceEvent;
class F2fsTruncatePartialNodesFtraceEvent;
class F2fsUnlinkEnterFtraceEvent;
class F2fsUnlinkExitFtraceEvent;
class F2fsVmPageMkwriteFtraceEvent;
class F2fsWriteBeginFtraceEvent;
class F2fsWriteCheckpointFtraceEvent;
class F2fsWriteEndFtraceEvent;
class FastrpcDmaStatFtraceEvent;
class FenceDestroyFtraceEvent;
class FenceEnableSignalFtraceEvent;
class FenceInitFtraceEvent;
class FenceSignaledFtraceEvent;
class G2dTracingMarkWriteFtraceEvent;
class GenericFtraceEvent;
class GpuFrequencyFtraceEvent;
class GpuMemTotalFtraceEvent;
class I2cReadFtraceEvent;
class I2cReplyFtraceEvent;
class I2cResultFtraceEvent;
class I2cWriteFtraceEvent;
class InetSockSetStateFtraceEvent;
class IommuMapRangeFtraceEvent;
class IommuSecPtblMapRangeEndFtraceEvent;
class IommuSecPtblMapRangeStartFtraceEvent;
class IonAllocBufferEndFtraceEvent;
class IonAllocBufferFailFtraceEvent;
class IonAllocBufferFallbackFtraceEvent;
class IonAllocBufferStartFtraceEvent;
class IonBufferCreateFtraceEvent;
class IonBufferDestroyFtraceEvent;
class IonCpAllocRetryFtraceEvent;
class IonCpSecureBufferEndFtraceEvent;
class IonCpSecureBufferStartFtraceEvent;
class IonHeapGrowFtraceEvent;
class IonHeapShrinkFtraceEvent;
class IonPrefetchingFtraceEvent;
class IonSecureCmaAddToPoolEndFtraceEvent;
class IonSecureCmaAddToPoolStartFtraceEvent;
class IonSecureCmaAllocateEndFtraceEvent;
class IonSecureCmaAllocateStartFtraceEvent;
class IonSecureCmaShrinkPoolEndFtraceEvent;
class IonSecureCmaShrinkPoolStartFtraceEvent;
class IonStatFtraceEvent;
class IpiEntryFtraceEvent;
class IpiExitFtraceEvent;
class IpiRaiseFtraceEvent;
class IrqHandlerEntryFtraceEvent;
class IrqHandlerExitFtraceEvent;
class KfreeFtraceEvent;
class KfreeSkbFtraceEvent;
class KmallocFtraceEvent;
class KmallocNodeFtraceEvent;
class KmemCacheAllocFtraceEvent;
class KmemCacheAllocNodeFtraceEvent;
class KmemCacheFreeFtraceEvent;
class KvmAccessFaultFtraceEvent;
class KvmAckIrqFtraceEvent;
class KvmAgeHvaFtraceEvent;
class KvmAgePageFtraceEvent;
class KvmArmClearDebugFtraceEvent;
class KvmArmSetDreg32FtraceEvent;
class KvmArmSetRegsetFtraceEvent;
class KvmArmSetupDebugFtraceEvent;
class KvmEntryFtraceEvent;
class KvmExitFtraceEvent;
class KvmFpuFtraceEvent;
class KvmGetTimerMapFtraceEvent;
class KvmGuestFaultFtraceEvent;
class KvmHandleSysRegFtraceEvent;
class KvmHvcArm64FtraceEvent;
class KvmIrqLineFtraceEvent;
class KvmMmioEmulateFtraceEvent;
class KvmMmioFtraceEvent;
class KvmSetGuestDebugFtraceEvent;
class KvmSetIrqFtraceEvent;
class KvmSetSpteHvaFtraceEvent;
class KvmSetWayFlushFtraceEvent;
class KvmSysAccessFtraceEvent;
class KvmTestAgeHvaFtraceEvent;
class KvmTimerEmulateFtraceEvent;
class KvmTimerHrtimerExpireFtraceEvent;
class KvmTimerRestoreStateFtraceEvent;
class KvmTimerSaveStateFtraceEvent;
class KvmTimerUpdateIrqFtraceEvent;
class KvmToggleCacheFtraceEvent;
class KvmUnmapHvaRangeFtraceEvent;
class KvmUserspaceExitFtraceEvent;
class KvmVcpuWakeupFtraceEvent;
class KvmWfxArm64FtraceEvent;
class LowmemoryKillFtraceEvent;
class MaliTracingMarkWriteFtraceEvent;
class MarkVictimFtraceEvent;
class MdpCmdKickoffFtraceEvent;
class MdpCmdPingpongDoneFtraceEvent;
class MdpCmdReadptrDoneFtraceEvent;
class MdpCmdReleaseBwFtraceEvent;
class MdpCmdWaitPingpongFtraceEvent;
class MdpCommitFtraceEvent;
class MdpCompareBwFtraceEvent;
class MdpMisrCrcFtraceEvent;
class MdpMixerUpdateFtraceEvent;
class MdpPerfPrefillCalcFtraceEvent;
class MdpPerfSetOtFtraceEvent;
class MdpPerfSetPanicLutsFtraceEvent;
class MdpPerfSetQosLutsFtraceEvent;
class MdpPerfSetWmLevelsFtraceEvent;
class MdpPerfUpdateBusFtraceEvent;
class MdpSsppChangeFtraceEvent;
class MdpSsppSetFtraceEvent;
class MdpTraceCounterFtraceEvent;
class MdpVideoUnderrunDoneFtraceEvent;
class MigratePagesEndFtraceEvent;
class MigratePagesStartFtraceEvent;
class MigrateRetryFtraceEvent;
class MmCompactionBeginFtraceEvent;
class MmCompactionDeferCompactionFtraceEvent;
class MmCompactionDeferResetFtraceEvent;
class MmCompactionDeferredFtraceEvent;
class MmCompactionEndFtraceEvent;
class MmCompactionFinishedFtraceEvent;
class MmCompactionIsolateFreepagesFtraceEvent;
class MmCompactionIsolateMigratepagesFtraceEvent;
class MmCompactionKcompactdSleepFtraceEvent;
class MmCompactionKcompactdWakeFtraceEvent;
class MmCompactionMigratepagesFtraceEvent;
class MmCompactionSuitableFtraceEvent;
class MmCompactionTryToCompactPagesFtraceEvent;
class MmCompactionWakeupKcompactdFtraceEvent;
class MmEventRecordFtraceEvent;
class MmFilemapAddToPageCacheFtraceEvent;
class MmFilemapDeleteFromPageCacheFtraceEvent;
class MmPageAllocExtfragFtraceEvent;
class MmPageAllocFtraceEvent;
class MmPageAllocZoneLockedFtraceEvent;
class MmPageFreeBatchedFtraceEvent;
class MmPageFreeFtraceEvent;
class MmPagePcpuDrainFtraceEvent;
class MmVmscanDirectReclaimBeginFtraceEvent;
class MmVmscanDirectReclaimEndFtraceEvent;
class MmVmscanKswapdSleepFtraceEvent;
class MmVmscanKswapdWakeFtraceEvent;
class NapiGroReceiveEntryFtraceEvent;
class NapiGroReceiveExitFtraceEvent;
class NetDevXmitFtraceEvent;
class NetifReceiveSkbFtraceEvent;
class OomScoreAdjUpdateFtraceEvent;
class PrintFtraceEvent;
class RegulatorDisableCompleteFtraceEvent;
class RegulatorDisableFtraceEvent;
class RegulatorEnableCompleteFtraceEvent;
class RegulatorEnableDelayFtraceEvent;
class RegulatorEnableFtraceEvent;
class RegulatorSetVoltageCompleteFtraceEvent;
class RegulatorSetVoltageFtraceEvent;
class RotatorBwAoAsContextFtraceEvent;
class RssStatFtraceEvent;
class RssStatThrottledFtraceEvent;
class SchedBlockedReasonFtraceEvent;
class SchedCpuHotplugFtraceEvent;
class SchedPiSetprioFtraceEvent;
class SchedProcessExecFtraceEvent;
class SchedProcessExitFtraceEvent;
class SchedProcessForkFtraceEvent;
class SchedProcessFreeFtraceEvent;
class SchedProcessHangFtraceEvent;
class SchedProcessWaitFtraceEvent;
class SchedSwitchFtraceEvent;
class SchedWakeupFtraceEvent;
class SchedWakeupNewFtraceEvent;
class SchedWakingFtraceEvent;
class ScmCallEndFtraceEvent;
class ScmCallStartFtraceEvent;
class SdeSdeEvtlogFtraceEvent;
class SdeSdePerfCalcCrtcFtraceEvent;
class SdeSdePerfCrtcUpdateFtraceEvent;
class SdeSdePerfSetQosLutsFtraceEvent;
class SdeSdePerfUpdateBusFtraceEvent;
class SdeTracingMarkWriteFtraceEvent;
class SignalDeliverFtraceEvent;
class SignalGenerateFtraceEvent;
class SmbusReadFtraceEvent;
class SmbusReplyFtraceEvent;
class SmbusResultFtraceEvent;
class SmbusWriteFtraceEvent;
class SoftirqEntryFtraceEvent;
class SoftirqExitFtraceEvent;
class SoftirqRaiseFtraceEvent;
class SuspendResumeFtraceEvent;
class SyncPtFtraceEvent;
class SyncTimelineFtraceEvent;
class SyncWaitFtraceEvent;
class SysEnterFtraceEvent;
class SysExitFtraceEvent;
class TaskNewtaskFtraceEvent;
class TaskRenameFtraceEvent;
class TcpRetransmitSkbFtraceEvent;
class ThermalTemperatureFtraceEvent;
class TracingMarkWriteFtraceEvent;
class TrapRegFtraceEvent;
class UfshcdClkGatingFtraceEvent;
class UfshcdCommandFtraceEvent;
class VgicUpdateIrqPendingFtraceEvent;
class WakeupSourceActivateFtraceEvent;
class WakeupSourceDeactivateFtraceEvent;
class WorkqueueActivateWorkFtraceEvent;
class WorkqueueExecuteEndFtraceEvent;
class WorkqueueExecuteStartFtraceEvent;
class WorkqueueQueueWorkFtraceEvent;
class ZeroFtraceEvent;

class FtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/418, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  FtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_timestamp() const { return at<1>().valid(); }
  uint64_t timestamp() const { return at<1>().as_uint64(); }
  bool has_pid() const { return at<2>().valid(); }
  uint32_t pid() const { return at<2>().as_uint32(); }
  bool has_print() const { return at<3>().valid(); }
  ::protozero::ConstBytes print() const { return at<3>().as_bytes(); }
  bool has_sched_switch() const { return at<4>().valid(); }
  ::protozero::ConstBytes sched_switch() const { return at<4>().as_bytes(); }
  bool has_cpu_frequency() const { return at<11>().valid(); }
  ::protozero::ConstBytes cpu_frequency() const { return at<11>().as_bytes(); }
  bool has_cpu_frequency_limits() const { return at<12>().valid(); }
  ::protozero::ConstBytes cpu_frequency_limits() const { return at<12>().as_bytes(); }
  bool has_cpu_idle() const { return at<13>().valid(); }
  ::protozero::ConstBytes cpu_idle() const { return at<13>().as_bytes(); }
  bool has_clock_enable() const { return at<14>().valid(); }
  ::protozero::ConstBytes clock_enable() const { return at<14>().as_bytes(); }
  bool has_clock_disable() const { return at<15>().valid(); }
  ::protozero::ConstBytes clock_disable() const { return at<15>().as_bytes(); }
  bool has_clock_set_rate() const { return at<16>().valid(); }
  ::protozero::ConstBytes clock_set_rate() const { return at<16>().as_bytes(); }
  bool has_sched_wakeup() const { return at<17>().valid(); }
  ::protozero::ConstBytes sched_wakeup() const { return at<17>().as_bytes(); }
  bool has_sched_blocked_reason() const { return at<18>().valid(); }
  ::protozero::ConstBytes sched_blocked_reason() const { return at<18>().as_bytes(); }
  bool has_sched_cpu_hotplug() const { return at<19>().valid(); }
  ::protozero::ConstBytes sched_cpu_hotplug() const { return at<19>().as_bytes(); }
  bool has_sched_waking() const { return at<20>().valid(); }
  ::protozero::ConstBytes sched_waking() const { return at<20>().as_bytes(); }
  bool has_ipi_entry() const { return at<21>().valid(); }
  ::protozero::ConstBytes ipi_entry() const { return at<21>().as_bytes(); }
  bool has_ipi_exit() const { return at<22>().valid(); }
  ::protozero::ConstBytes ipi_exit() const { return at<22>().as_bytes(); }
  bool has_ipi_raise() const { return at<23>().valid(); }
  ::protozero::ConstBytes ipi_raise() const { return at<23>().as_bytes(); }
  bool has_softirq_entry() const { return at<24>().valid(); }
  ::protozero::ConstBytes softirq_entry() const { return at<24>().as_bytes(); }
  bool has_softirq_exit() const { return at<25>().valid(); }
  ::protozero::ConstBytes softirq_exit() const { return at<25>().as_bytes(); }
  bool has_softirq_raise() const { return at<26>().valid(); }
  ::protozero::ConstBytes softirq_raise() const { return at<26>().as_bytes(); }
  bool has_i2c_read() const { return at<27>().valid(); }
  ::protozero::ConstBytes i2c_read() const { return at<27>().as_bytes(); }
  bool has_i2c_write() const { return at<28>().valid(); }
  ::protozero::ConstBytes i2c_write() const { return at<28>().as_bytes(); }
  bool has_i2c_result() const { return at<29>().valid(); }
  ::protozero::ConstBytes i2c_result() const { return at<29>().as_bytes(); }
  bool has_i2c_reply() const { return at<30>().valid(); }
  ::protozero::ConstBytes i2c_reply() const { return at<30>().as_bytes(); }
  bool has_smbus_read() const { return at<31>().valid(); }
  ::protozero::ConstBytes smbus_read() const { return at<31>().as_bytes(); }
  bool has_smbus_write() const { return at<32>().valid(); }
  ::protozero::ConstBytes smbus_write() const { return at<32>().as_bytes(); }
  bool has_smbus_result() const { return at<33>().valid(); }
  ::protozero::ConstBytes smbus_result() const { return at<33>().as_bytes(); }
  bool has_smbus_reply() const { return at<34>().valid(); }
  ::protozero::ConstBytes smbus_reply() const { return at<34>().as_bytes(); }
  bool has_lowmemory_kill() const { return at<35>().valid(); }
  ::protozero::ConstBytes lowmemory_kill() const { return at<35>().as_bytes(); }
  bool has_irq_handler_entry() const { return at<36>().valid(); }
  ::protozero::ConstBytes irq_handler_entry() const { return at<36>().as_bytes(); }
  bool has_irq_handler_exit() const { return at<37>().valid(); }
  ::protozero::ConstBytes irq_handler_exit() const { return at<37>().as_bytes(); }
  bool has_sync_pt() const { return at<38>().valid(); }
  ::protozero::ConstBytes sync_pt() const { return at<38>().as_bytes(); }
  bool has_sync_timeline() const { return at<39>().valid(); }
  ::protozero::ConstBytes sync_timeline() const { return at<39>().as_bytes(); }
  bool has_sync_wait() const { return at<40>().valid(); }
  ::protozero::ConstBytes sync_wait() const { return at<40>().as_bytes(); }
  bool has_ext4_da_write_begin() const { return at<41>().valid(); }
  ::protozero::ConstBytes ext4_da_write_begin() const { return at<41>().as_bytes(); }
  bool has_ext4_da_write_end() const { return at<42>().valid(); }
  ::protozero::ConstBytes ext4_da_write_end() const { return at<42>().as_bytes(); }
  bool has_ext4_sync_file_enter() const { return at<43>().valid(); }
  ::protozero::ConstBytes ext4_sync_file_enter() const { return at<43>().as_bytes(); }
  bool has_ext4_sync_file_exit() const { return at<44>().valid(); }
  ::protozero::ConstBytes ext4_sync_file_exit() const { return at<44>().as_bytes(); }
  bool has_block_rq_issue() const { return at<45>().valid(); }
  ::protozero::ConstBytes block_rq_issue() const { return at<45>().as_bytes(); }
  bool has_mm_vmscan_direct_reclaim_begin() const { return at<46>().valid(); }
  ::protozero::ConstBytes mm_vmscan_direct_reclaim_begin() const { return at<46>().as_bytes(); }
  bool has_mm_vmscan_direct_reclaim_end() const { return at<47>().valid(); }
  ::protozero::ConstBytes mm_vmscan_direct_reclaim_end() const { return at<47>().as_bytes(); }
  bool has_mm_vmscan_kswapd_wake() const { return at<48>().valid(); }
  ::protozero::ConstBytes mm_vmscan_kswapd_wake() const { return at<48>().as_bytes(); }
  bool has_mm_vmscan_kswapd_sleep() const { return at<49>().valid(); }
  ::protozero::ConstBytes mm_vmscan_kswapd_sleep() const { return at<49>().as_bytes(); }
  bool has_binder_transaction() const { return at<50>().valid(); }
  ::protozero::ConstBytes binder_transaction() const { return at<50>().as_bytes(); }
  bool has_binder_transaction_received() const { return at<51>().valid(); }
  ::protozero::ConstBytes binder_transaction_received() const { return at<51>().as_bytes(); }
  bool has_binder_set_priority() const { return at<52>().valid(); }
  ::protozero::ConstBytes binder_set_priority() const { return at<52>().as_bytes(); }
  bool has_binder_lock() const { return at<53>().valid(); }
  ::protozero::ConstBytes binder_lock() const { return at<53>().as_bytes(); }
  bool has_binder_locked() const { return at<54>().valid(); }
  ::protozero::ConstBytes binder_locked() const { return at<54>().as_bytes(); }
  bool has_binder_unlock() const { return at<55>().valid(); }
  ::protozero::ConstBytes binder_unlock() const { return at<55>().as_bytes(); }
  bool has_workqueue_activate_work() const { return at<56>().valid(); }
  ::protozero::ConstBytes workqueue_activate_work() const { return at<56>().as_bytes(); }
  bool has_workqueue_execute_end() const { return at<57>().valid(); }
  ::protozero::ConstBytes workqueue_execute_end() const { return at<57>().as_bytes(); }
  bool has_workqueue_execute_start() const { return at<58>().valid(); }
  ::protozero::ConstBytes workqueue_execute_start() const { return at<58>().as_bytes(); }
  bool has_workqueue_queue_work() const { return at<59>().valid(); }
  ::protozero::ConstBytes workqueue_queue_work() const { return at<59>().as_bytes(); }
  bool has_regulator_disable() const { return at<60>().valid(); }
  ::protozero::ConstBytes regulator_disable() const { return at<60>().as_bytes(); }
  bool has_regulator_disable_complete() const { return at<61>().valid(); }
  ::protozero::ConstBytes regulator_disable_complete() const { return at<61>().as_bytes(); }
  bool has_regulator_enable() const { return at<62>().valid(); }
  ::protozero::ConstBytes regulator_enable() const { return at<62>().as_bytes(); }
  bool has_regulator_enable_complete() const { return at<63>().valid(); }
  ::protozero::ConstBytes regulator_enable_complete() const { return at<63>().as_bytes(); }
  bool has_regulator_enable_delay() const { return at<64>().valid(); }
  ::protozero::ConstBytes regulator_enable_delay() const { return at<64>().as_bytes(); }
  bool has_regulator_set_voltage() const { return at<65>().valid(); }
  ::protozero::ConstBytes regulator_set_voltage() const { return at<65>().as_bytes(); }
  bool has_regulator_set_voltage_complete() const { return at<66>().valid(); }
  ::protozero::ConstBytes regulator_set_voltage_complete() const { return at<66>().as_bytes(); }
  bool has_cgroup_attach_task() const { return at<67>().valid(); }
  ::protozero::ConstBytes cgroup_attach_task() const { return at<67>().as_bytes(); }
  bool has_cgroup_mkdir() const { return at<68>().valid(); }
  ::protozero::ConstBytes cgroup_mkdir() const { return at<68>().as_bytes(); }
  bool has_cgroup_remount() const { return at<69>().valid(); }
  ::protozero::ConstBytes cgroup_remount() const { return at<69>().as_bytes(); }
  bool has_cgroup_rmdir() const { return at<70>().valid(); }
  ::protozero::ConstBytes cgroup_rmdir() const { return at<70>().as_bytes(); }
  bool has_cgroup_transfer_tasks() const { return at<71>().valid(); }
  ::protozero::ConstBytes cgroup_transfer_tasks() const { return at<71>().as_bytes(); }
  bool has_cgroup_destroy_root() const { return at<72>().valid(); }
  ::protozero::ConstBytes cgroup_destroy_root() const { return at<72>().as_bytes(); }
  bool has_cgroup_release() const { return at<73>().valid(); }
  ::protozero::ConstBytes cgroup_release() const { return at<73>().as_bytes(); }
  bool has_cgroup_rename() const { return at<74>().valid(); }
  ::protozero::ConstBytes cgroup_rename() const { return at<74>().as_bytes(); }
  bool has_cgroup_setup_root() const { return at<75>().valid(); }
  ::protozero::ConstBytes cgroup_setup_root() const { return at<75>().as_bytes(); }
  bool has_mdp_cmd_kickoff() const { return at<76>().valid(); }
  ::protozero::ConstBytes mdp_cmd_kickoff() const { return at<76>().as_bytes(); }
  bool has_mdp_commit() const { return at<77>().valid(); }
  ::protozero::ConstBytes mdp_commit() const { return at<77>().as_bytes(); }
  bool has_mdp_perf_set_ot() const { return at<78>().valid(); }
  ::protozero::ConstBytes mdp_perf_set_ot() const { return at<78>().as_bytes(); }
  bool has_mdp_sspp_change() const { return at<79>().valid(); }
  ::protozero::ConstBytes mdp_sspp_change() const { return at<79>().as_bytes(); }
  bool has_tracing_mark_write() const { return at<80>().valid(); }
  ::protozero::ConstBytes tracing_mark_write() const { return at<80>().as_bytes(); }
  bool has_mdp_cmd_pingpong_done() const { return at<81>().valid(); }
  ::protozero::ConstBytes mdp_cmd_pingpong_done() const { return at<81>().as_bytes(); }
  bool has_mdp_compare_bw() const { return at<82>().valid(); }
  ::protozero::ConstBytes mdp_compare_bw() const { return at<82>().as_bytes(); }
  bool has_mdp_perf_set_panic_luts() const { return at<83>().valid(); }
  ::protozero::ConstBytes mdp_perf_set_panic_luts() const { return at<83>().as_bytes(); }
  bool has_mdp_sspp_set() const { return at<84>().valid(); }
  ::protozero::ConstBytes mdp_sspp_set() const { return at<84>().as_bytes(); }
  bool has_mdp_cmd_readptr_done() const { return at<85>().valid(); }
  ::protozero::ConstBytes mdp_cmd_readptr_done() const { return at<85>().as_bytes(); }
  bool has_mdp_misr_crc() const { return at<86>().valid(); }
  ::protozero::ConstBytes mdp_misr_crc() const { return at<86>().as_bytes(); }
  bool has_mdp_perf_set_qos_luts() const { return at<87>().valid(); }
  ::protozero::ConstBytes mdp_perf_set_qos_luts() const { return at<87>().as_bytes(); }
  bool has_mdp_trace_counter() const { return at<88>().valid(); }
  ::protozero::ConstBytes mdp_trace_counter() const { return at<88>().as_bytes(); }
  bool has_mdp_cmd_release_bw() const { return at<89>().valid(); }
  ::protozero::ConstBytes mdp_cmd_release_bw() const { return at<89>().as_bytes(); }
  bool has_mdp_mixer_update() const { return at<90>().valid(); }
  ::protozero::ConstBytes mdp_mixer_update() const { return at<90>().as_bytes(); }
  bool has_mdp_perf_set_wm_levels() const { return at<91>().valid(); }
  ::protozero::ConstBytes mdp_perf_set_wm_levels() const { return at<91>().as_bytes(); }
  bool has_mdp_video_underrun_done() const { return at<92>().valid(); }
  ::protozero::ConstBytes mdp_video_underrun_done() const { return at<92>().as_bytes(); }
  bool has_mdp_cmd_wait_pingpong() const { return at<93>().valid(); }
  ::protozero::ConstBytes mdp_cmd_wait_pingpong() const { return at<93>().as_bytes(); }
  bool has_mdp_perf_prefill_calc() const { return at<94>().valid(); }
  ::protozero::ConstBytes mdp_perf_prefill_calc() const { return at<94>().as_bytes(); }
  bool has_mdp_perf_update_bus() const { return at<95>().valid(); }
  ::protozero::ConstBytes mdp_perf_update_bus() const { return at<95>().as_bytes(); }
  bool has_rotator_bw_ao_as_context() const { return at<96>().valid(); }
  ::protozero::ConstBytes rotator_bw_ao_as_context() const { return at<96>().as_bytes(); }
  bool has_mm_filemap_add_to_page_cache() const { return at<97>().valid(); }
  ::protozero::ConstBytes mm_filemap_add_to_page_cache() const { return at<97>().as_bytes(); }
  bool has_mm_filemap_delete_from_page_cache() const { return at<98>().valid(); }
  ::protozero::ConstBytes mm_filemap_delete_from_page_cache() const { return at<98>().as_bytes(); }
  bool has_mm_compaction_begin() const { return at<99>().valid(); }
  ::protozero::ConstBytes mm_compaction_begin() const { return at<99>().as_bytes(); }
  bool has_mm_compaction_defer_compaction() const { return at<100>().valid(); }
  ::protozero::ConstBytes mm_compaction_defer_compaction() const { return at<100>().as_bytes(); }
  bool has_mm_compaction_deferred() const { return at<101>().valid(); }
  ::protozero::ConstBytes mm_compaction_deferred() const { return at<101>().as_bytes(); }
  bool has_mm_compaction_defer_reset() const { return at<102>().valid(); }
  ::protozero::ConstBytes mm_compaction_defer_reset() const { return at<102>().as_bytes(); }
  bool has_mm_compaction_end() const { return at<103>().valid(); }
  ::protozero::ConstBytes mm_compaction_end() const { return at<103>().as_bytes(); }
  bool has_mm_compaction_finished() const { return at<104>().valid(); }
  ::protozero::ConstBytes mm_compaction_finished() const { return at<104>().as_bytes(); }
  bool has_mm_compaction_isolate_freepages() const { return at<105>().valid(); }
  ::protozero::ConstBytes mm_compaction_isolate_freepages() const { return at<105>().as_bytes(); }
  bool has_mm_compaction_isolate_migratepages() const { return at<106>().valid(); }
  ::protozero::ConstBytes mm_compaction_isolate_migratepages() const { return at<106>().as_bytes(); }
  bool has_mm_compaction_kcompactd_sleep() const { return at<107>().valid(); }
  ::protozero::ConstBytes mm_compaction_kcompactd_sleep() const { return at<107>().as_bytes(); }
  bool has_mm_compaction_kcompactd_wake() const { return at<108>().valid(); }
  ::protozero::ConstBytes mm_compaction_kcompactd_wake() const { return at<108>().as_bytes(); }
  bool has_mm_compaction_migratepages() const { return at<109>().valid(); }
  ::protozero::ConstBytes mm_compaction_migratepages() const { return at<109>().as_bytes(); }
  bool has_mm_compaction_suitable() const { return at<110>().valid(); }
  ::protozero::ConstBytes mm_compaction_suitable() const { return at<110>().as_bytes(); }
  bool has_mm_compaction_try_to_compact_pages() const { return at<111>().valid(); }
  ::protozero::ConstBytes mm_compaction_try_to_compact_pages() const { return at<111>().as_bytes(); }
  bool has_mm_compaction_wakeup_kcompactd() const { return at<112>().valid(); }
  ::protozero::ConstBytes mm_compaction_wakeup_kcompactd() const { return at<112>().as_bytes(); }
  bool has_suspend_resume() const { return at<113>().valid(); }
  ::protozero::ConstBytes suspend_resume() const { return at<113>().as_bytes(); }
  bool has_sched_wakeup_new() const { return at<114>().valid(); }
  ::protozero::ConstBytes sched_wakeup_new() const { return at<114>().as_bytes(); }
  bool has_block_bio_backmerge() const { return at<115>().valid(); }
  ::protozero::ConstBytes block_bio_backmerge() const { return at<115>().as_bytes(); }
  bool has_block_bio_bounce() const { return at<116>().valid(); }
  ::protozero::ConstBytes block_bio_bounce() const { return at<116>().as_bytes(); }
  bool has_block_bio_complete() const { return at<117>().valid(); }
  ::protozero::ConstBytes block_bio_complete() const { return at<117>().as_bytes(); }
  bool has_block_bio_frontmerge() const { return at<118>().valid(); }
  ::protozero::ConstBytes block_bio_frontmerge() const { return at<118>().as_bytes(); }
  bool has_block_bio_queue() const { return at<119>().valid(); }
  ::protozero::ConstBytes block_bio_queue() const { return at<119>().as_bytes(); }
  bool has_block_bio_remap() const { return at<120>().valid(); }
  ::protozero::ConstBytes block_bio_remap() const { return at<120>().as_bytes(); }
  bool has_block_dirty_buffer() const { return at<121>().valid(); }
  ::protozero::ConstBytes block_dirty_buffer() const { return at<121>().as_bytes(); }
  bool has_block_getrq() const { return at<122>().valid(); }
  ::protozero::ConstBytes block_getrq() const { return at<122>().as_bytes(); }
  bool has_block_plug() const { return at<123>().valid(); }
  ::protozero::ConstBytes block_plug() const { return at<123>().as_bytes(); }
  bool has_block_rq_abort() const { return at<124>().valid(); }
  ::protozero::ConstBytes block_rq_abort() const { return at<124>().as_bytes(); }
  bool has_block_rq_complete() const { return at<125>().valid(); }
  ::protozero::ConstBytes block_rq_complete() const { return at<125>().as_bytes(); }
  bool has_block_rq_insert() const { return at<126>().valid(); }
  ::protozero::ConstBytes block_rq_insert() const { return at<126>().as_bytes(); }
  bool has_block_rq_remap() const { return at<128>().valid(); }
  ::protozero::ConstBytes block_rq_remap() const { return at<128>().as_bytes(); }
  bool has_block_rq_requeue() const { return at<129>().valid(); }
  ::protozero::ConstBytes block_rq_requeue() const { return at<129>().as_bytes(); }
  bool has_block_sleeprq() const { return at<130>().valid(); }
  ::protozero::ConstBytes block_sleeprq() const { return at<130>().as_bytes(); }
  bool has_block_split() const { return at<131>().valid(); }
  ::protozero::ConstBytes block_split() const { return at<131>().as_bytes(); }
  bool has_block_touch_buffer() const { return at<132>().valid(); }
  ::protozero::ConstBytes block_touch_buffer() const { return at<132>().as_bytes(); }
  bool has_block_unplug() const { return at<133>().valid(); }
  ::protozero::ConstBytes block_unplug() const { return at<133>().as_bytes(); }
  bool has_ext4_alloc_da_blocks() const { return at<134>().valid(); }
  ::protozero::ConstBytes ext4_alloc_da_blocks() const { return at<134>().as_bytes(); }
  bool has_ext4_allocate_blocks() const { return at<135>().valid(); }
  ::protozero::ConstBytes ext4_allocate_blocks() const { return at<135>().as_bytes(); }
  bool has_ext4_allocate_inode() const { return at<136>().valid(); }
  ::protozero::ConstBytes ext4_allocate_inode() const { return at<136>().as_bytes(); }
  bool has_ext4_begin_ordered_truncate() const { return at<137>().valid(); }
  ::protozero::ConstBytes ext4_begin_ordered_truncate() const { return at<137>().as_bytes(); }
  bool has_ext4_collapse_range() const { return at<138>().valid(); }
  ::protozero::ConstBytes ext4_collapse_range() const { return at<138>().as_bytes(); }
  bool has_ext4_da_release_space() const { return at<139>().valid(); }
  ::protozero::ConstBytes ext4_da_release_space() const { return at<139>().as_bytes(); }
  bool has_ext4_da_reserve_space() const { return at<140>().valid(); }
  ::protozero::ConstBytes ext4_da_reserve_space() const { return at<140>().as_bytes(); }
  bool has_ext4_da_update_reserve_space() const { return at<141>().valid(); }
  ::protozero::ConstBytes ext4_da_update_reserve_space() const { return at<141>().as_bytes(); }
  bool has_ext4_da_write_pages() const { return at<142>().valid(); }
  ::protozero::ConstBytes ext4_da_write_pages() const { return at<142>().as_bytes(); }
  bool has_ext4_da_write_pages_extent() const { return at<143>().valid(); }
  ::protozero::ConstBytes ext4_da_write_pages_extent() const { return at<143>().as_bytes(); }
  bool has_ext4_direct_io_enter() const { return at<144>().valid(); }
  ::protozero::ConstBytes ext4_direct_io_enter() const { return at<144>().as_bytes(); }
  bool has_ext4_direct_io_exit() const { return at<145>().valid(); }
  ::protozero::ConstBytes ext4_direct_io_exit() const { return at<145>().as_bytes(); }
  bool has_ext4_discard_blocks() const { return at<146>().valid(); }
  ::protozero::ConstBytes ext4_discard_blocks() const { return at<146>().as_bytes(); }
  bool has_ext4_discard_preallocations() const { return at<147>().valid(); }
  ::protozero::ConstBytes ext4_discard_preallocations() const { return at<147>().as_bytes(); }
  bool has_ext4_drop_inode() const { return at<148>().valid(); }
  ::protozero::ConstBytes ext4_drop_inode() const { return at<148>().as_bytes(); }
  bool has_ext4_es_cache_extent() const { return at<149>().valid(); }
  ::protozero::ConstBytes ext4_es_cache_extent() const { return at<149>().as_bytes(); }
  bool has_ext4_es_find_delayed_extent_range_enter() const { return at<150>().valid(); }
  ::protozero::ConstBytes ext4_es_find_delayed_extent_range_enter() const { return at<150>().as_bytes(); }
  bool has_ext4_es_find_delayed_extent_range_exit() const { return at<151>().valid(); }
  ::protozero::ConstBytes ext4_es_find_delayed_extent_range_exit() const { return at<151>().as_bytes(); }
  bool has_ext4_es_insert_extent() const { return at<152>().valid(); }
  ::protozero::ConstBytes ext4_es_insert_extent() const { return at<152>().as_bytes(); }
  bool has_ext4_es_lookup_extent_enter() const { return at<153>().valid(); }
  ::protozero::ConstBytes ext4_es_lookup_extent_enter() const { return at<153>().as_bytes(); }
  bool has_ext4_es_lookup_extent_exit() const { return at<154>().valid(); }
  ::protozero::ConstBytes ext4_es_lookup_extent_exit() const { return at<154>().as_bytes(); }
  bool has_ext4_es_remove_extent() const { return at<155>().valid(); }
  ::protozero::ConstBytes ext4_es_remove_extent() const { return at<155>().as_bytes(); }
  bool has_ext4_es_shrink() const { return at<156>().valid(); }
  ::protozero::ConstBytes ext4_es_shrink() const { return at<156>().as_bytes(); }
  bool has_ext4_es_shrink_count() const { return at<157>().valid(); }
  ::protozero::ConstBytes ext4_es_shrink_count() const { return at<157>().as_bytes(); }
  bool has_ext4_es_shrink_scan_enter() const { return at<158>().valid(); }
  ::protozero::ConstBytes ext4_es_shrink_scan_enter() const { return at<158>().as_bytes(); }
  bool has_ext4_es_shrink_scan_exit() const { return at<159>().valid(); }
  ::protozero::ConstBytes ext4_es_shrink_scan_exit() const { return at<159>().as_bytes(); }
  bool has_ext4_evict_inode() const { return at<160>().valid(); }
  ::protozero::ConstBytes ext4_evict_inode() const { return at<160>().as_bytes(); }
  bool has_ext4_ext_convert_to_initialized_enter() const { return at<161>().valid(); }
  ::protozero::ConstBytes ext4_ext_convert_to_initialized_enter() const { return at<161>().as_bytes(); }
  bool has_ext4_ext_convert_to_initialized_fastpath() const { return at<162>().valid(); }
  ::protozero::ConstBytes ext4_ext_convert_to_initialized_fastpath() const { return at<162>().as_bytes(); }
  bool has_ext4_ext_handle_unwritten_extents() const { return at<163>().valid(); }
  ::protozero::ConstBytes ext4_ext_handle_unwritten_extents() const { return at<163>().as_bytes(); }
  bool has_ext4_ext_in_cache() const { return at<164>().valid(); }
  ::protozero::ConstBytes ext4_ext_in_cache() const { return at<164>().as_bytes(); }
  bool has_ext4_ext_load_extent() const { return at<165>().valid(); }
  ::protozero::ConstBytes ext4_ext_load_extent() const { return at<165>().as_bytes(); }
  bool has_ext4_ext_map_blocks_enter() const { return at<166>().valid(); }
  ::protozero::ConstBytes ext4_ext_map_blocks_enter() const { return at<166>().as_bytes(); }
  bool has_ext4_ext_map_blocks_exit() const { return at<167>().valid(); }
  ::protozero::ConstBytes ext4_ext_map_blocks_exit() const { return at<167>().as_bytes(); }
  bool has_ext4_ext_put_in_cache() const { return at<168>().valid(); }
  ::protozero::ConstBytes ext4_ext_put_in_cache() const { return at<168>().as_bytes(); }
  bool has_ext4_ext_remove_space() const { return at<169>().valid(); }
  ::protozero::ConstBytes ext4_ext_remove_space() const { return at<169>().as_bytes(); }
  bool has_ext4_ext_remove_space_done() const { return at<170>().valid(); }
  ::protozero::ConstBytes ext4_ext_remove_space_done() const { return at<170>().as_bytes(); }
  bool has_ext4_ext_rm_idx() const { return at<171>().valid(); }
  ::protozero::ConstBytes ext4_ext_rm_idx() const { return at<171>().as_bytes(); }
  bool has_ext4_ext_rm_leaf() const { return at<172>().valid(); }
  ::protozero::ConstBytes ext4_ext_rm_leaf() const { return at<172>().as_bytes(); }
  bool has_ext4_ext_show_extent() const { return at<173>().valid(); }
  ::protozero::ConstBytes ext4_ext_show_extent() const { return at<173>().as_bytes(); }
  bool has_ext4_fallocate_enter() const { return at<174>().valid(); }
  ::protozero::ConstBytes ext4_fallocate_enter() const { return at<174>().as_bytes(); }
  bool has_ext4_fallocate_exit() const { return at<175>().valid(); }
  ::protozero::ConstBytes ext4_fallocate_exit() const { return at<175>().as_bytes(); }
  bool has_ext4_find_delalloc_range() const { return at<176>().valid(); }
  ::protozero::ConstBytes ext4_find_delalloc_range() const { return at<176>().as_bytes(); }
  bool has_ext4_forget() const { return at<177>().valid(); }
  ::protozero::ConstBytes ext4_forget() const { return at<177>().as_bytes(); }
  bool has_ext4_free_blocks() const { return at<178>().valid(); }
  ::protozero::ConstBytes ext4_free_blocks() const { return at<178>().as_bytes(); }
  bool has_ext4_free_inode() const { return at<179>().valid(); }
  ::protozero::ConstBytes ext4_free_inode() const { return at<179>().as_bytes(); }
  bool has_ext4_get_implied_cluster_alloc_exit() const { return at<180>().valid(); }
  ::protozero::ConstBytes ext4_get_implied_cluster_alloc_exit() const { return at<180>().as_bytes(); }
  bool has_ext4_get_reserved_cluster_alloc() const { return at<181>().valid(); }
  ::protozero::ConstBytes ext4_get_reserved_cluster_alloc() const { return at<181>().as_bytes(); }
  bool has_ext4_ind_map_blocks_enter() const { return at<182>().valid(); }
  ::protozero::ConstBytes ext4_ind_map_blocks_enter() const { return at<182>().as_bytes(); }
  bool has_ext4_ind_map_blocks_exit() const { return at<183>().valid(); }
  ::protozero::ConstBytes ext4_ind_map_blocks_exit() const { return at<183>().as_bytes(); }
  bool has_ext4_insert_range() const { return at<184>().valid(); }
  ::protozero::ConstBytes ext4_insert_range() const { return at<184>().as_bytes(); }
  bool has_ext4_invalidatepage() const { return at<185>().valid(); }
  ::protozero::ConstBytes ext4_invalidatepage() const { return at<185>().as_bytes(); }
  bool has_ext4_journal_start() const { return at<186>().valid(); }
  ::protozero::ConstBytes ext4_journal_start() const { return at<186>().as_bytes(); }
  bool has_ext4_journal_start_reserved() const { return at<187>().valid(); }
  ::protozero::ConstBytes ext4_journal_start_reserved() const { return at<187>().as_bytes(); }
  bool has_ext4_journalled_invalidatepage() const { return at<188>().valid(); }
  ::protozero::ConstBytes ext4_journalled_invalidatepage() const { return at<188>().as_bytes(); }
  bool has_ext4_journalled_write_end() const { return at<189>().valid(); }
  ::protozero::ConstBytes ext4_journalled_write_end() const { return at<189>().as_bytes(); }
  bool has_ext4_load_inode() const { return at<190>().valid(); }
  ::protozero::ConstBytes ext4_load_inode() const { return at<190>().as_bytes(); }
  bool has_ext4_load_inode_bitmap() const { return at<191>().valid(); }
  ::protozero::ConstBytes ext4_load_inode_bitmap() const { return at<191>().as_bytes(); }
  bool has_ext4_mark_inode_dirty() const { return at<192>().valid(); }
  ::protozero::ConstBytes ext4_mark_inode_dirty() const { return at<192>().as_bytes(); }
  bool has_ext4_mb_bitmap_load() const { return at<193>().valid(); }
  ::protozero::ConstBytes ext4_mb_bitmap_load() const { return at<193>().as_bytes(); }
  bool has_ext4_mb_buddy_bitmap_load() const { return at<194>().valid(); }
  ::protozero::ConstBytes ext4_mb_buddy_bitmap_load() const { return at<194>().as_bytes(); }
  bool has_ext4_mb_discard_preallocations() const { return at<195>().valid(); }
  ::protozero::ConstBytes ext4_mb_discard_preallocations() const { return at<195>().as_bytes(); }
  bool has_ext4_mb_new_group_pa() const { return at<196>().valid(); }
  ::protozero::ConstBytes ext4_mb_new_group_pa() const { return at<196>().as_bytes(); }
  bool has_ext4_mb_new_inode_pa() const { return at<197>().valid(); }
  ::protozero::ConstBytes ext4_mb_new_inode_pa() const { return at<197>().as_bytes(); }
  bool has_ext4_mb_release_group_pa() const { return at<198>().valid(); }
  ::protozero::ConstBytes ext4_mb_release_group_pa() const { return at<198>().as_bytes(); }
  bool has_ext4_mb_release_inode_pa() const { return at<199>().valid(); }
  ::protozero::ConstBytes ext4_mb_release_inode_pa() const { return at<199>().as_bytes(); }
  bool has_ext4_mballoc_alloc() const { return at<200>().valid(); }
  ::protozero::ConstBytes ext4_mballoc_alloc() const { return at<200>().as_bytes(); }
  bool has_ext4_mballoc_discard() const { return at<201>().valid(); }
  ::protozero::ConstBytes ext4_mballoc_discard() const { return at<201>().as_bytes(); }
  bool has_ext4_mballoc_free() const { return at<202>().valid(); }
  ::protozero::ConstBytes ext4_mballoc_free() const { return at<202>().as_bytes(); }
  bool has_ext4_mballoc_prealloc() const { return at<203>().valid(); }
  ::protozero::ConstBytes ext4_mballoc_prealloc() const { return at<203>().as_bytes(); }
  bool has_ext4_other_inode_update_time() const { return at<204>().valid(); }
  ::protozero::ConstBytes ext4_other_inode_update_time() const { return at<204>().as_bytes(); }
  bool has_ext4_punch_hole() const { return at<205>().valid(); }
  ::protozero::ConstBytes ext4_punch_hole() const { return at<205>().as_bytes(); }
  bool has_ext4_read_block_bitmap_load() const { return at<206>().valid(); }
  ::protozero::ConstBytes ext4_read_block_bitmap_load() const { return at<206>().as_bytes(); }
  bool has_ext4_readpage() const { return at<207>().valid(); }
  ::protozero::ConstBytes ext4_readpage() const { return at<207>().as_bytes(); }
  bool has_ext4_releasepage() const { return at<208>().valid(); }
  ::protozero::ConstBytes ext4_releasepage() const { return at<208>().as_bytes(); }
  bool has_ext4_remove_blocks() const { return at<209>().valid(); }
  ::protozero::ConstBytes ext4_remove_blocks() const { return at<209>().as_bytes(); }
  bool has_ext4_request_blocks() const { return at<210>().valid(); }
  ::protozero::ConstBytes ext4_request_blocks() const { return at<210>().as_bytes(); }
  bool has_ext4_request_inode() const { return at<211>().valid(); }
  ::protozero::ConstBytes ext4_request_inode() const { return at<211>().as_bytes(); }
  bool has_ext4_sync_fs() const { return at<212>().valid(); }
  ::protozero::ConstBytes ext4_sync_fs() const { return at<212>().as_bytes(); }
  bool has_ext4_trim_all_free() const { return at<213>().valid(); }
  ::protozero::ConstBytes ext4_trim_all_free() const { return at<213>().as_bytes(); }
  bool has_ext4_trim_extent() const { return at<214>().valid(); }
  ::protozero::ConstBytes ext4_trim_extent() const { return at<214>().as_bytes(); }
  bool has_ext4_truncate_enter() const { return at<215>().valid(); }
  ::protozero::ConstBytes ext4_truncate_enter() const { return at<215>().as_bytes(); }
  bool has_ext4_truncate_exit() const { return at<216>().valid(); }
  ::protozero::ConstBytes ext4_truncate_exit() const { return at<216>().as_bytes(); }
  bool has_ext4_unlink_enter() const { return at<217>().valid(); }
  ::protozero::ConstBytes ext4_unlink_enter() const { return at<217>().as_bytes(); }
  bool has_ext4_unlink_exit() const { return at<218>().valid(); }
  ::protozero::ConstBytes ext4_unlink_exit() const { return at<218>().as_bytes(); }
  bool has_ext4_write_begin() const { return at<219>().valid(); }
  ::protozero::ConstBytes ext4_write_begin() const { return at<219>().as_bytes(); }
  bool has_ext4_write_end() const { return at<230>().valid(); }
  ::protozero::ConstBytes ext4_write_end() const { return at<230>().as_bytes(); }
  bool has_ext4_writepage() const { return at<231>().valid(); }
  ::protozero::ConstBytes ext4_writepage() const { return at<231>().as_bytes(); }
  bool has_ext4_writepages() const { return at<232>().valid(); }
  ::protozero::ConstBytes ext4_writepages() const { return at<232>().as_bytes(); }
  bool has_ext4_writepages_result() const { return at<233>().valid(); }
  ::protozero::ConstBytes ext4_writepages_result() const { return at<233>().as_bytes(); }
  bool has_ext4_zero_range() const { return at<234>().valid(); }
  ::protozero::ConstBytes ext4_zero_range() const { return at<234>().as_bytes(); }
  bool has_task_newtask() const { return at<235>().valid(); }
  ::protozero::ConstBytes task_newtask() const { return at<235>().as_bytes(); }
  bool has_task_rename() const { return at<236>().valid(); }
  ::protozero::ConstBytes task_rename() const { return at<236>().as_bytes(); }
  bool has_sched_process_exec() const { return at<237>().valid(); }
  ::protozero::ConstBytes sched_process_exec() const { return at<237>().as_bytes(); }
  bool has_sched_process_exit() const { return at<238>().valid(); }
  ::protozero::ConstBytes sched_process_exit() const { return at<238>().as_bytes(); }
  bool has_sched_process_fork() const { return at<239>().valid(); }
  ::protozero::ConstBytes sched_process_fork() const { return at<239>().as_bytes(); }
  bool has_sched_process_free() const { return at<240>().valid(); }
  ::protozero::ConstBytes sched_process_free() const { return at<240>().as_bytes(); }
  bool has_sched_process_hang() const { return at<241>().valid(); }
  ::protozero::ConstBytes sched_process_hang() const { return at<241>().as_bytes(); }
  bool has_sched_process_wait() const { return at<242>().valid(); }
  ::protozero::ConstBytes sched_process_wait() const { return at<242>().as_bytes(); }
  bool has_f2fs_do_submit_bio() const { return at<243>().valid(); }
  ::protozero::ConstBytes f2fs_do_submit_bio() const { return at<243>().as_bytes(); }
  bool has_f2fs_evict_inode() const { return at<244>().valid(); }
  ::protozero::ConstBytes f2fs_evict_inode() const { return at<244>().as_bytes(); }
  bool has_f2fs_fallocate() const { return at<245>().valid(); }
  ::protozero::ConstBytes f2fs_fallocate() const { return at<245>().as_bytes(); }
  bool has_f2fs_get_data_block() const { return at<246>().valid(); }
  ::protozero::ConstBytes f2fs_get_data_block() const { return at<246>().as_bytes(); }
  bool has_f2fs_get_victim() const { return at<247>().valid(); }
  ::protozero::ConstBytes f2fs_get_victim() const { return at<247>().as_bytes(); }
  bool has_f2fs_iget() const { return at<248>().valid(); }
  ::protozero::ConstBytes f2fs_iget() const { return at<248>().as_bytes(); }
  bool has_f2fs_iget_exit() const { return at<249>().valid(); }
  ::protozero::ConstBytes f2fs_iget_exit() const { return at<249>().as_bytes(); }
  bool has_f2fs_new_inode() const { return at<250>().valid(); }
  ::protozero::ConstBytes f2fs_new_inode() const { return at<250>().as_bytes(); }
  bool has_f2fs_readpage() const { return at<251>().valid(); }
  ::protozero::ConstBytes f2fs_readpage() const { return at<251>().as_bytes(); }
  bool has_f2fs_reserve_new_block() const { return at<252>().valid(); }
  ::protozero::ConstBytes f2fs_reserve_new_block() const { return at<252>().as_bytes(); }
  bool has_f2fs_set_page_dirty() const { return at<253>().valid(); }
  ::protozero::ConstBytes f2fs_set_page_dirty() const { return at<253>().as_bytes(); }
  bool has_f2fs_submit_write_page() const { return at<254>().valid(); }
  ::protozero::ConstBytes f2fs_submit_write_page() const { return at<254>().as_bytes(); }
  bool has_f2fs_sync_file_enter() const { return at<255>().valid(); }
  ::protozero::ConstBytes f2fs_sync_file_enter() const { return at<255>().as_bytes(); }
  bool has_f2fs_sync_file_exit() const { return at<256>().valid(); }
  ::protozero::ConstBytes f2fs_sync_file_exit() const { return at<256>().as_bytes(); }
  bool has_f2fs_sync_fs() const { return at<257>().valid(); }
  ::protozero::ConstBytes f2fs_sync_fs() const { return at<257>().as_bytes(); }
  bool has_f2fs_truncate() const { return at<258>().valid(); }
  ::protozero::ConstBytes f2fs_truncate() const { return at<258>().as_bytes(); }
  bool has_f2fs_truncate_blocks_enter() const { return at<259>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_blocks_enter() const { return at<259>().as_bytes(); }
  bool has_f2fs_truncate_blocks_exit() const { return at<260>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_blocks_exit() const { return at<260>().as_bytes(); }
  bool has_f2fs_truncate_data_blocks_range() const { return at<261>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_data_blocks_range() const { return at<261>().as_bytes(); }
  bool has_f2fs_truncate_inode_blocks_enter() const { return at<262>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_inode_blocks_enter() const { return at<262>().as_bytes(); }
  bool has_f2fs_truncate_inode_blocks_exit() const { return at<263>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_inode_blocks_exit() const { return at<263>().as_bytes(); }
  bool has_f2fs_truncate_node() const { return at<264>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_node() const { return at<264>().as_bytes(); }
  bool has_f2fs_truncate_nodes_enter() const { return at<265>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_nodes_enter() const { return at<265>().as_bytes(); }
  bool has_f2fs_truncate_nodes_exit() const { return at<266>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_nodes_exit() const { return at<266>().as_bytes(); }
  bool has_f2fs_truncate_partial_nodes() const { return at<267>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_partial_nodes() const { return at<267>().as_bytes(); }
  bool has_f2fs_unlink_enter() const { return at<268>().valid(); }
  ::protozero::ConstBytes f2fs_unlink_enter() const { return at<268>().as_bytes(); }
  bool has_f2fs_unlink_exit() const { return at<269>().valid(); }
  ::protozero::ConstBytes f2fs_unlink_exit() const { return at<269>().as_bytes(); }
  bool has_f2fs_vm_page_mkwrite() const { return at<270>().valid(); }
  ::protozero::ConstBytes f2fs_vm_page_mkwrite() const { return at<270>().as_bytes(); }
  bool has_f2fs_write_begin() const { return at<271>().valid(); }
  ::protozero::ConstBytes f2fs_write_begin() const { return at<271>().as_bytes(); }
  bool has_f2fs_write_checkpoint() const { return at<272>().valid(); }
  ::protozero::ConstBytes f2fs_write_checkpoint() const { return at<272>().as_bytes(); }
  bool has_f2fs_write_end() const { return at<273>().valid(); }
  ::protozero::ConstBytes f2fs_write_end() const { return at<273>().as_bytes(); }
  bool has_alloc_pages_iommu_end() const { return at<274>().valid(); }
  ::protozero::ConstBytes alloc_pages_iommu_end() const { return at<274>().as_bytes(); }
  bool has_alloc_pages_iommu_fail() const { return at<275>().valid(); }
  ::protozero::ConstBytes alloc_pages_iommu_fail() const { return at<275>().as_bytes(); }
  bool has_alloc_pages_iommu_start() const { return at<276>().valid(); }
  ::protozero::ConstBytes alloc_pages_iommu_start() const { return at<276>().as_bytes(); }
  bool has_alloc_pages_sys_end() const { return at<277>().valid(); }
  ::protozero::ConstBytes alloc_pages_sys_end() const { return at<277>().as_bytes(); }
  bool has_alloc_pages_sys_fail() const { return at<278>().valid(); }
  ::protozero::ConstBytes alloc_pages_sys_fail() const { return at<278>().as_bytes(); }
  bool has_alloc_pages_sys_start() const { return at<279>().valid(); }
  ::protozero::ConstBytes alloc_pages_sys_start() const { return at<279>().as_bytes(); }
  bool has_dma_alloc_contiguous_retry() const { return at<280>().valid(); }
  ::protozero::ConstBytes dma_alloc_contiguous_retry() const { return at<280>().as_bytes(); }
  bool has_iommu_map_range() const { return at<281>().valid(); }
  ::protozero::ConstBytes iommu_map_range() const { return at<281>().as_bytes(); }
  bool has_iommu_sec_ptbl_map_range_end() const { return at<282>().valid(); }
  ::protozero::ConstBytes iommu_sec_ptbl_map_range_end() const { return at<282>().as_bytes(); }
  bool has_iommu_sec_ptbl_map_range_start() const { return at<283>().valid(); }
  ::protozero::ConstBytes iommu_sec_ptbl_map_range_start() const { return at<283>().as_bytes(); }
  bool has_ion_alloc_buffer_end() const { return at<284>().valid(); }
  ::protozero::ConstBytes ion_alloc_buffer_end() const { return at<284>().as_bytes(); }
  bool has_ion_alloc_buffer_fail() const { return at<285>().valid(); }
  ::protozero::ConstBytes ion_alloc_buffer_fail() const { return at<285>().as_bytes(); }
  bool has_ion_alloc_buffer_fallback() const { return at<286>().valid(); }
  ::protozero::ConstBytes ion_alloc_buffer_fallback() const { return at<286>().as_bytes(); }
  bool has_ion_alloc_buffer_start() const { return at<287>().valid(); }
  ::protozero::ConstBytes ion_alloc_buffer_start() const { return at<287>().as_bytes(); }
  bool has_ion_cp_alloc_retry() const { return at<288>().valid(); }
  ::protozero::ConstBytes ion_cp_alloc_retry() const { return at<288>().as_bytes(); }
  bool has_ion_cp_secure_buffer_end() const { return at<289>().valid(); }
  ::protozero::ConstBytes ion_cp_secure_buffer_end() const { return at<289>().as_bytes(); }
  bool has_ion_cp_secure_buffer_start() const { return at<290>().valid(); }
  ::protozero::ConstBytes ion_cp_secure_buffer_start() const { return at<290>().as_bytes(); }
  bool has_ion_prefetching() const { return at<291>().valid(); }
  ::protozero::ConstBytes ion_prefetching() const { return at<291>().as_bytes(); }
  bool has_ion_secure_cma_add_to_pool_end() const { return at<292>().valid(); }
  ::protozero::ConstBytes ion_secure_cma_add_to_pool_end() const { return at<292>().as_bytes(); }
  bool has_ion_secure_cma_add_to_pool_start() const { return at<293>().valid(); }
  ::protozero::ConstBytes ion_secure_cma_add_to_pool_start() const { return at<293>().as_bytes(); }
  bool has_ion_secure_cma_allocate_end() const { return at<294>().valid(); }
  ::protozero::ConstBytes ion_secure_cma_allocate_end() const { return at<294>().as_bytes(); }
  bool has_ion_secure_cma_allocate_start() const { return at<295>().valid(); }
  ::protozero::ConstBytes ion_secure_cma_allocate_start() const { return at<295>().as_bytes(); }
  bool has_ion_secure_cma_shrink_pool_end() const { return at<296>().valid(); }
  ::protozero::ConstBytes ion_secure_cma_shrink_pool_end() const { return at<296>().as_bytes(); }
  bool has_ion_secure_cma_shrink_pool_start() const { return at<297>().valid(); }
  ::protozero::ConstBytes ion_secure_cma_shrink_pool_start() const { return at<297>().as_bytes(); }
  bool has_kfree() const { return at<298>().valid(); }
  ::protozero::ConstBytes kfree() const { return at<298>().as_bytes(); }
  bool has_kmalloc() const { return at<299>().valid(); }
  ::protozero::ConstBytes kmalloc() const { return at<299>().as_bytes(); }
  bool has_kmalloc_node() const { return at<300>().valid(); }
  ::protozero::ConstBytes kmalloc_node() const { return at<300>().as_bytes(); }
  bool has_kmem_cache_alloc() const { return at<301>().valid(); }
  ::protozero::ConstBytes kmem_cache_alloc() const { return at<301>().as_bytes(); }
  bool has_kmem_cache_alloc_node() const { return at<302>().valid(); }
  ::protozero::ConstBytes kmem_cache_alloc_node() const { return at<302>().as_bytes(); }
  bool has_kmem_cache_free() const { return at<303>().valid(); }
  ::protozero::ConstBytes kmem_cache_free() const { return at<303>().as_bytes(); }
  bool has_migrate_pages_end() const { return at<304>().valid(); }
  ::protozero::ConstBytes migrate_pages_end() const { return at<304>().as_bytes(); }
  bool has_migrate_pages_start() const { return at<305>().valid(); }
  ::protozero::ConstBytes migrate_pages_start() const { return at<305>().as_bytes(); }
  bool has_migrate_retry() const { return at<306>().valid(); }
  ::protozero::ConstBytes migrate_retry() const { return at<306>().as_bytes(); }
  bool has_mm_page_alloc() const { return at<307>().valid(); }
  ::protozero::ConstBytes mm_page_alloc() const { return at<307>().as_bytes(); }
  bool has_mm_page_alloc_extfrag() const { return at<308>().valid(); }
  ::protozero::ConstBytes mm_page_alloc_extfrag() const { return at<308>().as_bytes(); }
  bool has_mm_page_alloc_zone_locked() const { return at<309>().valid(); }
  ::protozero::ConstBytes mm_page_alloc_zone_locked() const { return at<309>().as_bytes(); }
  bool has_mm_page_free() const { return at<310>().valid(); }
  ::protozero::ConstBytes mm_page_free() const { return at<310>().as_bytes(); }
  bool has_mm_page_free_batched() const { return at<311>().valid(); }
  ::protozero::ConstBytes mm_page_free_batched() const { return at<311>().as_bytes(); }
  bool has_mm_page_pcpu_drain() const { return at<312>().valid(); }
  ::protozero::ConstBytes mm_page_pcpu_drain() const { return at<312>().as_bytes(); }
  bool has_rss_stat() const { return at<313>().valid(); }
  ::protozero::ConstBytes rss_stat() const { return at<313>().as_bytes(); }
  bool has_ion_heap_shrink() const { return at<314>().valid(); }
  ::protozero::ConstBytes ion_heap_shrink() const { return at<314>().as_bytes(); }
  bool has_ion_heap_grow() const { return at<315>().valid(); }
  ::protozero::ConstBytes ion_heap_grow() const { return at<315>().as_bytes(); }
  bool has_fence_init() const { return at<316>().valid(); }
  ::protozero::ConstBytes fence_init() const { return at<316>().as_bytes(); }
  bool has_fence_destroy() const { return at<317>().valid(); }
  ::protozero::ConstBytes fence_destroy() const { return at<317>().as_bytes(); }
  bool has_fence_enable_signal() const { return at<318>().valid(); }
  ::protozero::ConstBytes fence_enable_signal() const { return at<318>().as_bytes(); }
  bool has_fence_signaled() const { return at<319>().valid(); }
  ::protozero::ConstBytes fence_signaled() const { return at<319>().as_bytes(); }
  bool has_clk_enable() const { return at<320>().valid(); }
  ::protozero::ConstBytes clk_enable() const { return at<320>().as_bytes(); }
  bool has_clk_disable() const { return at<321>().valid(); }
  ::protozero::ConstBytes clk_disable() const { return at<321>().as_bytes(); }
  bool has_clk_set_rate() const { return at<322>().valid(); }
  ::protozero::ConstBytes clk_set_rate() const { return at<322>().as_bytes(); }
  bool has_binder_transaction_alloc_buf() const { return at<323>().valid(); }
  ::protozero::ConstBytes binder_transaction_alloc_buf() const { return at<323>().as_bytes(); }
  bool has_signal_deliver() const { return at<324>().valid(); }
  ::protozero::ConstBytes signal_deliver() const { return at<324>().as_bytes(); }
  bool has_signal_generate() const { return at<325>().valid(); }
  ::protozero::ConstBytes signal_generate() const { return at<325>().as_bytes(); }
  bool has_oom_score_adj_update() const { return at<326>().valid(); }
  ::protozero::ConstBytes oom_score_adj_update() const { return at<326>().as_bytes(); }
  bool has_generic() const { return at<327>().valid(); }
  ::protozero::ConstBytes generic() const { return at<327>().as_bytes(); }
  bool has_mm_event_record() const { return at<328>().valid(); }
  ::protozero::ConstBytes mm_event_record() const { return at<328>().as_bytes(); }
  bool has_sys_enter() const { return at<329>().valid(); }
  ::protozero::ConstBytes sys_enter() const { return at<329>().as_bytes(); }
  bool has_sys_exit() const { return at<330>().valid(); }
  ::protozero::ConstBytes sys_exit() const { return at<330>().as_bytes(); }
  bool has_zero() const { return at<331>().valid(); }
  ::protozero::ConstBytes zero() const { return at<331>().as_bytes(); }
  bool has_gpu_frequency() const { return at<332>().valid(); }
  ::protozero::ConstBytes gpu_frequency() const { return at<332>().as_bytes(); }
  bool has_sde_tracing_mark_write() const { return at<333>().valid(); }
  ::protozero::ConstBytes sde_tracing_mark_write() const { return at<333>().as_bytes(); }
  bool has_mark_victim() const { return at<334>().valid(); }
  ::protozero::ConstBytes mark_victim() const { return at<334>().as_bytes(); }
  bool has_ion_stat() const { return at<335>().valid(); }
  ::protozero::ConstBytes ion_stat() const { return at<335>().as_bytes(); }
  bool has_ion_buffer_create() const { return at<336>().valid(); }
  ::protozero::ConstBytes ion_buffer_create() const { return at<336>().as_bytes(); }
  bool has_ion_buffer_destroy() const { return at<337>().valid(); }
  ::protozero::ConstBytes ion_buffer_destroy() const { return at<337>().as_bytes(); }
  bool has_scm_call_start() const { return at<338>().valid(); }
  ::protozero::ConstBytes scm_call_start() const { return at<338>().as_bytes(); }
  bool has_scm_call_end() const { return at<339>().valid(); }
  ::protozero::ConstBytes scm_call_end() const { return at<339>().as_bytes(); }
  bool has_gpu_mem_total() const { return at<340>().valid(); }
  ::protozero::ConstBytes gpu_mem_total() const { return at<340>().as_bytes(); }
  bool has_thermal_temperature() const { return at<341>().valid(); }
  ::protozero::ConstBytes thermal_temperature() const { return at<341>().as_bytes(); }
  bool has_cdev_update() const { return at<342>().valid(); }
  ::protozero::ConstBytes cdev_update() const { return at<342>().as_bytes(); }
  bool has_cpuhp_exit() const { return at<343>().valid(); }
  ::protozero::ConstBytes cpuhp_exit() const { return at<343>().as_bytes(); }
  bool has_cpuhp_multi_enter() const { return at<344>().valid(); }
  ::protozero::ConstBytes cpuhp_multi_enter() const { return at<344>().as_bytes(); }
  bool has_cpuhp_enter() const { return at<345>().valid(); }
  ::protozero::ConstBytes cpuhp_enter() const { return at<345>().as_bytes(); }
  bool has_cpuhp_latency() const { return at<346>().valid(); }
  ::protozero::ConstBytes cpuhp_latency() const { return at<346>().as_bytes(); }
  bool has_fastrpc_dma_stat() const { return at<347>().valid(); }
  ::protozero::ConstBytes fastrpc_dma_stat() const { return at<347>().as_bytes(); }
  bool has_dpu_tracing_mark_write() const { return at<348>().valid(); }
  ::protozero::ConstBytes dpu_tracing_mark_write() const { return at<348>().as_bytes(); }
  bool has_g2d_tracing_mark_write() const { return at<349>().valid(); }
  ::protozero::ConstBytes g2d_tracing_mark_write() const { return at<349>().as_bytes(); }
  bool has_mali_tracing_mark_write() const { return at<350>().valid(); }
  ::protozero::ConstBytes mali_tracing_mark_write() const { return at<350>().as_bytes(); }
  bool has_dma_heap_stat() const { return at<351>().valid(); }
  ::protozero::ConstBytes dma_heap_stat() const { return at<351>().as_bytes(); }
  bool has_cpuhp_pause() const { return at<352>().valid(); }
  ::protozero::ConstBytes cpuhp_pause() const { return at<352>().as_bytes(); }
  bool has_sched_pi_setprio() const { return at<353>().valid(); }
  ::protozero::ConstBytes sched_pi_setprio() const { return at<353>().as_bytes(); }
  bool has_sde_sde_evtlog() const { return at<354>().valid(); }
  ::protozero::ConstBytes sde_sde_evtlog() const { return at<354>().as_bytes(); }
  bool has_sde_sde_perf_calc_crtc() const { return at<355>().valid(); }
  ::protozero::ConstBytes sde_sde_perf_calc_crtc() const { return at<355>().as_bytes(); }
  bool has_sde_sde_perf_crtc_update() const { return at<356>().valid(); }
  ::protozero::ConstBytes sde_sde_perf_crtc_update() const { return at<356>().as_bytes(); }
  bool has_sde_sde_perf_set_qos_luts() const { return at<357>().valid(); }
  ::protozero::ConstBytes sde_sde_perf_set_qos_luts() const { return at<357>().as_bytes(); }
  bool has_sde_sde_perf_update_bus() const { return at<358>().valid(); }
  ::protozero::ConstBytes sde_sde_perf_update_bus() const { return at<358>().as_bytes(); }
  bool has_rss_stat_throttled() const { return at<359>().valid(); }
  ::protozero::ConstBytes rss_stat_throttled() const { return at<359>().as_bytes(); }
  bool has_netif_receive_skb() const { return at<360>().valid(); }
  ::protozero::ConstBytes netif_receive_skb() const { return at<360>().as_bytes(); }
  bool has_net_dev_xmit() const { return at<361>().valid(); }
  ::protozero::ConstBytes net_dev_xmit() const { return at<361>().as_bytes(); }
  bool has_inet_sock_set_state() const { return at<362>().valid(); }
  ::protozero::ConstBytes inet_sock_set_state() const { return at<362>().as_bytes(); }
  bool has_tcp_retransmit_skb() const { return at<363>().valid(); }
  ::protozero::ConstBytes tcp_retransmit_skb() const { return at<363>().as_bytes(); }
  bool has_cros_ec_sensorhub_data() const { return at<364>().valid(); }
  ::protozero::ConstBytes cros_ec_sensorhub_data() const { return at<364>().as_bytes(); }
  bool has_napi_gro_receive_entry() const { return at<365>().valid(); }
  ::protozero::ConstBytes napi_gro_receive_entry() const { return at<365>().as_bytes(); }
  bool has_napi_gro_receive_exit() const { return at<366>().valid(); }
  ::protozero::ConstBytes napi_gro_receive_exit() const { return at<366>().as_bytes(); }
  bool has_kfree_skb() const { return at<367>().valid(); }
  ::protozero::ConstBytes kfree_skb() const { return at<367>().as_bytes(); }
  bool has_kvm_access_fault() const { return at<368>().valid(); }
  ::protozero::ConstBytes kvm_access_fault() const { return at<368>().as_bytes(); }
  bool has_kvm_ack_irq() const { return at<369>().valid(); }
  ::protozero::ConstBytes kvm_ack_irq() const { return at<369>().as_bytes(); }
  bool has_kvm_age_hva() const { return at<370>().valid(); }
  ::protozero::ConstBytes kvm_age_hva() const { return at<370>().as_bytes(); }
  bool has_kvm_age_page() const { return at<371>().valid(); }
  ::protozero::ConstBytes kvm_age_page() const { return at<371>().as_bytes(); }
  bool has_kvm_arm_clear_debug() const { return at<372>().valid(); }
  ::protozero::ConstBytes kvm_arm_clear_debug() const { return at<372>().as_bytes(); }
  bool has_kvm_arm_set_dreg32() const { return at<373>().valid(); }
  ::protozero::ConstBytes kvm_arm_set_dreg32() const { return at<373>().as_bytes(); }
  bool has_kvm_arm_set_regset() const { return at<374>().valid(); }
  ::protozero::ConstBytes kvm_arm_set_regset() const { return at<374>().as_bytes(); }
  bool has_kvm_arm_setup_debug() const { return at<375>().valid(); }
  ::protozero::ConstBytes kvm_arm_setup_debug() const { return at<375>().as_bytes(); }
  bool has_kvm_entry() const { return at<376>().valid(); }
  ::protozero::ConstBytes kvm_entry() const { return at<376>().as_bytes(); }
  bool has_kvm_exit() const { return at<377>().valid(); }
  ::protozero::ConstBytes kvm_exit() const { return at<377>().as_bytes(); }
  bool has_kvm_fpu() const { return at<378>().valid(); }
  ::protozero::ConstBytes kvm_fpu() const { return at<378>().as_bytes(); }
  bool has_kvm_get_timer_map() const { return at<379>().valid(); }
  ::protozero::ConstBytes kvm_get_timer_map() const { return at<379>().as_bytes(); }
  bool has_kvm_guest_fault() const { return at<380>().valid(); }
  ::protozero::ConstBytes kvm_guest_fault() const { return at<380>().as_bytes(); }
  bool has_kvm_handle_sys_reg() const { return at<381>().valid(); }
  ::protozero::ConstBytes kvm_handle_sys_reg() const { return at<381>().as_bytes(); }
  bool has_kvm_hvc_arm64() const { return at<382>().valid(); }
  ::protozero::ConstBytes kvm_hvc_arm64() const { return at<382>().as_bytes(); }
  bool has_kvm_irq_line() const { return at<383>().valid(); }
  ::protozero::ConstBytes kvm_irq_line() const { return at<383>().as_bytes(); }
  bool has_kvm_mmio() const { return at<384>().valid(); }
  ::protozero::ConstBytes kvm_mmio() const { return at<384>().as_bytes(); }
  bool has_kvm_mmio_emulate() const { return at<385>().valid(); }
  ::protozero::ConstBytes kvm_mmio_emulate() const { return at<385>().as_bytes(); }
  bool has_kvm_set_guest_debug() const { return at<386>().valid(); }
  ::protozero::ConstBytes kvm_set_guest_debug() const { return at<386>().as_bytes(); }
  bool has_kvm_set_irq() const { return at<387>().valid(); }
  ::protozero::ConstBytes kvm_set_irq() const { return at<387>().as_bytes(); }
  bool has_kvm_set_spte_hva() const { return at<388>().valid(); }
  ::protozero::ConstBytes kvm_set_spte_hva() const { return at<388>().as_bytes(); }
  bool has_kvm_set_way_flush() const { return at<389>().valid(); }
  ::protozero::ConstBytes kvm_set_way_flush() const { return at<389>().as_bytes(); }
  bool has_kvm_sys_access() const { return at<390>().valid(); }
  ::protozero::ConstBytes kvm_sys_access() const { return at<390>().as_bytes(); }
  bool has_kvm_test_age_hva() const { return at<391>().valid(); }
  ::protozero::ConstBytes kvm_test_age_hva() const { return at<391>().as_bytes(); }
  bool has_kvm_timer_emulate() const { return at<392>().valid(); }
  ::protozero::ConstBytes kvm_timer_emulate() const { return at<392>().as_bytes(); }
  bool has_kvm_timer_hrtimer_expire() const { return at<393>().valid(); }
  ::protozero::ConstBytes kvm_timer_hrtimer_expire() const { return at<393>().as_bytes(); }
  bool has_kvm_timer_restore_state() const { return at<394>().valid(); }
  ::protozero::ConstBytes kvm_timer_restore_state() const { return at<394>().as_bytes(); }
  bool has_kvm_timer_save_state() const { return at<395>().valid(); }
  ::protozero::ConstBytes kvm_timer_save_state() const { return at<395>().as_bytes(); }
  bool has_kvm_timer_update_irq() const { return at<396>().valid(); }
  ::protozero::ConstBytes kvm_timer_update_irq() const { return at<396>().as_bytes(); }
  bool has_kvm_toggle_cache() const { return at<397>().valid(); }
  ::protozero::ConstBytes kvm_toggle_cache() const { return at<397>().as_bytes(); }
  bool has_kvm_unmap_hva_range() const { return at<398>().valid(); }
  ::protozero::ConstBytes kvm_unmap_hva_range() const { return at<398>().as_bytes(); }
  bool has_kvm_userspace_exit() const { return at<399>().valid(); }
  ::protozero::ConstBytes kvm_userspace_exit() const { return at<399>().as_bytes(); }
  bool has_kvm_vcpu_wakeup() const { return at<400>().valid(); }
  ::protozero::ConstBytes kvm_vcpu_wakeup() const { return at<400>().as_bytes(); }
  bool has_kvm_wfx_arm64() const { return at<401>().valid(); }
  ::protozero::ConstBytes kvm_wfx_arm64() const { return at<401>().as_bytes(); }
  bool has_trap_reg() const { return at<402>().valid(); }
  ::protozero::ConstBytes trap_reg() const { return at<402>().as_bytes(); }
  bool has_vgic_update_irq_pending() const { return at<403>().valid(); }
  ::protozero::ConstBytes vgic_update_irq_pending() const { return at<403>().as_bytes(); }
  bool has_wakeup_source_activate() const { return at<404>().valid(); }
  ::protozero::ConstBytes wakeup_source_activate() const { return at<404>().as_bytes(); }
  bool has_wakeup_source_deactivate() const { return at<405>().valid(); }
  ::protozero::ConstBytes wakeup_source_deactivate() const { return at<405>().as_bytes(); }
  bool has_ufshcd_command() const { return at<406>().valid(); }
  ::protozero::ConstBytes ufshcd_command() const { return at<406>().as_bytes(); }
  bool has_ufshcd_clk_gating() const { return at<407>().valid(); }
  ::protozero::ConstBytes ufshcd_clk_gating() const { return at<407>().as_bytes(); }
  bool has_console() const { return at<408>().valid(); }
  ::protozero::ConstBytes console() const { return at<408>().as_bytes(); }
  bool has_drm_vblank_event() const { return at<409>().valid(); }
  ::protozero::ConstBytes drm_vblank_event() const { return at<409>().as_bytes(); }
  bool has_drm_vblank_event_delivered() const { return at<410>().valid(); }
  ::protozero::ConstBytes drm_vblank_event_delivered() const { return at<410>().as_bytes(); }
  bool has_drm_sched_job() const { return at<411>().valid(); }
  ::protozero::ConstBytes drm_sched_job() const { return at<411>().as_bytes(); }
  bool has_drm_run_job() const { return at<412>().valid(); }
  ::protozero::ConstBytes drm_run_job() const { return at<412>().as_bytes(); }
  bool has_drm_sched_process_job() const { return at<413>().valid(); }
  ::protozero::ConstBytes drm_sched_process_job() const { return at<413>().as_bytes(); }
  bool has_dma_fence_init() const { return at<414>().valid(); }
  ::protozero::ConstBytes dma_fence_init() const { return at<414>().as_bytes(); }
  bool has_dma_fence_emit() const { return at<415>().valid(); }
  ::protozero::ConstBytes dma_fence_emit() const { return at<415>().as_bytes(); }
  bool has_dma_fence_signaled() const { return at<416>().valid(); }
  ::protozero::ConstBytes dma_fence_signaled() const { return at<416>().as_bytes(); }
  bool has_dma_fence_wait_start() const { return at<417>().valid(); }
  ::protozero::ConstBytes dma_fence_wait_start() const { return at<417>().as_bytes(); }
  bool has_dma_fence_wait_end() const { return at<418>().valid(); }
  ::protozero::ConstBytes dma_fence_wait_end() const { return at<418>().as_bytes(); }
};

class FtraceEvent : public ::protozero::Message {
 public:
  using Decoder = FtraceEvent_Decoder;
  enum : int32_t {
    kTimestampFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrintFieldNumber = 3,
    kSchedSwitchFieldNumber = 4,
    kCpuFrequencyFieldNumber = 11,
    kCpuFrequencyLimitsFieldNumber = 12,
    kCpuIdleFieldNumber = 13,
    kClockEnableFieldNumber = 14,
    kClockDisableFieldNumber = 15,
    kClockSetRateFieldNumber = 16,
    kSchedWakeupFieldNumber = 17,
    kSchedBlockedReasonFieldNumber = 18,
    kSchedCpuHotplugFieldNumber = 19,
    kSchedWakingFieldNumber = 20,
    kIpiEntryFieldNumber = 21,
    kIpiExitFieldNumber = 22,
    kIpiRaiseFieldNumber = 23,
    kSoftirqEntryFieldNumber = 24,
    kSoftirqExitFieldNumber = 25,
    kSoftirqRaiseFieldNumber = 26,
    kI2cReadFieldNumber = 27,
    kI2cWriteFieldNumber = 28,
    kI2cResultFieldNumber = 29,
    kI2cReplyFieldNumber = 30,
    kSmbusReadFieldNumber = 31,
    kSmbusWriteFieldNumber = 32,
    kSmbusResultFieldNumber = 33,
    kSmbusReplyFieldNumber = 34,
    kLowmemoryKillFieldNumber = 35,
    kIrqHandlerEntryFieldNumber = 36,
    kIrqHandlerExitFieldNumber = 37,
    kSyncPtFieldNumber = 38,
    kSyncTimelineFieldNumber = 39,
    kSyncWaitFieldNumber = 40,
    kExt4DaWriteBeginFieldNumber = 41,
    kExt4DaWriteEndFieldNumber = 42,
    kExt4SyncFileEnterFieldNumber = 43,
    kExt4SyncFileExitFieldNumber = 44,
    kBlockRqIssueFieldNumber = 45,
    kMmVmscanDirectReclaimBeginFieldNumber = 46,
    kMmVmscanDirectReclaimEndFieldNumber = 47,
    kMmVmscanKswapdWakeFieldNumber = 48,
    kMmVmscanKswapdSleepFieldNumber = 49,
    kBinderTransactionFieldNumber = 50,
    kBinderTransactionReceivedFieldNumber = 51,
    kBinderSetPriorityFieldNumber = 52,
    kBinderLockFieldNumber = 53,
    kBinderLockedFieldNumber = 54,
    kBinderUnlockFieldNumber = 55,
    kWorkqueueActivateWorkFieldNumber = 56,
    kWorkqueueExecuteEndFieldNumber = 57,
    kWorkqueueExecuteStartFieldNumber = 58,
    kWorkqueueQueueWorkFieldNumber = 59,
    kRegulatorDisableFieldNumber = 60,
    kRegulatorDisableCompleteFieldNumber = 61,
    kRegulatorEnableFieldNumber = 62,
    kRegulatorEnableCompleteFieldNumber = 63,
    kRegulatorEnableDelayFieldNumber = 64,
    kRegulatorSetVoltageFieldNumber = 65,
    kRegulatorSetVoltageCompleteFieldNumber = 66,
    kCgroupAttachTaskFieldNumber = 67,
    kCgroupMkdirFieldNumber = 68,
    kCgroupRemountFieldNumber = 69,
    kCgroupRmdirFieldNumber = 70,
    kCgroupTransferTasksFieldNumber = 71,
    kCgroupDestroyRootFieldNumber = 72,
    kCgroupReleaseFieldNumber = 73,
    kCgroupRenameFieldNumber = 74,
    kCgroupSetupRootFieldNumber = 75,
    kMdpCmdKickoffFieldNumber = 76,
    kMdpCommitFieldNumber = 77,
    kMdpPerfSetOtFieldNumber = 78,
    kMdpSsppChangeFieldNumber = 79,
    kTracingMarkWriteFieldNumber = 80,
    kMdpCmdPingpongDoneFieldNumber = 81,
    kMdpCompareBwFieldNumber = 82,
    kMdpPerfSetPanicLutsFieldNumber = 83,
    kMdpSsppSetFieldNumber = 84,
    kMdpCmdReadptrDoneFieldNumber = 85,
    kMdpMisrCrcFieldNumber = 86,
    kMdpPerfSetQosLutsFieldNumber = 87,
    kMdpTraceCounterFieldNumber = 88,
    kMdpCmdReleaseBwFieldNumber = 89,
    kMdpMixerUpdateFieldNumber = 90,
    kMdpPerfSetWmLevelsFieldNumber = 91,
    kMdpVideoUnderrunDoneFieldNumber = 92,
    kMdpCmdWaitPingpongFieldNumber = 93,
    kMdpPerfPrefillCalcFieldNumber = 94,
    kMdpPerfUpdateBusFieldNumber = 95,
    kRotatorBwAoAsContextFieldNumber = 96,
    kMmFilemapAddToPageCacheFieldNumber = 97,
    kMmFilemapDeleteFromPageCacheFieldNumber = 98,
    kMmCompactionBeginFieldNumber = 99,
    kMmCompactionDeferCompactionFieldNumber = 100,
    kMmCompactionDeferredFieldNumber = 101,
    kMmCompactionDeferResetFieldNumber = 102,
    kMmCompactionEndFieldNumber = 103,
    kMmCompactionFinishedFieldNumber = 104,
    kMmCompactionIsolateFreepagesFieldNumber = 105,
    kMmCompactionIsolateMigratepagesFieldNumber = 106,
    kMmCompactionKcompactdSleepFieldNumber = 107,
    kMmCompactionKcompactdWakeFieldNumber = 108,
    kMmCompactionMigratepagesFieldNumber = 109,
    kMmCompactionSuitableFieldNumber = 110,
    kMmCompactionTryToCompactPagesFieldNumber = 111,
    kMmCompactionWakeupKcompactdFieldNumber = 112,
    kSuspendResumeFieldNumber = 113,
    kSchedWakeupNewFieldNumber = 114,
    kBlockBioBackmergeFieldNumber = 115,
    kBlockBioBounceFieldNumber = 116,
    kBlockBioCompleteFieldNumber = 117,
    kBlockBioFrontmergeFieldNumber = 118,
    kBlockBioQueueFieldNumber = 119,
    kBlockBioRemapFieldNumber = 120,
    kBlockDirtyBufferFieldNumber = 121,
    kBlockGetrqFieldNumber = 122,
    kBlockPlugFieldNumber = 123,
    kBlockRqAbortFieldNumber = 124,
    kBlockRqCompleteFieldNumber = 125,
    kBlockRqInsertFieldNumber = 126,
    kBlockRqRemapFieldNumber = 128,
    kBlockRqRequeueFieldNumber = 129,
    kBlockSleeprqFieldNumber = 130,
    kBlockSplitFieldNumber = 131,
    kBlockTouchBufferFieldNumber = 132,
    kBlockUnplugFieldNumber = 133,
    kExt4AllocDaBlocksFieldNumber = 134,
    kExt4AllocateBlocksFieldNumber = 135,
    kExt4AllocateInodeFieldNumber = 136,
    kExt4BeginOrderedTruncateFieldNumber = 137,
    kExt4CollapseRangeFieldNumber = 138,
    kExt4DaReleaseSpaceFieldNumber = 139,
    kExt4DaReserveSpaceFieldNumber = 140,
    kExt4DaUpdateReserveSpaceFieldNumber = 141,
    kExt4DaWritePagesFieldNumber = 142,
    kExt4DaWritePagesExtentFieldNumber = 143,
    kExt4DirectIOEnterFieldNumber = 144,
    kExt4DirectIOExitFieldNumber = 145,
    kExt4DiscardBlocksFieldNumber = 146,
    kExt4DiscardPreallocationsFieldNumber = 147,
    kExt4DropInodeFieldNumber = 148,
    kExt4EsCacheExtentFieldNumber = 149,
    kExt4EsFindDelayedExtentRangeEnterFieldNumber = 150,
    kExt4EsFindDelayedExtentRangeExitFieldNumber = 151,
    kExt4EsInsertExtentFieldNumber = 152,
    kExt4EsLookupExtentEnterFieldNumber = 153,
    kExt4EsLookupExtentExitFieldNumber = 154,
    kExt4EsRemoveExtentFieldNumber = 155,
    kExt4EsShrinkFieldNumber = 156,
    kExt4EsShrinkCountFieldNumber = 157,
    kExt4EsShrinkScanEnterFieldNumber = 158,
    kExt4EsShrinkScanExitFieldNumber = 159,
    kExt4EvictInodeFieldNumber = 160,
    kExt4ExtConvertToInitializedEnterFieldNumber = 161,
    kExt4ExtConvertToInitializedFastpathFieldNumber = 162,
    kExt4ExtHandleUnwrittenExtentsFieldNumber = 163,
    kExt4ExtInCacheFieldNumber = 164,
    kExt4ExtLoadExtentFieldNumber = 165,
    kExt4ExtMapBlocksEnterFieldNumber = 166,
    kExt4ExtMapBlocksExitFieldNumber = 167,
    kExt4ExtPutInCacheFieldNumber = 168,
    kExt4ExtRemoveSpaceFieldNumber = 169,
    kExt4ExtRemoveSpaceDoneFieldNumber = 170,
    kExt4ExtRmIdxFieldNumber = 171,
    kExt4ExtRmLeafFieldNumber = 172,
    kExt4ExtShowExtentFieldNumber = 173,
    kExt4FallocateEnterFieldNumber = 174,
    kExt4FallocateExitFieldNumber = 175,
    kExt4FindDelallocRangeFieldNumber = 176,
    kExt4ForgetFieldNumber = 177,
    kExt4FreeBlocksFieldNumber = 178,
    kExt4FreeInodeFieldNumber = 179,
    kExt4GetImpliedClusterAllocExitFieldNumber = 180,
    kExt4GetReservedClusterAllocFieldNumber = 181,
    kExt4IndMapBlocksEnterFieldNumber = 182,
    kExt4IndMapBlocksExitFieldNumber = 183,
    kExt4InsertRangeFieldNumber = 184,
    kExt4InvalidatepageFieldNumber = 185,
    kExt4JournalStartFieldNumber = 186,
    kExt4JournalStartReservedFieldNumber = 187,
    kExt4JournalledInvalidatepageFieldNumber = 188,
    kExt4JournalledWriteEndFieldNumber = 189,
    kExt4LoadInodeFieldNumber = 190,
    kExt4LoadInodeBitmapFieldNumber = 191,
    kExt4MarkInodeDirtyFieldNumber = 192,
    kExt4MbBitmapLoadFieldNumber = 193,
    kExt4MbBuddyBitmapLoadFieldNumber = 194,
    kExt4MbDiscardPreallocationsFieldNumber = 195,
    kExt4MbNewGroupPaFieldNumber = 196,
    kExt4MbNewInodePaFieldNumber = 197,
    kExt4MbReleaseGroupPaFieldNumber = 198,
    kExt4MbReleaseInodePaFieldNumber = 199,
    kExt4MballocAllocFieldNumber = 200,
    kExt4MballocDiscardFieldNumber = 201,
    kExt4MballocFreeFieldNumber = 202,
    kExt4MballocPreallocFieldNumber = 203,
    kExt4OtherInodeUpdateTimeFieldNumber = 204,
    kExt4PunchHoleFieldNumber = 205,
    kExt4ReadBlockBitmapLoadFieldNumber = 206,
    kExt4ReadpageFieldNumber = 207,
    kExt4ReleasepageFieldNumber = 208,
    kExt4RemoveBlocksFieldNumber = 209,
    kExt4RequestBlocksFieldNumber = 210,
    kExt4RequestInodeFieldNumber = 211,
    kExt4SyncFsFieldNumber = 212,
    kExt4TrimAllFreeFieldNumber = 213,
    kExt4TrimExtentFieldNumber = 214,
    kExt4TruncateEnterFieldNumber = 215,
    kExt4TruncateExitFieldNumber = 216,
    kExt4UnlinkEnterFieldNumber = 217,
    kExt4UnlinkExitFieldNumber = 218,
    kExt4WriteBeginFieldNumber = 219,
    kExt4WriteEndFieldNumber = 230,
    kExt4WritepageFieldNumber = 231,
    kExt4WritepagesFieldNumber = 232,
    kExt4WritepagesResultFieldNumber = 233,
    kExt4ZeroRangeFieldNumber = 234,
    kTaskNewtaskFieldNumber = 235,
    kTaskRenameFieldNumber = 236,
    kSchedProcessExecFieldNumber = 237,
    kSchedProcessExitFieldNumber = 238,
    kSchedProcessForkFieldNumber = 239,
    kSchedProcessFreeFieldNumber = 240,
    kSchedProcessHangFieldNumber = 241,
    kSchedProcessWaitFieldNumber = 242,
    kF2fsDoSubmitBioFieldNumber = 243,
    kF2fsEvictInodeFieldNumber = 244,
    kF2fsFallocateFieldNumber = 245,
    kF2fsGetDataBlockFieldNumber = 246,
    kF2fsGetVictimFieldNumber = 247,
    kF2fsIgetFieldNumber = 248,
    kF2fsIgetExitFieldNumber = 249,
    kF2fsNewInodeFieldNumber = 250,
    kF2fsReadpageFieldNumber = 251,
    kF2fsReserveNewBlockFieldNumber = 252,
    kF2fsSetPageDirtyFieldNumber = 253,
    kF2fsSubmitWritePageFieldNumber = 254,
    kF2fsSyncFileEnterFieldNumber = 255,
    kF2fsSyncFileExitFieldNumber = 256,
    kF2fsSyncFsFieldNumber = 257,
    kF2fsTruncateFieldNumber = 258,
    kF2fsTruncateBlocksEnterFieldNumber = 259,
    kF2fsTruncateBlocksExitFieldNumber = 260,
    kF2fsTruncateDataBlocksRangeFieldNumber = 261,
    kF2fsTruncateInodeBlocksEnterFieldNumber = 262,
    kF2fsTruncateInodeBlocksExitFieldNumber = 263,
    kF2fsTruncateNodeFieldNumber = 264,
    kF2fsTruncateNodesEnterFieldNumber = 265,
    kF2fsTruncateNodesExitFieldNumber = 266,
    kF2fsTruncatePartialNodesFieldNumber = 267,
    kF2fsUnlinkEnterFieldNumber = 268,
    kF2fsUnlinkExitFieldNumber = 269,
    kF2fsVmPageMkwriteFieldNumber = 270,
    kF2fsWriteBeginFieldNumber = 271,
    kF2fsWriteCheckpointFieldNumber = 272,
    kF2fsWriteEndFieldNumber = 273,
    kAllocPagesIommuEndFieldNumber = 274,
    kAllocPagesIommuFailFieldNumber = 275,
    kAllocPagesIommuStartFieldNumber = 276,
    kAllocPagesSysEndFieldNumber = 277,
    kAllocPagesSysFailFieldNumber = 278,
    kAllocPagesSysStartFieldNumber = 279,
    kDmaAllocContiguousRetryFieldNumber = 280,
    kIommuMapRangeFieldNumber = 281,
    kIommuSecPtblMapRangeEndFieldNumber = 282,
    kIommuSecPtblMapRangeStartFieldNumber = 283,
    kIonAllocBufferEndFieldNumber = 284,
    kIonAllocBufferFailFieldNumber = 285,
    kIonAllocBufferFallbackFieldNumber = 286,
    kIonAllocBufferStartFieldNumber = 287,
    kIonCpAllocRetryFieldNumber = 288,
    kIonCpSecureBufferEndFieldNumber = 289,
    kIonCpSecureBufferStartFieldNumber = 290,
    kIonPrefetchingFieldNumber = 291,
    kIonSecureCmaAddToPoolEndFieldNumber = 292,
    kIonSecureCmaAddToPoolStartFieldNumber = 293,
    kIonSecureCmaAllocateEndFieldNumber = 294,
    kIonSecureCmaAllocateStartFieldNumber = 295,
    kIonSecureCmaShrinkPoolEndFieldNumber = 296,
    kIonSecureCmaShrinkPoolStartFieldNumber = 297,
    kKfreeFieldNumber = 298,
    kKmallocFieldNumber = 299,
    kKmallocNodeFieldNumber = 300,
    kKmemCacheAllocFieldNumber = 301,
    kKmemCacheAllocNodeFieldNumber = 302,
    kKmemCacheFreeFieldNumber = 303,
    kMigratePagesEndFieldNumber = 304,
    kMigratePagesStartFieldNumber = 305,
    kMigrateRetryFieldNumber = 306,
    kMmPageAllocFieldNumber = 307,
    kMmPageAllocExtfragFieldNumber = 308,
    kMmPageAllocZoneLockedFieldNumber = 309,
    kMmPageFreeFieldNumber = 310,
    kMmPageFreeBatchedFieldNumber = 311,
    kMmPagePcpuDrainFieldNumber = 312,
    kRssStatFieldNumber = 313,
    kIonHeapShrinkFieldNumber = 314,
    kIonHeapGrowFieldNumber = 315,
    kFenceInitFieldNumber = 316,
    kFenceDestroyFieldNumber = 317,
    kFenceEnableSignalFieldNumber = 318,
    kFenceSignaledFieldNumber = 319,
    kClkEnableFieldNumber = 320,
    kClkDisableFieldNumber = 321,
    kClkSetRateFieldNumber = 322,
    kBinderTransactionAllocBufFieldNumber = 323,
    kSignalDeliverFieldNumber = 324,
    kSignalGenerateFieldNumber = 325,
    kOomScoreAdjUpdateFieldNumber = 326,
    kGenericFieldNumber = 327,
    kMmEventRecordFieldNumber = 328,
    kSysEnterFieldNumber = 329,
    kSysExitFieldNumber = 330,
    kZeroFieldNumber = 331,
    kGpuFrequencyFieldNumber = 332,
    kSdeTracingMarkWriteFieldNumber = 333,
    kMarkVictimFieldNumber = 334,
    kIonStatFieldNumber = 335,
    kIonBufferCreateFieldNumber = 336,
    kIonBufferDestroyFieldNumber = 337,
    kScmCallStartFieldNumber = 338,
    kScmCallEndFieldNumber = 339,
    kGpuMemTotalFieldNumber = 340,
    kThermalTemperatureFieldNumber = 341,
    kCdevUpdateFieldNumber = 342,
    kCpuhpExitFieldNumber = 343,
    kCpuhpMultiEnterFieldNumber = 344,
    kCpuhpEnterFieldNumber = 345,
    kCpuhpLatencyFieldNumber = 346,
    kFastrpcDmaStatFieldNumber = 347,
    kDpuTracingMarkWriteFieldNumber = 348,
    kG2dTracingMarkWriteFieldNumber = 349,
    kMaliTracingMarkWriteFieldNumber = 350,
    kDmaHeapStatFieldNumber = 351,
    kCpuhpPauseFieldNumber = 352,
    kSchedPiSetprioFieldNumber = 353,
    kSdeSdeEvtlogFieldNumber = 354,
    kSdeSdePerfCalcCrtcFieldNumber = 355,
    kSdeSdePerfCrtcUpdateFieldNumber = 356,
    kSdeSdePerfSetQosLutsFieldNumber = 357,
    kSdeSdePerfUpdateBusFieldNumber = 358,
    kRssStatThrottledFieldNumber = 359,
    kNetifReceiveSkbFieldNumber = 360,
    kNetDevXmitFieldNumber = 361,
    kInetSockSetStateFieldNumber = 362,
    kTcpRetransmitSkbFieldNumber = 363,
    kCrosEcSensorhubDataFieldNumber = 364,
    kNapiGroReceiveEntryFieldNumber = 365,
    kNapiGroReceiveExitFieldNumber = 366,
    kKfreeSkbFieldNumber = 367,
    kKvmAccessFaultFieldNumber = 368,
    kKvmAckIrqFieldNumber = 369,
    kKvmAgeHvaFieldNumber = 370,
    kKvmAgePageFieldNumber = 371,
    kKvmArmClearDebugFieldNumber = 372,
    kKvmArmSetDreg32FieldNumber = 373,
    kKvmArmSetRegsetFieldNumber = 374,
    kKvmArmSetupDebugFieldNumber = 375,
    kKvmEntryFieldNumber = 376,
    kKvmExitFieldNumber = 377,
    kKvmFpuFieldNumber = 378,
    kKvmGetTimerMapFieldNumber = 379,
    kKvmGuestFaultFieldNumber = 380,
    kKvmHandleSysRegFieldNumber = 381,
    kKvmHvcArm64FieldNumber = 382,
    kKvmIrqLineFieldNumber = 383,
    kKvmMmioFieldNumber = 384,
    kKvmMmioEmulateFieldNumber = 385,
    kKvmSetGuestDebugFieldNumber = 386,
    kKvmSetIrqFieldNumber = 387,
    kKvmSetSpteHvaFieldNumber = 388,
    kKvmSetWayFlushFieldNumber = 389,
    kKvmSysAccessFieldNumber = 390,
    kKvmTestAgeHvaFieldNumber = 391,
    kKvmTimerEmulateFieldNumber = 392,
    kKvmTimerHrtimerExpireFieldNumber = 393,
    kKvmTimerRestoreStateFieldNumber = 394,
    kKvmTimerSaveStateFieldNumber = 395,
    kKvmTimerUpdateIrqFieldNumber = 396,
    kKvmToggleCacheFieldNumber = 397,
    kKvmUnmapHvaRangeFieldNumber = 398,
    kKvmUserspaceExitFieldNumber = 399,
    kKvmVcpuWakeupFieldNumber = 400,
    kKvmWfxArm64FieldNumber = 401,
    kTrapRegFieldNumber = 402,
    kVgicUpdateIrqPendingFieldNumber = 403,
    kWakeupSourceActivateFieldNumber = 404,
    kWakeupSourceDeactivateFieldNumber = 405,
    kUfshcdCommandFieldNumber = 406,
    kUfshcdClkGatingFieldNumber = 407,
    kConsoleFieldNumber = 408,
    kDrmVblankEventFieldNumber = 409,
    kDrmVblankEventDeliveredFieldNumber = 410,
    kDrmSchedJobFieldNumber = 411,
    kDrmRunJobFieldNumber = 412,
    kDrmSchedProcessJobFieldNumber = 413,
    kDmaFenceInitFieldNumber = 414,
    kDmaFenceEmitFieldNumber = 415,
    kDmaFenceSignaledFieldNumber = 416,
    kDmaFenceWaitStartFieldNumber = 417,
    kDmaFenceWaitEndFieldNumber = 418,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.FtraceEvent"; }


  using FieldMetadata_Timestamp =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Timestamp kTimestamp() { return {}; }
  void set_timestamp(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Timestamp::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Pid =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Pid kPid() { return {}; }
  void set_pid(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Pid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Print =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      PrintFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Print kPrint() { return {}; }
  template <typename T = PrintFtraceEvent> T* set_print() {
    return BeginNestedMessage<T>(3);
  }


  using FieldMetadata_SchedSwitch =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SchedSwitchFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SchedSwitch kSchedSwitch() { return {}; }
  template <typename T = SchedSwitchFtraceEvent> T* set_sched_switch() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_CpuFrequency =
    ::protozero::proto_utils::FieldMetadata<
      11,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      CpuFrequencyFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CpuFrequency kCpuFrequency() { return {}; }
  template <typename T = CpuFrequencyFtraceEvent> T* set_cpu_frequency() {
    return BeginNestedMessage<T>(11);
  }


  using FieldMetadata_CpuFrequencyLimits =
    ::protozero::proto_utils::FieldMetadata<
      12,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      CpuFrequencyLimitsFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CpuFrequencyLimits kCpuFrequencyLimits() { return {}; }
  template <typename T = CpuFrequencyLimitsFtraceEvent> T* set_cpu_frequency_limits() {
    return BeginNestedMessage<T>(12);
  }


  using FieldMetadata_CpuIdle =
    ::protozero::proto_utils::FieldMetadata<
      13,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      CpuIdleFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CpuIdle kCpuIdle() { return {}; }
  template <typename T = CpuIdleFtraceEvent> T* set_cpu_idle() {
    return BeginNestedMessage<T>(13);
  }


  using FieldMetadata_ClockEnable =
    ::protozero::proto_utils::FieldMetadata<
      14,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ClockEnableFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ClockEnable kClockEnable() { return {}; }
  template <typename T = ClockEnableFtraceEvent> T* set_clock_enable() {
    return BeginNestedMessage<T>(14);
  }


  using FieldMetadata_ClockDisable =
    ::protozero::proto_utils::FieldMetadata<
      15,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ClockDisableFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ClockDisable kClockDisable() { return {}; }
  template <typename T = ClockDisableFtraceEvent> T* set_clock_disable() {
    return BeginNestedMessage<T>(15);
  }


  using FieldMetadata_ClockSetRate =
    ::protozero::proto_utils::FieldMetadata<
      16,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ClockSetRateFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ClockSetRate kClockSetRate() { return {}; }
  template <typename T = ClockSetRateFtraceEvent> T* set_clock_set_rate() {
    return BeginNestedMessage<T>(16);
  }


  using FieldMetadata_SchedWakeup =
    ::protozero::proto_utils::FieldMetadata<
      17,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SchedWakeupFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SchedWakeup kSchedWakeup() { return {}; }
  template <typename T = SchedWakeupFtraceEvent> T* set_sched_wakeup() {
    return BeginNestedMessage<T>(17);
  }


  using FieldMetadata_SchedBlockedReason =
    ::protozero::proto_utils::FieldMetadata<
      18,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SchedBlockedReasonFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SchedBlockedReason kSchedBlockedReason() { return {}; }
  template <typename T = SchedBlockedReasonFtraceEvent> T* set_sched_blocked_reason() {
    return BeginNestedMessage<T>(18);
  }


  using FieldMetadata_SchedCpuHotplug =
    ::protozero::proto_utils::FieldMetadata<
      19,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SchedCpuHotplugFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SchedCpuHotplug kSchedCpuHotplug() { return {}; }
  template <typename T = SchedCpuHotplugFtraceEvent> T* set_sched_cpu_hotplug() {
    return BeginNestedMessage<T>(19);
  }


  using FieldMetadata_SchedWaking =
    ::protozero::proto_utils::FieldMetadata<
      20,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SchedWakingFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SchedWaking kSchedWaking() { return {}; }
  template <typename T = SchedWakingFtraceEvent> T* set_sched_waking() {
    return BeginNestedMessage<T>(20);
  }


  using FieldMetadata_IpiEntry =
    ::protozero::proto_utils::FieldMetadata<
      21,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IpiEntryFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IpiEntry kIpiEntry() { return {}; }
  template <typename T = IpiEntryFtraceEvent> T* set_ipi_entry() {
    return BeginNestedMessage<T>(21);
  }


  using FieldMetadata_IpiExit =
    ::protozero::proto_utils::FieldMetadata<
      22,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IpiExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IpiExit kIpiExit() { return {}; }
  template <typename T = IpiExitFtraceEvent> T* set_ipi_exit() {
    return BeginNestedMessage<T>(22);
  }


  using FieldMetadata_IpiRaise =
    ::protozero::proto_utils::FieldMetadata<
      23,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IpiRaiseFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IpiRaise kIpiRaise() { return {}; }
  template <typename T = IpiRaiseFtraceEvent> T* set_ipi_raise() {
    return BeginNestedMessage<T>(23);
  }


  using FieldMetadata_SoftirqEntry =
    ::protozero::proto_utils::FieldMetadata<
      24,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SoftirqEntryFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SoftirqEntry kSoftirqEntry() { return {}; }
  template <typename T = SoftirqEntryFtraceEvent> T* set_softirq_entry() {
    return BeginNestedMessage<T>(24);
  }


  using FieldMetadata_SoftirqExit =
    ::protozero::proto_utils::FieldMetadata<
      25,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SoftirqExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SoftirqExit kSoftirqExit() { return {}; }
  template <typename T = SoftirqExitFtraceEvent> T* set_softirq_exit() {
    return BeginNestedMessage<T>(25);
  }


  using FieldMetadata_SoftirqRaise =
    ::protozero::proto_utils::FieldMetadata<
      26,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SoftirqRaiseFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SoftirqRaise kSoftirqRaise() { return {}; }
  template <typename T = SoftirqRaiseFtraceEvent> T* set_softirq_raise() {
    return BeginNestedMessage<T>(26);
  }


  using FieldMetadata_I2cRead =
    ::protozero::proto_utils::FieldMetadata<
      27,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      I2cReadFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_I2cRead kI2cRead() { return {}; }
  template <typename T = I2cReadFtraceEvent> T* set_i2c_read() {
    return BeginNestedMessage<T>(27);
  }


  using FieldMetadata_I2cWrite =
    ::protozero::proto_utils::FieldMetadata<
      28,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      I2cWriteFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_I2cWrite kI2cWrite() { return {}; }
  template <typename T = I2cWriteFtraceEvent> T* set_i2c_write() {
    return BeginNestedMessage<T>(28);
  }


  using FieldMetadata_I2cResult =
    ::protozero::proto_utils::FieldMetadata<
      29,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      I2cResultFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_I2cResult kI2cResult() { return {}; }
  template <typename T = I2cResultFtraceEvent> T* set_i2c_result() {
    return BeginNestedMessage<T>(29);
  }


  using FieldMetadata_I2cReply =
    ::protozero::proto_utils::FieldMetadata<
      30,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      I2cReplyFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_I2cReply kI2cReply() { return {}; }
  template <typename T = I2cReplyFtraceEvent> T* set_i2c_reply() {
    return BeginNestedMessage<T>(30);
  }


  using FieldMetadata_SmbusRead =
    ::protozero::proto_utils::FieldMetadata<
      31,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SmbusReadFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SmbusRead kSmbusRead() { return {}; }
  template <typename T = SmbusReadFtraceEvent> T* set_smbus_read() {
    return BeginNestedMessage<T>(31);
  }


  using FieldMetadata_SmbusWrite =
    ::protozero::proto_utils::FieldMetadata<
      32,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SmbusWriteFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SmbusWrite kSmbusWrite() { return {}; }
  template <typename T = SmbusWriteFtraceEvent> T* set_smbus_write() {
    return BeginNestedMessage<T>(32);
  }


  using FieldMetadata_SmbusResult =
    ::protozero::proto_utils::FieldMetadata<
      33,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SmbusResultFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SmbusResult kSmbusResult() { return {}; }
  template <typename T = SmbusResultFtraceEvent> T* set_smbus_result() {
    return BeginNestedMessage<T>(33);
  }


  using FieldMetadata_SmbusReply =
    ::protozero::proto_utils::FieldMetadata<
      34,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SmbusReplyFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SmbusReply kSmbusReply() { return {}; }
  template <typename T = SmbusReplyFtraceEvent> T* set_smbus_reply() {
    return BeginNestedMessage<T>(34);
  }


  using FieldMetadata_LowmemoryKill =
    ::protozero::proto_utils::FieldMetadata<
      35,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      LowmemoryKillFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_LowmemoryKill kLowmemoryKill() { return {}; }
  template <typename T = LowmemoryKillFtraceEvent> T* set_lowmemory_kill() {
    return BeginNestedMessage<T>(35);
  }


  using FieldMetadata_IrqHandlerEntry =
    ::protozero::proto_utils::FieldMetadata<
      36,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IrqHandlerEntryFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IrqHandlerEntry kIrqHandlerEntry() { return {}; }
  template <typename T = IrqHandlerEntryFtraceEvent> T* set_irq_handler_entry() {
    return BeginNestedMessage<T>(36);
  }


  using FieldMetadata_IrqHandlerExit =
    ::protozero::proto_utils::FieldMetadata<
      37,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IrqHandlerExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IrqHandlerExit kIrqHandlerExit() { return {}; }
  template <typename T = IrqHandlerExitFtraceEvent> T* set_irq_handler_exit() {
    return BeginNestedMessage<T>(37);
  }


  using FieldMetadata_SyncPt =
    ::protozero::proto_utils::FieldMetadata<
      38,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SyncPtFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SyncPt kSyncPt() { return {}; }
  template <typename T = SyncPtFtraceEvent> T* set_sync_pt() {
    return BeginNestedMessage<T>(38);
  }


  using FieldMetadata_SyncTimeline =
    ::protozero::proto_utils::FieldMetadata<
      39,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SyncTimelineFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SyncTimeline kSyncTimeline() { return {}; }
  template <typename T = SyncTimelineFtraceEvent> T* set_sync_timeline() {
    return BeginNestedMessage<T>(39);
  }


  using FieldMetadata_SyncWait =
    ::protozero::proto_utils::FieldMetadata<
      40,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SyncWaitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SyncWait kSyncWait() { return {}; }
  template <typename T = SyncWaitFtraceEvent> T* set_sync_wait() {
    return BeginNestedMessage<T>(40);
  }


  using FieldMetadata_Ext4DaWriteBegin =
    ::protozero::proto_utils::FieldMetadata<
      41,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4DaWriteBeginFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4DaWriteBegin kExt4DaWriteBegin() { return {}; }
  template <typename T = Ext4DaWriteBeginFtraceEvent> T* set_ext4_da_write_begin() {
    return BeginNestedMessage<T>(41);
  }


  using FieldMetadata_Ext4DaWriteEnd =
    ::protozero::proto_utils::FieldMetadata<
      42,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4DaWriteEndFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4DaWriteEnd kExt4DaWriteEnd() { return {}; }
  template <typename T = Ext4DaWriteEndFtraceEvent> T* set_ext4_da_write_end() {
    return BeginNestedMessage<T>(42);
  }


  using FieldMetadata_Ext4SyncFileEnter =
    ::protozero::proto_utils::FieldMetadata<
      43,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4SyncFileEnterFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4SyncFileEnter kExt4SyncFileEnter() { return {}; }
  template <typename T = Ext4SyncFileEnterFtraceEvent> T* set_ext4_sync_file_enter() {
    return BeginNestedMessage<T>(43);
  }


  using FieldMetadata_Ext4SyncFileExit =
    ::protozero::proto_utils::FieldMetadata<
      44,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4SyncFileExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4SyncFileExit kExt4SyncFileExit() { return {}; }
  template <typename T = Ext4SyncFileExitFtraceEvent> T* set_ext4_sync_file_exit() {
    return BeginNestedMessage<T>(44);
  }


  using FieldMetadata_BlockRqIssue =
    ::protozero::proto_utils::FieldMetadata<
      45,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlockRqIssueFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BlockRqIssue kBlockRqIssue() { return {}; }
  template <typename T = BlockRqIssueFtraceEvent> T* set_block_rq_issue() {
    return BeginNestedMessage<T>(45);
  }


  using FieldMetadata_MmVmscanDirectReclaimBegin =
    ::protozero::proto_utils::FieldMetadata<
      46,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmVmscanDirectReclaimBeginFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmVmscanDirectReclaimBegin kMmVmscanDirectReclaimBegin() { return {}; }
  template <typename T = MmVmscanDirectReclaimBeginFtraceEvent> T* set_mm_vmscan_direct_reclaim_begin() {
    return BeginNestedMessage<T>(46);
  }


  using FieldMetadata_MmVmscanDirectReclaimEnd =
    ::protozero::proto_utils::FieldMetadata<
      47,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmVmscanDirectReclaimEndFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmVmscanDirectReclaimEnd kMmVmscanDirectReclaimEnd() { return {}; }
  template <typename T = MmVmscanDirectReclaimEndFtraceEvent> T* set_mm_vmscan_direct_reclaim_end() {
    return BeginNestedMessage<T>(47);
  }


  using FieldMetadata_MmVmscanKswapdWake =
    ::protozero::proto_utils::FieldMetadata<
      48,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmVmscanKswapdWakeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmVmscanKswapdWake kMmVmscanKswapdWake() { return {}; }
  template <typename T = MmVmscanKswapdWakeFtraceEvent> T* set_mm_vmscan_kswapd_wake() {
    return BeginNestedMessage<T>(48);
  }


  using FieldMetadata_MmVmscanKswapdSleep =
    ::protozero::proto_utils::FieldMetadata<
      49,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmVmscanKswapdSleepFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmVmscanKswapdSleep kMmVmscanKswapdSleep() { return {}; }
  template <typename T = MmVmscanKswapdSleepFtraceEvent> T* set_mm_vmscan_kswapd_sleep() {
    return BeginNestedMessage<T>(49);
  }


  using FieldMetadata_BinderTransaction =
    ::protozero::proto_utils::FieldMetadata<
      50,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BinderTransactionFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BinderTransaction kBinderTransaction() { return {}; }
  template <typename T = BinderTransactionFtraceEvent> T* set_binder_transaction() {
    return BeginNestedMessage<T>(50);
  }


  using FieldMetadata_BinderTransactionReceived =
    ::protozero::proto_utils::FieldMetadata<
      51,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BinderTransactionReceivedFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BinderTransactionReceived kBinderTransactionReceived() { return {}; }
  template <typename T = BinderTransactionReceivedFtraceEvent> T* set_binder_transaction_received() {
    return BeginNestedMessage<T>(51);
  }


  using FieldMetadata_BinderSetPriority =
    ::protozero::proto_utils::FieldMetadata<
      52,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BinderSetPriorityFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BinderSetPriority kBinderSetPriority() { return {}; }
  template <typename T = BinderSetPriorityFtraceEvent> T* set_binder_set_priority() {
    return BeginNestedMessage<T>(52);
  }


  using FieldMetadata_BinderLock =
    ::protozero::proto_utils::FieldMetadata<
      53,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BinderLockFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BinderLock kBinderLock() { return {}; }
  template <typename T = BinderLockFtraceEvent> T* set_binder_lock() {
    return BeginNestedMessage<T>(53);
  }


  using FieldMetadata_BinderLocked =
    ::protozero::proto_utils::FieldMetadata<
      54,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BinderLockedFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BinderLocked kBinderLocked() { return {}; }
  template <typename T = BinderLockedFtraceEvent> T* set_binder_locked() {
    return BeginNestedMessage<T>(54);
  }


  using FieldMetadata_BinderUnlock =
    ::protozero::proto_utils::FieldMetadata<
      55,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BinderUnlockFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BinderUnlock kBinderUnlock() { return {}; }
  template <typename T = BinderUnlockFtraceEvent> T* set_binder_unlock() {
    return BeginNestedMessage<T>(55);
  }


  using FieldMetadata_WorkqueueActivateWork =
    ::protozero::proto_utils::FieldMetadata<
      56,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WorkqueueActivateWorkFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_WorkqueueActivateWork kWorkqueueActivateWork() { return {}; }
  template <typename T = WorkqueueActivateWorkFtraceEvent> T* set_workqueue_activate_work() {
    return BeginNestedMessage<T>(56);
  }


  using FieldMetadata_WorkqueueExecuteEnd =
    ::protozero::proto_utils::FieldMetadata<
      57,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WorkqueueExecuteEndFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_WorkqueueExecuteEnd kWorkqueueExecuteEnd() { return {}; }
  template <typename T = WorkqueueExecuteEndFtraceEvent> T* set_workqueue_execute_end() {
    return BeginNestedMessage<T>(57);
  }


  using FieldMetadata_WorkqueueExecuteStart =
    ::protozero::proto_utils::FieldMetadata<
      58,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WorkqueueExecuteStartFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_WorkqueueExecuteStart kWorkqueueExecuteStart() { return {}; }
  template <typename T = WorkqueueExecuteStartFtraceEvent> T* set_workqueue_execute_start() {
    return BeginNestedMessage<T>(58);
  }


  using FieldMetadata_WorkqueueQueueWork =
    ::protozero::proto_utils::FieldMetadata<
      59,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WorkqueueQueueWorkFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_WorkqueueQueueWork kWorkqueueQueueWork() { return {}; }
  template <typename T = WorkqueueQueueWorkFtraceEvent> T* set_workqueue_queue_work() {
    return BeginNestedMessage<T>(59);
  }


  using FieldMetadata_RegulatorDisable =
    ::protozero::proto_utils::FieldMetadata<
      60,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RegulatorDisableFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RegulatorDisable kRegulatorDisable() { return {}; }
  template <typename T = RegulatorDisableFtraceEvent> T* set_regulator_disable() {
    return BeginNestedMessage<T>(60);
  }


  using FieldMetadata_RegulatorDisableComplete =
    ::protozero::proto_utils::FieldMetadata<
      61,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RegulatorDisableCompleteFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RegulatorDisableComplete kRegulatorDisableComplete() { return {}; }
  template <typename T = RegulatorDisableCompleteFtraceEvent> T* set_regulator_disable_complete() {
    return BeginNestedMessage<T>(61);
  }


  using FieldMetadata_RegulatorEnable =
    ::protozero::proto_utils::FieldMetadata<
      62,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RegulatorEnableFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RegulatorEnable kRegulatorEnable() { return {}; }
  template <typename T = RegulatorEnableFtraceEvent> T* set_regulator_enable() {
    return BeginNestedMessage<T>(62);
  }


  using FieldMetadata_RegulatorEnableComplete =
    ::protozero::proto_utils::FieldMetadata<
      63,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RegulatorEnableCompleteFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RegulatorEnableComplete kRegulatorEnableComplete() { return {}; }
  template <typename T = RegulatorEnableCompleteFtraceEvent> T* set_regulator_enable_complete() {
    return BeginNestedMessage<T>(63);
  }


  using FieldMetadata_RegulatorEnableDelay =
    ::protozero::proto_utils::FieldMetadata<
      64,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RegulatorEnableDelayFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RegulatorEnableDelay kRegulatorEnableDelay() { return {}; }
  template <typename T = RegulatorEnableDelayFtraceEvent> T* set_regulator_enable_delay() {
    return BeginNestedMessage<T>(64);
  }


  using FieldMetadata_RegulatorSetVoltage =
    ::protozero::proto_utils::FieldMetadata<
      65,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RegulatorSetVoltageFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RegulatorSetVoltage kRegulatorSetVoltage() { return {}; }
  template <typename T = RegulatorSetVoltageFtraceEvent> T* set_regulator_set_voltage() {
    return BeginNestedMessage<T>(65);
  }


  using FieldMetadata_RegulatorSetVoltageComplete =
    ::protozero::proto_utils::FieldMetadata<
      66,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RegulatorSetVoltageCompleteFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RegulatorSetVoltageComplete kRegulatorSetVoltageComplete() { return {}; }
  template <typename T = RegulatorSetVoltageCompleteFtraceEvent> T* set_regulator_set_voltage_complete() {
    return BeginNestedMessage<T>(66);
  }


  using FieldMetadata_CgroupAttachTask =
    ::protozero::proto_utils::FieldMetadata<
      67,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      CgroupAttachTaskFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CgroupAttachTask kCgroupAttachTask() { return {}; }
  template <typename T = CgroupAttachTaskFtraceEvent> T* set_cgroup_attach_task() {
    return BeginNestedMessage<T>(67);
  }


  using FieldMetadata_CgroupMkdir =
    ::protozero::proto_utils::FieldMetadata<
      68,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      CgroupMkdirFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CgroupMkdir kCgroupMkdir() { return {}; }
  template <typename T = CgroupMkdirFtraceEvent> T* set_cgroup_mkdir() {
    return BeginNestedMessage<T>(68);
  }


  using FieldMetadata_CgroupRemount =
    ::protozero::proto_utils::FieldMetadata<
      69,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      CgroupRemountFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CgroupRemount kCgroupRemount() { return {}; }
  template <typename T = CgroupRemountFtraceEvent> T* set_cgroup_remount() {
    return BeginNestedMessage<T>(69);
  }


  using FieldMetadata_CgroupRmdir =
    ::protozero::proto_utils::FieldMetadata<
      70,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      CgroupRmdirFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CgroupRmdir kCgroupRmdir() { return {}; }
  template <typename T = CgroupRmdirFtraceEvent> T* set_cgroup_rmdir() {
    return BeginNestedMessage<T>(70);
  }


  using FieldMetadata_CgroupTransferTasks =
    ::protozero::proto_utils::FieldMetadata<
      71,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      CgroupTransferTasksFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CgroupTransferTasks kCgroupTransferTasks() { return {}; }
  template <typename T = CgroupTransferTasksFtraceEvent> T* set_cgroup_transfer_tasks() {
    return BeginNestedMessage<T>(71);
  }


  using FieldMetadata_CgroupDestroyRoot =
    ::protozero::proto_utils::FieldMetadata<
      72,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      CgroupDestroyRootFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CgroupDestroyRoot kCgroupDestroyRoot() { return {}; }
  template <typename T = CgroupDestroyRootFtraceEvent> T* set_cgroup_destroy_root() {
    return BeginNestedMessage<T>(72);
  }


  using FieldMetadata_CgroupRelease =
    ::protozero::proto_utils::FieldMetadata<
      73,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      CgroupReleaseFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CgroupRelease kCgroupRelease() { return {}; }
  template <typename T = CgroupReleaseFtraceEvent> T* set_cgroup_release() {
    return BeginNestedMessage<T>(73);
  }


  using FieldMetadata_CgroupRename =
    ::protozero::proto_utils::FieldMetadata<
      74,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      CgroupRenameFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CgroupRename kCgroupRename() { return {}; }
  template <typename T = CgroupRenameFtraceEvent> T* set_cgroup_rename() {
    return BeginNestedMessage<T>(74);
  }


  using FieldMetadata_CgroupSetupRoot =
    ::protozero::proto_utils::FieldMetadata<
      75,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      CgroupSetupRootFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CgroupSetupRoot kCgroupSetupRoot() { return {}; }
  template <typename T = CgroupSetupRootFtraceEvent> T* set_cgroup_setup_root() {
    return BeginNestedMessage<T>(75);
  }


  using FieldMetadata_MdpCmdKickoff =
    ::protozero::proto_utils::FieldMetadata<
      76,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MdpCmdKickoffFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MdpCmdKickoff kMdpCmdKickoff() { return {}; }
  template <typename T = MdpCmdKickoffFtraceEvent> T* set_mdp_cmd_kickoff() {
    return BeginNestedMessage<T>(76);
  }


  using FieldMetadata_MdpCommit =
    ::protozero::proto_utils::FieldMetadata<
      77,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MdpCommitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MdpCommit kMdpCommit() { return {}; }
  template <typename T = MdpCommitFtraceEvent> T* set_mdp_commit() {
    return BeginNestedMessage<T>(77);
  }


  using FieldMetadata_MdpPerfSetOt =
    ::protozero::proto_utils::FieldMetadata<
      78,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MdpPerfSetOtFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MdpPerfSetOt kMdpPerfSetOt() { return {}; }
  template <typename T = MdpPerfSetOtFtraceEvent> T* set_mdp_perf_set_ot() {
    return BeginNestedMessage<T>(78);
  }


  using FieldMetadata_MdpSsppChange =
    ::protozero::proto_utils::FieldMetadata<
      79,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MdpSsppChangeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MdpSsppChange kMdpSsppChange() { return {}; }
  template <typename T = MdpSsppChangeFtraceEvent> T* set_mdp_sspp_change() {
    return BeginNestedMessage<T>(79);
  }


  using FieldMetadata_TracingMarkWrite =
    ::protozero::proto_utils::FieldMetadata<
      80,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TracingMarkWriteFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_TracingMarkWrite kTracingMarkWrite() { return {}; }
  template <typename T = TracingMarkWriteFtraceEvent> T* set_tracing_mark_write() {
    return BeginNestedMessage<T>(80);
  }


  using FieldMetadata_MdpCmdPingpongDone =
    ::protozero::proto_utils::FieldMetadata<
      81,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MdpCmdPingpongDoneFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MdpCmdPingpongDone kMdpCmdPingpongDone() { return {}; }
  template <typename T = MdpCmdPingpongDoneFtraceEvent> T* set_mdp_cmd_pingpong_done() {
    return BeginNestedMessage<T>(81);
  }


  using FieldMetadata_MdpCompareBw =
    ::protozero::proto_utils::FieldMetadata<
      82,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MdpCompareBwFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MdpCompareBw kMdpCompareBw() { return {}; }
  template <typename T = MdpCompareBwFtraceEvent> T* set_mdp_compare_bw() {
    return BeginNestedMessage<T>(82);
  }


  using FieldMetadata_MdpPerfSetPanicLuts =
    ::protozero::proto_utils::FieldMetadata<
      83,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MdpPerfSetPanicLutsFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MdpPerfSetPanicLuts kMdpPerfSetPanicLuts() { return {}; }
  template <typename T = MdpPerfSetPanicLutsFtraceEvent> T* set_mdp_perf_set_panic_luts() {
    return BeginNestedMessage<T>(83);
  }


  using FieldMetadata_MdpSsppSet =
    ::protozero::proto_utils::FieldMetadata<
      84,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MdpSsppSetFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MdpSsppSet kMdpSsppSet() { return {}; }
  template <typename T = MdpSsppSetFtraceEvent> T* set_mdp_sspp_set() {
    return BeginNestedMessage<T>(84);
  }


  using FieldMetadata_MdpCmdReadptrDone =
    ::protozero::proto_utils::FieldMetadata<
      85,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MdpCmdReadptrDoneFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MdpCmdReadptrDone kMdpCmdReadptrDone() { return {}; }
  template <typename T = MdpCmdReadptrDoneFtraceEvent> T* set_mdp_cmd_readptr_done() {
    return BeginNestedMessage<T>(85);
  }


  using FieldMetadata_MdpMisrCrc =
    ::protozero::proto_utils::FieldMetadata<
      86,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MdpMisrCrcFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MdpMisrCrc kMdpMisrCrc() { return {}; }
  template <typename T = MdpMisrCrcFtraceEvent> T* set_mdp_misr_crc() {
    return BeginNestedMessage<T>(86);
  }


  using FieldMetadata_MdpPerfSetQosLuts =
    ::protozero::proto_utils::FieldMetadata<
      87,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MdpPerfSetQosLutsFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MdpPerfSetQosLuts kMdpPerfSetQosLuts() { return {}; }
  template <typename T = MdpPerfSetQosLutsFtraceEvent> T* set_mdp_perf_set_qos_luts() {
    return BeginNestedMessage<T>(87);
  }


  using FieldMetadata_MdpTraceCounter =
    ::protozero::proto_utils::FieldMetadata<
      88,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MdpTraceCounterFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MdpTraceCounter kMdpTraceCounter() { return {}; }
  template <typename T = MdpTraceCounterFtraceEvent> T* set_mdp_trace_counter() {
    return BeginNestedMessage<T>(88);
  }


  using FieldMetadata_MdpCmdReleaseBw =
    ::protozero::proto_utils::FieldMetadata<
      89,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MdpCmdReleaseBwFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MdpCmdReleaseBw kMdpCmdReleaseBw() { return {}; }
  template <typename T = MdpCmdReleaseBwFtraceEvent> T* set_mdp_cmd_release_bw() {
    return BeginNestedMessage<T>(89);
  }


  using FieldMetadata_MdpMixerUpdate =
    ::protozero::proto_utils::FieldMetadata<
      90,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MdpMixerUpdateFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MdpMixerUpdate kMdpMixerUpdate() { return {}; }
  template <typename T = MdpMixerUpdateFtraceEvent> T* set_mdp_mixer_update() {
    return BeginNestedMessage<T>(90);
  }


  using FieldMetadata_MdpPerfSetWmLevels =
    ::protozero::proto_utils::FieldMetadata<
      91,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MdpPerfSetWmLevelsFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MdpPerfSetWmLevels kMdpPerfSetWmLevels() { return {}; }
  template <typename T = MdpPerfSetWmLevelsFtraceEvent> T* set_mdp_perf_set_wm_levels() {
    return BeginNestedMessage<T>(91);
  }


  using FieldMetadata_MdpVideoUnderrunDone =
    ::protozero::proto_utils::FieldMetadata<
      92,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MdpVideoUnderrunDoneFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MdpVideoUnderrunDone kMdpVideoUnderrunDone() { return {}; }
  template <typename T = MdpVideoUnderrunDoneFtraceEvent> T* set_mdp_video_underrun_done() {
    return BeginNestedMessage<T>(92);
  }


  using FieldMetadata_MdpCmdWaitPingpong =
    ::protozero::proto_utils::FieldMetadata<
      93,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MdpCmdWaitPingpongFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MdpCmdWaitPingpong kMdpCmdWaitPingpong() { return {}; }
  template <typename T = MdpCmdWaitPingpongFtraceEvent> T* set_mdp_cmd_wait_pingpong() {
    return BeginNestedMessage<T>(93);
  }


  using FieldMetadata_MdpPerfPrefillCalc =
    ::protozero::proto_utils::FieldMetadata<
      94,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MdpPerfPrefillCalcFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MdpPerfPrefillCalc kMdpPerfPrefillCalc() { return {}; }
  template <typename T = MdpPerfPrefillCalcFtraceEvent> T* set_mdp_perf_prefill_calc() {
    return BeginNestedMessage<T>(94);
  }


  using FieldMetadata_MdpPerfUpdateBus =
    ::protozero::proto_utils::FieldMetadata<
      95,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MdpPerfUpdateBusFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MdpPerfUpdateBus kMdpPerfUpdateBus() { return {}; }
  template <typename T = MdpPerfUpdateBusFtraceEvent> T* set_mdp_perf_update_bus() {
    return BeginNestedMessage<T>(95);
  }


  using FieldMetadata_RotatorBwAoAsContext =
    ::protozero::proto_utils::FieldMetadata<
      96,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RotatorBwAoAsContextFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RotatorBwAoAsContext kRotatorBwAoAsContext() { return {}; }
  template <typename T = RotatorBwAoAsContextFtraceEvent> T* set_rotator_bw_ao_as_context() {
    return BeginNestedMessage<T>(96);
  }


  using FieldMetadata_MmFilemapAddToPageCache =
    ::protozero::proto_utils::FieldMetadata<
      97,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmFilemapAddToPageCacheFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmFilemapAddToPageCache kMmFilemapAddToPageCache() { return {}; }
  template <typename T = MmFilemapAddToPageCacheFtraceEvent> T* set_mm_filemap_add_to_page_cache() {
    return BeginNestedMessage<T>(97);
  }


  using FieldMetadata_MmFilemapDeleteFromPageCache =
    ::protozero::proto_utils::FieldMetadata<
      98,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmFilemapDeleteFromPageCacheFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmFilemapDeleteFromPageCache kMmFilemapDeleteFromPageCache() { return {}; }
  template <typename T = MmFilemapDeleteFromPageCacheFtraceEvent> T* set_mm_filemap_delete_from_page_cache() {
    return BeginNestedMessage<T>(98);
  }


  using FieldMetadata_MmCompactionBegin =
    ::protozero::proto_utils::FieldMetadata<
      99,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmCompactionBeginFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmCompactionBegin kMmCompactionBegin() { return {}; }
  template <typename T = MmCompactionBeginFtraceEvent> T* set_mm_compaction_begin() {
    return BeginNestedMessage<T>(99);
  }


  using FieldMetadata_MmCompactionDeferCompaction =
    ::protozero::proto_utils::FieldMetadata<
      100,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmCompactionDeferCompactionFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmCompactionDeferCompaction kMmCompactionDeferCompaction() { return {}; }
  template <typename T = MmCompactionDeferCompactionFtraceEvent> T* set_mm_compaction_defer_compaction() {
    return BeginNestedMessage<T>(100);
  }


  using FieldMetadata_MmCompactionDeferred =
    ::protozero::proto_utils::FieldMetadata<
      101,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmCompactionDeferredFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmCompactionDeferred kMmCompactionDeferred() { return {}; }
  template <typename T = MmCompactionDeferredFtraceEvent> T* set_mm_compaction_deferred() {
    return BeginNestedMessage<T>(101);
  }


  using FieldMetadata_MmCompactionDeferReset =
    ::protozero::proto_utils::FieldMetadata<
      102,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmCompactionDeferResetFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmCompactionDeferReset kMmCompactionDeferReset() { return {}; }
  template <typename T = MmCompactionDeferResetFtraceEvent> T* set_mm_compaction_defer_reset() {
    return BeginNestedMessage<T>(102);
  }


  using FieldMetadata_MmCompactionEnd =
    ::protozero::proto_utils::FieldMetadata<
      103,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmCompactionEndFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmCompactionEnd kMmCompactionEnd() { return {}; }
  template <typename T = MmCompactionEndFtraceEvent> T* set_mm_compaction_end() {
    return BeginNestedMessage<T>(103);
  }


  using FieldMetadata_MmCompactionFinished =
    ::protozero::proto_utils::FieldMetadata<
      104,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmCompactionFinishedFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmCompactionFinished kMmCompactionFinished() { return {}; }
  template <typename T = MmCompactionFinishedFtraceEvent> T* set_mm_compaction_finished() {
    return BeginNestedMessage<T>(104);
  }


  using FieldMetadata_MmCompactionIsolateFreepages =
    ::protozero::proto_utils::FieldMetadata<
      105,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmCompactionIsolateFreepagesFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmCompactionIsolateFreepages kMmCompactionIsolateFreepages() { return {}; }
  template <typename T = MmCompactionIsolateFreepagesFtraceEvent> T* set_mm_compaction_isolate_freepages() {
    return BeginNestedMessage<T>(105);
  }


  using FieldMetadata_MmCompactionIsolateMigratepages =
    ::protozero::proto_utils::FieldMetadata<
      106,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmCompactionIsolateMigratepagesFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmCompactionIsolateMigratepages kMmCompactionIsolateMigratepages() { return {}; }
  template <typename T = MmCompactionIsolateMigratepagesFtraceEvent> T* set_mm_compaction_isolate_migratepages() {
    return BeginNestedMessage<T>(106);
  }


  using FieldMetadata_MmCompactionKcompactdSleep =
    ::protozero::proto_utils::FieldMetadata<
      107,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmCompactionKcompactdSleepFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmCompactionKcompactdSleep kMmCompactionKcompactdSleep() { return {}; }
  template <typename T = MmCompactionKcompactdSleepFtraceEvent> T* set_mm_compaction_kcompactd_sleep() {
    return BeginNestedMessage<T>(107);
  }


  using FieldMetadata_MmCompactionKcompactdWake =
    ::protozero::proto_utils::FieldMetadata<
      108,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmCompactionKcompactdWakeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmCompactionKcompactdWake kMmCompactionKcompactdWake() { return {}; }
  template <typename T = MmCompactionKcompactdWakeFtraceEvent> T* set_mm_compaction_kcompactd_wake() {
    return BeginNestedMessage<T>(108);
  }


  using FieldMetadata_MmCompactionMigratepages =
    ::protozero::proto_utils::FieldMetadata<
      109,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmCompactionMigratepagesFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmCompactionMigratepages kMmCompactionMigratepages() { return {}; }
  template <typename T = MmCompactionMigratepagesFtraceEvent> T* set_mm_compaction_migratepages() {
    return BeginNestedMessage<T>(109);
  }


  using FieldMetadata_MmCompactionSuitable =
    ::protozero::proto_utils::FieldMetadata<
      110,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmCompactionSuitableFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmCompactionSuitable kMmCompactionSuitable() { return {}; }
  template <typename T = MmCompactionSuitableFtraceEvent> T* set_mm_compaction_suitable() {
    return BeginNestedMessage<T>(110);
  }


  using FieldMetadata_MmCompactionTryToCompactPages =
    ::protozero::proto_utils::FieldMetadata<
      111,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmCompactionTryToCompactPagesFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmCompactionTryToCompactPages kMmCompactionTryToCompactPages() { return {}; }
  template <typename T = MmCompactionTryToCompactPagesFtraceEvent> T* set_mm_compaction_try_to_compact_pages() {
    return BeginNestedMessage<T>(111);
  }


  using FieldMetadata_MmCompactionWakeupKcompactd =
    ::protozero::proto_utils::FieldMetadata<
      112,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmCompactionWakeupKcompactdFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmCompactionWakeupKcompactd kMmCompactionWakeupKcompactd() { return {}; }
  template <typename T = MmCompactionWakeupKcompactdFtraceEvent> T* set_mm_compaction_wakeup_kcompactd() {
    return BeginNestedMessage<T>(112);
  }


  using FieldMetadata_SuspendResume =
    ::protozero::proto_utils::FieldMetadata<
      113,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SuspendResumeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SuspendResume kSuspendResume() { return {}; }
  template <typename T = SuspendResumeFtraceEvent> T* set_suspend_resume() {
    return BeginNestedMessage<T>(113);
  }


  using FieldMetadata_SchedWakeupNew =
    ::protozero::proto_utils::FieldMetadata<
      114,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SchedWakeupNewFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SchedWakeupNew kSchedWakeupNew() { return {}; }
  template <typename T = SchedWakeupNewFtraceEvent> T* set_sched_wakeup_new() {
    return BeginNestedMessage<T>(114);
  }


  using FieldMetadata_BlockBioBackmerge =
    ::protozero::proto_utils::FieldMetadata<
      115,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlockBioBackmergeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BlockBioBackmerge kBlockBioBackmerge() { return {}; }
  template <typename T = BlockBioBackmergeFtraceEvent> T* set_block_bio_backmerge() {
    return BeginNestedMessage<T>(115);
  }


  using FieldMetadata_BlockBioBounce =
    ::protozero::proto_utils::FieldMetadata<
      116,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlockBioBounceFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BlockBioBounce kBlockBioBounce() { return {}; }
  template <typename T = BlockBioBounceFtraceEvent> T* set_block_bio_bounce() {
    return BeginNestedMessage<T>(116);
  }


  using FieldMetadata_BlockBioComplete =
    ::protozero::proto_utils::FieldMetadata<
      117,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlockBioCompleteFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BlockBioComplete kBlockBioComplete() { return {}; }
  template <typename T = BlockBioCompleteFtraceEvent> T* set_block_bio_complete() {
    return BeginNestedMessage<T>(117);
  }


  using FieldMetadata_BlockBioFrontmerge =
    ::protozero::proto_utils::FieldMetadata<
      118,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlockBioFrontmergeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BlockBioFrontmerge kBlockBioFrontmerge() { return {}; }
  template <typename T = BlockBioFrontmergeFtraceEvent> T* set_block_bio_frontmerge() {
    return BeginNestedMessage<T>(118);
  }


  using FieldMetadata_BlockBioQueue =
    ::protozero::proto_utils::FieldMetadata<
      119,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlockBioQueueFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BlockBioQueue kBlockBioQueue() { return {}; }
  template <typename T = BlockBioQueueFtraceEvent> T* set_block_bio_queue() {
    return BeginNestedMessage<T>(119);
  }


  using FieldMetadata_BlockBioRemap =
    ::protozero::proto_utils::FieldMetadata<
      120,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlockBioRemapFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BlockBioRemap kBlockBioRemap() { return {}; }
  template <typename T = BlockBioRemapFtraceEvent> T* set_block_bio_remap() {
    return BeginNestedMessage<T>(120);
  }


  using FieldMetadata_BlockDirtyBuffer =
    ::protozero::proto_utils::FieldMetadata<
      121,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlockDirtyBufferFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BlockDirtyBuffer kBlockDirtyBuffer() { return {}; }
  template <typename T = BlockDirtyBufferFtraceEvent> T* set_block_dirty_buffer() {
    return BeginNestedMessage<T>(121);
  }


  using FieldMetadata_BlockGetrq =
    ::protozero::proto_utils::FieldMetadata<
      122,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlockGetrqFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BlockGetrq kBlockGetrq() { return {}; }
  template <typename T = BlockGetrqFtraceEvent> T* set_block_getrq() {
    return BeginNestedMessage<T>(122);
  }


  using FieldMetadata_BlockPlug =
    ::protozero::proto_utils::FieldMetadata<
      123,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlockPlugFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BlockPlug kBlockPlug() { return {}; }
  template <typename T = BlockPlugFtraceEvent> T* set_block_plug() {
    return BeginNestedMessage<T>(123);
  }


  using FieldMetadata_BlockRqAbort =
    ::protozero::proto_utils::FieldMetadata<
      124,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlockRqAbortFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BlockRqAbort kBlockRqAbort() { return {}; }
  template <typename T = BlockRqAbortFtraceEvent> T* set_block_rq_abort() {
    return BeginNestedMessage<T>(124);
  }


  using FieldMetadata_BlockRqComplete =
    ::protozero::proto_utils::FieldMetadata<
      125,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlockRqCompleteFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BlockRqComplete kBlockRqComplete() { return {}; }
  template <typename T = BlockRqCompleteFtraceEvent> T* set_block_rq_complete() {
    return BeginNestedMessage<T>(125);
  }


  using FieldMetadata_BlockRqInsert =
    ::protozero::proto_utils::FieldMetadata<
      126,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlockRqInsertFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BlockRqInsert kBlockRqInsert() { return {}; }
  template <typename T = BlockRqInsertFtraceEvent> T* set_block_rq_insert() {
    return BeginNestedMessage<T>(126);
  }


  using FieldMetadata_BlockRqRemap =
    ::protozero::proto_utils::FieldMetadata<
      128,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlockRqRemapFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BlockRqRemap kBlockRqRemap() { return {}; }
  template <typename T = BlockRqRemapFtraceEvent> T* set_block_rq_remap() {
    return BeginNestedMessage<T>(128);
  }


  using FieldMetadata_BlockRqRequeue =
    ::protozero::proto_utils::FieldMetadata<
      129,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlockRqRequeueFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BlockRqRequeue kBlockRqRequeue() { return {}; }
  template <typename T = BlockRqRequeueFtraceEvent> T* set_block_rq_requeue() {
    return BeginNestedMessage<T>(129);
  }


  using FieldMetadata_BlockSleeprq =
    ::protozero::proto_utils::FieldMetadata<
      130,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlockSleeprqFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BlockSleeprq kBlockSleeprq() { return {}; }
  template <typename T = BlockSleeprqFtraceEvent> T* set_block_sleeprq() {
    return BeginNestedMessage<T>(130);
  }


  using FieldMetadata_BlockSplit =
    ::protozero::proto_utils::FieldMetadata<
      131,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlockSplitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BlockSplit kBlockSplit() { return {}; }
  template <typename T = BlockSplitFtraceEvent> T* set_block_split() {
    return BeginNestedMessage<T>(131);
  }


  using FieldMetadata_BlockTouchBuffer =
    ::protozero::proto_utils::FieldMetadata<
      132,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlockTouchBufferFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BlockTouchBuffer kBlockTouchBuffer() { return {}; }
  template <typename T = BlockTouchBufferFtraceEvent> T* set_block_touch_buffer() {
    return BeginNestedMessage<T>(132);
  }


  using FieldMetadata_BlockUnplug =
    ::protozero::proto_utils::FieldMetadata<
      133,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BlockUnplugFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BlockUnplug kBlockUnplug() { return {}; }
  template <typename T = BlockUnplugFtraceEvent> T* set_block_unplug() {
    return BeginNestedMessage<T>(133);
  }


  using FieldMetadata_Ext4AllocDaBlocks =
    ::protozero::proto_utils::FieldMetadata<
      134,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4AllocDaBlocksFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4AllocDaBlocks kExt4AllocDaBlocks() { return {}; }
  template <typename T = Ext4AllocDaBlocksFtraceEvent> T* set_ext4_alloc_da_blocks() {
    return BeginNestedMessage<T>(134);
  }


  using FieldMetadata_Ext4AllocateBlocks =
    ::protozero::proto_utils::FieldMetadata<
      135,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4AllocateBlocksFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4AllocateBlocks kExt4AllocateBlocks() { return {}; }
  template <typename T = Ext4AllocateBlocksFtraceEvent> T* set_ext4_allocate_blocks() {
    return BeginNestedMessage<T>(135);
  }


  using FieldMetadata_Ext4AllocateInode =
    ::protozero::proto_utils::FieldMetadata<
      136,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4AllocateInodeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4AllocateInode kExt4AllocateInode() { return {}; }
  template <typename T = Ext4AllocateInodeFtraceEvent> T* set_ext4_allocate_inode() {
    return BeginNestedMessage<T>(136);
  }


  using FieldMetadata_Ext4BeginOrderedTruncate =
    ::protozero::proto_utils::FieldMetadata<
      137,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4BeginOrderedTruncateFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4BeginOrderedTruncate kExt4BeginOrderedTruncate() { return {}; }
  template <typename T = Ext4BeginOrderedTruncateFtraceEvent> T* set_ext4_begin_ordered_truncate() {
    return BeginNestedMessage<T>(137);
  }


  using FieldMetadata_Ext4CollapseRange =
    ::protozero::proto_utils::FieldMetadata<
      138,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4CollapseRangeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4CollapseRange kExt4CollapseRange() { return {}; }
  template <typename T = Ext4CollapseRangeFtraceEvent> T* set_ext4_collapse_range() {
    return BeginNestedMessage<T>(138);
  }


  using FieldMetadata_Ext4DaReleaseSpace =
    ::protozero::proto_utils::FieldMetadata<
      139,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4DaReleaseSpaceFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4DaReleaseSpace kExt4DaReleaseSpace() { return {}; }
  template <typename T = Ext4DaReleaseSpaceFtraceEvent> T* set_ext4_da_release_space() {
    return BeginNestedMessage<T>(139);
  }


  using FieldMetadata_Ext4DaReserveSpace =
    ::protozero::proto_utils::FieldMetadata<
      140,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4DaReserveSpaceFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4DaReserveSpace kExt4DaReserveSpace() { return {}; }
  template <typename T = Ext4DaReserveSpaceFtraceEvent> T* set_ext4_da_reserve_space() {
    return BeginNestedMessage<T>(140);
  }


  using FieldMetadata_Ext4DaUpdateReserveSpace =
    ::protozero::proto_utils::FieldMetadata<
      141,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4DaUpdateReserveSpaceFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4DaUpdateReserveSpace kExt4DaUpdateReserveSpace() { return {}; }
  template <typename T = Ext4DaUpdateReserveSpaceFtraceEvent> T* set_ext4_da_update_reserve_space() {
    return BeginNestedMessage<T>(141);
  }


  using FieldMetadata_Ext4DaWritePages =
    ::protozero::proto_utils::FieldMetadata<
      142,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4DaWritePagesFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4DaWritePages kExt4DaWritePages() { return {}; }
  template <typename T = Ext4DaWritePagesFtraceEvent> T* set_ext4_da_write_pages() {
    return BeginNestedMessage<T>(142);
  }


  using FieldMetadata_Ext4DaWritePagesExtent =
    ::protozero::proto_utils::FieldMetadata<
      143,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4DaWritePagesExtentFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4DaWritePagesExtent kExt4DaWritePagesExtent() { return {}; }
  template <typename T = Ext4DaWritePagesExtentFtraceEvent> T* set_ext4_da_write_pages_extent() {
    return BeginNestedMessage<T>(143);
  }


  using FieldMetadata_Ext4DirectIOEnter =
    ::protozero::proto_utils::FieldMetadata<
      144,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4DirectIOEnterFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4DirectIOEnter kExt4DirectIOEnter() { return {}; }
  template <typename T = Ext4DirectIOEnterFtraceEvent> T* set_ext4_direct_io_enter() {
    return BeginNestedMessage<T>(144);
  }


  using FieldMetadata_Ext4DirectIOExit =
    ::protozero::proto_utils::FieldMetadata<
      145,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4DirectIOExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4DirectIOExit kExt4DirectIOExit() { return {}; }
  template <typename T = Ext4DirectIOExitFtraceEvent> T* set_ext4_direct_io_exit() {
    return BeginNestedMessage<T>(145);
  }


  using FieldMetadata_Ext4DiscardBlocks =
    ::protozero::proto_utils::FieldMetadata<
      146,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4DiscardBlocksFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4DiscardBlocks kExt4DiscardBlocks() { return {}; }
  template <typename T = Ext4DiscardBlocksFtraceEvent> T* set_ext4_discard_blocks() {
    return BeginNestedMessage<T>(146);
  }


  using FieldMetadata_Ext4DiscardPreallocations =
    ::protozero::proto_utils::FieldMetadata<
      147,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4DiscardPreallocationsFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4DiscardPreallocations kExt4DiscardPreallocations() { return {}; }
  template <typename T = Ext4DiscardPreallocationsFtraceEvent> T* set_ext4_discard_preallocations() {
    return BeginNestedMessage<T>(147);
  }


  using FieldMetadata_Ext4DropInode =
    ::protozero::proto_utils::FieldMetadata<
      148,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4DropInodeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4DropInode kExt4DropInode() { return {}; }
  template <typename T = Ext4DropInodeFtraceEvent> T* set_ext4_drop_inode() {
    return BeginNestedMessage<T>(148);
  }


  using FieldMetadata_Ext4EsCacheExtent =
    ::protozero::proto_utils::FieldMetadata<
      149,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4EsCacheExtentFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4EsCacheExtent kExt4EsCacheExtent() { return {}; }
  template <typename T = Ext4EsCacheExtentFtraceEvent> T* set_ext4_es_cache_extent() {
    return BeginNestedMessage<T>(149);
  }


  using FieldMetadata_Ext4EsFindDelayedExtentRangeEnter =
    ::protozero::proto_utils::FieldMetadata<
      150,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4EsFindDelayedExtentRangeEnterFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4EsFindDelayedExtentRangeEnter kExt4EsFindDelayedExtentRangeEnter() { return {}; }
  template <typename T = Ext4EsFindDelayedExtentRangeEnterFtraceEvent> T* set_ext4_es_find_delayed_extent_range_enter() {
    return BeginNestedMessage<T>(150);
  }


  using FieldMetadata_Ext4EsFindDelayedExtentRangeExit =
    ::protozero::proto_utils::FieldMetadata<
      151,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4EsFindDelayedExtentRangeExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4EsFindDelayedExtentRangeExit kExt4EsFindDelayedExtentRangeExit() { return {}; }
  template <typename T = Ext4EsFindDelayedExtentRangeExitFtraceEvent> T* set_ext4_es_find_delayed_extent_range_exit() {
    return BeginNestedMessage<T>(151);
  }


  using FieldMetadata_Ext4EsInsertExtent =
    ::protozero::proto_utils::FieldMetadata<
      152,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4EsInsertExtentFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4EsInsertExtent kExt4EsInsertExtent() { return {}; }
  template <typename T = Ext4EsInsertExtentFtraceEvent> T* set_ext4_es_insert_extent() {
    return BeginNestedMessage<T>(152);
  }


  using FieldMetadata_Ext4EsLookupExtentEnter =
    ::protozero::proto_utils::FieldMetadata<
      153,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4EsLookupExtentEnterFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4EsLookupExtentEnter kExt4EsLookupExtentEnter() { return {}; }
  template <typename T = Ext4EsLookupExtentEnterFtraceEvent> T* set_ext4_es_lookup_extent_enter() {
    return BeginNestedMessage<T>(153);
  }


  using FieldMetadata_Ext4EsLookupExtentExit =
    ::protozero::proto_utils::FieldMetadata<
      154,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4EsLookupExtentExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4EsLookupExtentExit kExt4EsLookupExtentExit() { return {}; }
  template <typename T = Ext4EsLookupExtentExitFtraceEvent> T* set_ext4_es_lookup_extent_exit() {
    return BeginNestedMessage<T>(154);
  }


  using FieldMetadata_Ext4EsRemoveExtent =
    ::protozero::proto_utils::FieldMetadata<
      155,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4EsRemoveExtentFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4EsRemoveExtent kExt4EsRemoveExtent() { return {}; }
  template <typename T = Ext4EsRemoveExtentFtraceEvent> T* set_ext4_es_remove_extent() {
    return BeginNestedMessage<T>(155);
  }


  using FieldMetadata_Ext4EsShrink =
    ::protozero::proto_utils::FieldMetadata<
      156,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4EsShrinkFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4EsShrink kExt4EsShrink() { return {}; }
  template <typename T = Ext4EsShrinkFtraceEvent> T* set_ext4_es_shrink() {
    return BeginNestedMessage<T>(156);
  }


  using FieldMetadata_Ext4EsShrinkCount =
    ::protozero::proto_utils::FieldMetadata<
      157,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4EsShrinkCountFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4EsShrinkCount kExt4EsShrinkCount() { return {}; }
  template <typename T = Ext4EsShrinkCountFtraceEvent> T* set_ext4_es_shrink_count() {
    return BeginNestedMessage<T>(157);
  }


  using FieldMetadata_Ext4EsShrinkScanEnter =
    ::protozero::proto_utils::FieldMetadata<
      158,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4EsShrinkScanEnterFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4EsShrinkScanEnter kExt4EsShrinkScanEnter() { return {}; }
  template <typename T = Ext4EsShrinkScanEnterFtraceEvent> T* set_ext4_es_shrink_scan_enter() {
    return BeginNestedMessage<T>(158);
  }


  using FieldMetadata_Ext4EsShrinkScanExit =
    ::protozero::proto_utils::FieldMetadata<
      159,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4EsShrinkScanExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4EsShrinkScanExit kExt4EsShrinkScanExit() { return {}; }
  template <typename T = Ext4EsShrinkScanExitFtraceEvent> T* set_ext4_es_shrink_scan_exit() {
    return BeginNestedMessage<T>(159);
  }


  using FieldMetadata_Ext4EvictInode =
    ::protozero::proto_utils::FieldMetadata<
      160,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4EvictInodeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4EvictInode kExt4EvictInode() { return {}; }
  template <typename T = Ext4EvictInodeFtraceEvent> T* set_ext4_evict_inode() {
    return BeginNestedMessage<T>(160);
  }


  using FieldMetadata_Ext4ExtConvertToInitializedEnter =
    ::protozero::proto_utils::FieldMetadata<
      161,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4ExtConvertToInitializedEnterFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4ExtConvertToInitializedEnter kExt4ExtConvertToInitializedEnter() { return {}; }
  template <typename T = Ext4ExtConvertToInitializedEnterFtraceEvent> T* set_ext4_ext_convert_to_initialized_enter() {
    return BeginNestedMessage<T>(161);
  }


  using FieldMetadata_Ext4ExtConvertToInitializedFastpath =
    ::protozero::proto_utils::FieldMetadata<
      162,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4ExtConvertToInitializedFastpathFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4ExtConvertToInitializedFastpath kExt4ExtConvertToInitializedFastpath() { return {}; }
  template <typename T = Ext4ExtConvertToInitializedFastpathFtraceEvent> T* set_ext4_ext_convert_to_initialized_fastpath() {
    return BeginNestedMessage<T>(162);
  }


  using FieldMetadata_Ext4ExtHandleUnwrittenExtents =
    ::protozero::proto_utils::FieldMetadata<
      163,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4ExtHandleUnwrittenExtentsFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4ExtHandleUnwrittenExtents kExt4ExtHandleUnwrittenExtents() { return {}; }
  template <typename T = Ext4ExtHandleUnwrittenExtentsFtraceEvent> T* set_ext4_ext_handle_unwritten_extents() {
    return BeginNestedMessage<T>(163);
  }


  using FieldMetadata_Ext4ExtInCache =
    ::protozero::proto_utils::FieldMetadata<
      164,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4ExtInCacheFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4ExtInCache kExt4ExtInCache() { return {}; }
  template <typename T = Ext4ExtInCacheFtraceEvent> T* set_ext4_ext_in_cache() {
    return BeginNestedMessage<T>(164);
  }


  using FieldMetadata_Ext4ExtLoadExtent =
    ::protozero::proto_utils::FieldMetadata<
      165,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4ExtLoadExtentFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4ExtLoadExtent kExt4ExtLoadExtent() { return {}; }
  template <typename T = Ext4ExtLoadExtentFtraceEvent> T* set_ext4_ext_load_extent() {
    return BeginNestedMessage<T>(165);
  }


  using FieldMetadata_Ext4ExtMapBlocksEnter =
    ::protozero::proto_utils::FieldMetadata<
      166,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4ExtMapBlocksEnterFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4ExtMapBlocksEnter kExt4ExtMapBlocksEnter() { return {}; }
  template <typename T = Ext4ExtMapBlocksEnterFtraceEvent> T* set_ext4_ext_map_blocks_enter() {
    return BeginNestedMessage<T>(166);
  }


  using FieldMetadata_Ext4ExtMapBlocksExit =
    ::protozero::proto_utils::FieldMetadata<
      167,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4ExtMapBlocksExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4ExtMapBlocksExit kExt4ExtMapBlocksExit() { return {}; }
  template <typename T = Ext4ExtMapBlocksExitFtraceEvent> T* set_ext4_ext_map_blocks_exit() {
    return BeginNestedMessage<T>(167);
  }


  using FieldMetadata_Ext4ExtPutInCache =
    ::protozero::proto_utils::FieldMetadata<
      168,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4ExtPutInCacheFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4ExtPutInCache kExt4ExtPutInCache() { return {}; }
  template <typename T = Ext4ExtPutInCacheFtraceEvent> T* set_ext4_ext_put_in_cache() {
    return BeginNestedMessage<T>(168);
  }


  using FieldMetadata_Ext4ExtRemoveSpace =
    ::protozero::proto_utils::FieldMetadata<
      169,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4ExtRemoveSpaceFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4ExtRemoveSpace kExt4ExtRemoveSpace() { return {}; }
  template <typename T = Ext4ExtRemoveSpaceFtraceEvent> T* set_ext4_ext_remove_space() {
    return BeginNestedMessage<T>(169);
  }


  using FieldMetadata_Ext4ExtRemoveSpaceDone =
    ::protozero::proto_utils::FieldMetadata<
      170,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4ExtRemoveSpaceDoneFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4ExtRemoveSpaceDone kExt4ExtRemoveSpaceDone() { return {}; }
  template <typename T = Ext4ExtRemoveSpaceDoneFtraceEvent> T* set_ext4_ext_remove_space_done() {
    return BeginNestedMessage<T>(170);
  }


  using FieldMetadata_Ext4ExtRmIdx =
    ::protozero::proto_utils::FieldMetadata<
      171,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4ExtRmIdxFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4ExtRmIdx kExt4ExtRmIdx() { return {}; }
  template <typename T = Ext4ExtRmIdxFtraceEvent> T* set_ext4_ext_rm_idx() {
    return BeginNestedMessage<T>(171);
  }


  using FieldMetadata_Ext4ExtRmLeaf =
    ::protozero::proto_utils::FieldMetadata<
      172,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4ExtRmLeafFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4ExtRmLeaf kExt4ExtRmLeaf() { return {}; }
  template <typename T = Ext4ExtRmLeafFtraceEvent> T* set_ext4_ext_rm_leaf() {
    return BeginNestedMessage<T>(172);
  }


  using FieldMetadata_Ext4ExtShowExtent =
    ::protozero::proto_utils::FieldMetadata<
      173,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4ExtShowExtentFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4ExtShowExtent kExt4ExtShowExtent() { return {}; }
  template <typename T = Ext4ExtShowExtentFtraceEvent> T* set_ext4_ext_show_extent() {
    return BeginNestedMessage<T>(173);
  }


  using FieldMetadata_Ext4FallocateEnter =
    ::protozero::proto_utils::FieldMetadata<
      174,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4FallocateEnterFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4FallocateEnter kExt4FallocateEnter() { return {}; }
  template <typename T = Ext4FallocateEnterFtraceEvent> T* set_ext4_fallocate_enter() {
    return BeginNestedMessage<T>(174);
  }


  using FieldMetadata_Ext4FallocateExit =
    ::protozero::proto_utils::FieldMetadata<
      175,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4FallocateExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4FallocateExit kExt4FallocateExit() { return {}; }
  template <typename T = Ext4FallocateExitFtraceEvent> T* set_ext4_fallocate_exit() {
    return BeginNestedMessage<T>(175);
  }


  using FieldMetadata_Ext4FindDelallocRange =
    ::protozero::proto_utils::FieldMetadata<
      176,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4FindDelallocRangeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4FindDelallocRange kExt4FindDelallocRange() { return {}; }
  template <typename T = Ext4FindDelallocRangeFtraceEvent> T* set_ext4_find_delalloc_range() {
    return BeginNestedMessage<T>(176);
  }


  using FieldMetadata_Ext4Forget =
    ::protozero::proto_utils::FieldMetadata<
      177,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4ForgetFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4Forget kExt4Forget() { return {}; }
  template <typename T = Ext4ForgetFtraceEvent> T* set_ext4_forget() {
    return BeginNestedMessage<T>(177);
  }


  using FieldMetadata_Ext4FreeBlocks =
    ::protozero::proto_utils::FieldMetadata<
      178,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4FreeBlocksFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4FreeBlocks kExt4FreeBlocks() { return {}; }
  template <typename T = Ext4FreeBlocksFtraceEvent> T* set_ext4_free_blocks() {
    return BeginNestedMessage<T>(178);
  }


  using FieldMetadata_Ext4FreeInode =
    ::protozero::proto_utils::FieldMetadata<
      179,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4FreeInodeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4FreeInode kExt4FreeInode() { return {}; }
  template <typename T = Ext4FreeInodeFtraceEvent> T* set_ext4_free_inode() {
    return BeginNestedMessage<T>(179);
  }


  using FieldMetadata_Ext4GetImpliedClusterAllocExit =
    ::protozero::proto_utils::FieldMetadata<
      180,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4GetImpliedClusterAllocExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4GetImpliedClusterAllocExit kExt4GetImpliedClusterAllocExit() { return {}; }
  template <typename T = Ext4GetImpliedClusterAllocExitFtraceEvent> T* set_ext4_get_implied_cluster_alloc_exit() {
    return BeginNestedMessage<T>(180);
  }


  using FieldMetadata_Ext4GetReservedClusterAlloc =
    ::protozero::proto_utils::FieldMetadata<
      181,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4GetReservedClusterAllocFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4GetReservedClusterAlloc kExt4GetReservedClusterAlloc() { return {}; }
  template <typename T = Ext4GetReservedClusterAllocFtraceEvent> T* set_ext4_get_reserved_cluster_alloc() {
    return BeginNestedMessage<T>(181);
  }


  using FieldMetadata_Ext4IndMapBlocksEnter =
    ::protozero::proto_utils::FieldMetadata<
      182,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4IndMapBlocksEnterFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4IndMapBlocksEnter kExt4IndMapBlocksEnter() { return {}; }
  template <typename T = Ext4IndMapBlocksEnterFtraceEvent> T* set_ext4_ind_map_blocks_enter() {
    return BeginNestedMessage<T>(182);
  }


  using FieldMetadata_Ext4IndMapBlocksExit =
    ::protozero::proto_utils::FieldMetadata<
      183,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4IndMapBlocksExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4IndMapBlocksExit kExt4IndMapBlocksExit() { return {}; }
  template <typename T = Ext4IndMapBlocksExitFtraceEvent> T* set_ext4_ind_map_blocks_exit() {
    return BeginNestedMessage<T>(183);
  }


  using FieldMetadata_Ext4InsertRange =
    ::protozero::proto_utils::FieldMetadata<
      184,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4InsertRangeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4InsertRange kExt4InsertRange() { return {}; }
  template <typename T = Ext4InsertRangeFtraceEvent> T* set_ext4_insert_range() {
    return BeginNestedMessage<T>(184);
  }


  using FieldMetadata_Ext4Invalidatepage =
    ::protozero::proto_utils::FieldMetadata<
      185,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4InvalidatepageFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4Invalidatepage kExt4Invalidatepage() { return {}; }
  template <typename T = Ext4InvalidatepageFtraceEvent> T* set_ext4_invalidatepage() {
    return BeginNestedMessage<T>(185);
  }


  using FieldMetadata_Ext4JournalStart =
    ::protozero::proto_utils::FieldMetadata<
      186,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4JournalStartFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4JournalStart kExt4JournalStart() { return {}; }
  template <typename T = Ext4JournalStartFtraceEvent> T* set_ext4_journal_start() {
    return BeginNestedMessage<T>(186);
  }


  using FieldMetadata_Ext4JournalStartReserved =
    ::protozero::proto_utils::FieldMetadata<
      187,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4JournalStartReservedFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4JournalStartReserved kExt4JournalStartReserved() { return {}; }
  template <typename T = Ext4JournalStartReservedFtraceEvent> T* set_ext4_journal_start_reserved() {
    return BeginNestedMessage<T>(187);
  }


  using FieldMetadata_Ext4JournalledInvalidatepage =
    ::protozero::proto_utils::FieldMetadata<
      188,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4JournalledInvalidatepageFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4JournalledInvalidatepage kExt4JournalledInvalidatepage() { return {}; }
  template <typename T = Ext4JournalledInvalidatepageFtraceEvent> T* set_ext4_journalled_invalidatepage() {
    return BeginNestedMessage<T>(188);
  }


  using FieldMetadata_Ext4JournalledWriteEnd =
    ::protozero::proto_utils::FieldMetadata<
      189,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4JournalledWriteEndFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4JournalledWriteEnd kExt4JournalledWriteEnd() { return {}; }
  template <typename T = Ext4JournalledWriteEndFtraceEvent> T* set_ext4_journalled_write_end() {
    return BeginNestedMessage<T>(189);
  }


  using FieldMetadata_Ext4LoadInode =
    ::protozero::proto_utils::FieldMetadata<
      190,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4LoadInodeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4LoadInode kExt4LoadInode() { return {}; }
  template <typename T = Ext4LoadInodeFtraceEvent> T* set_ext4_load_inode() {
    return BeginNestedMessage<T>(190);
  }


  using FieldMetadata_Ext4LoadInodeBitmap =
    ::protozero::proto_utils::FieldMetadata<
      191,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4LoadInodeBitmapFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4LoadInodeBitmap kExt4LoadInodeBitmap() { return {}; }
  template <typename T = Ext4LoadInodeBitmapFtraceEvent> T* set_ext4_load_inode_bitmap() {
    return BeginNestedMessage<T>(191);
  }


  using FieldMetadata_Ext4MarkInodeDirty =
    ::protozero::proto_utils::FieldMetadata<
      192,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4MarkInodeDirtyFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4MarkInodeDirty kExt4MarkInodeDirty() { return {}; }
  template <typename T = Ext4MarkInodeDirtyFtraceEvent> T* set_ext4_mark_inode_dirty() {
    return BeginNestedMessage<T>(192);
  }


  using FieldMetadata_Ext4MbBitmapLoad =
    ::protozero::proto_utils::FieldMetadata<
      193,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4MbBitmapLoadFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4MbBitmapLoad kExt4MbBitmapLoad() { return {}; }
  template <typename T = Ext4MbBitmapLoadFtraceEvent> T* set_ext4_mb_bitmap_load() {
    return BeginNestedMessage<T>(193);
  }


  using FieldMetadata_Ext4MbBuddyBitmapLoad =
    ::protozero::proto_utils::FieldMetadata<
      194,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4MbBuddyBitmapLoadFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4MbBuddyBitmapLoad kExt4MbBuddyBitmapLoad() { return {}; }
  template <typename T = Ext4MbBuddyBitmapLoadFtraceEvent> T* set_ext4_mb_buddy_bitmap_load() {
    return BeginNestedMessage<T>(194);
  }


  using FieldMetadata_Ext4MbDiscardPreallocations =
    ::protozero::proto_utils::FieldMetadata<
      195,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4MbDiscardPreallocationsFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4MbDiscardPreallocations kExt4MbDiscardPreallocations() { return {}; }
  template <typename T = Ext4MbDiscardPreallocationsFtraceEvent> T* set_ext4_mb_discard_preallocations() {
    return BeginNestedMessage<T>(195);
  }


  using FieldMetadata_Ext4MbNewGroupPa =
    ::protozero::proto_utils::FieldMetadata<
      196,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4MbNewGroupPaFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4MbNewGroupPa kExt4MbNewGroupPa() { return {}; }
  template <typename T = Ext4MbNewGroupPaFtraceEvent> T* set_ext4_mb_new_group_pa() {
    return BeginNestedMessage<T>(196);
  }


  using FieldMetadata_Ext4MbNewInodePa =
    ::protozero::proto_utils::FieldMetadata<
      197,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4MbNewInodePaFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4MbNewInodePa kExt4MbNewInodePa() { return {}; }
  template <typename T = Ext4MbNewInodePaFtraceEvent> T* set_ext4_mb_new_inode_pa() {
    return BeginNestedMessage<T>(197);
  }


  using FieldMetadata_Ext4MbReleaseGroupPa =
    ::protozero::proto_utils::FieldMetadata<
      198,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4MbReleaseGroupPaFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4MbReleaseGroupPa kExt4MbReleaseGroupPa() { return {}; }
  template <typename T = Ext4MbReleaseGroupPaFtraceEvent> T* set_ext4_mb_release_group_pa() {
    return BeginNestedMessage<T>(198);
  }


  using FieldMetadata_Ext4MbReleaseInodePa =
    ::protozero::proto_utils::FieldMetadata<
      199,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4MbReleaseInodePaFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4MbReleaseInodePa kExt4MbReleaseInodePa() { return {}; }
  template <typename T = Ext4MbReleaseInodePaFtraceEvent> T* set_ext4_mb_release_inode_pa() {
    return BeginNestedMessage<T>(199);
  }


  using FieldMetadata_Ext4MballocAlloc =
    ::protozero::proto_utils::FieldMetadata<
      200,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4MballocAllocFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4MballocAlloc kExt4MballocAlloc() { return {}; }
  template <typename T = Ext4MballocAllocFtraceEvent> T* set_ext4_mballoc_alloc() {
    return BeginNestedMessage<T>(200);
  }


  using FieldMetadata_Ext4MballocDiscard =
    ::protozero::proto_utils::FieldMetadata<
      201,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4MballocDiscardFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4MballocDiscard kExt4MballocDiscard() { return {}; }
  template <typename T = Ext4MballocDiscardFtraceEvent> T* set_ext4_mballoc_discard() {
    return BeginNestedMessage<T>(201);
  }


  using FieldMetadata_Ext4MballocFree =
    ::protozero::proto_utils::FieldMetadata<
      202,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4MballocFreeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4MballocFree kExt4MballocFree() { return {}; }
  template <typename T = Ext4MballocFreeFtraceEvent> T* set_ext4_mballoc_free() {
    return BeginNestedMessage<T>(202);
  }


  using FieldMetadata_Ext4MballocPrealloc =
    ::protozero::proto_utils::FieldMetadata<
      203,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4MballocPreallocFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4MballocPrealloc kExt4MballocPrealloc() { return {}; }
  template <typename T = Ext4MballocPreallocFtraceEvent> T* set_ext4_mballoc_prealloc() {
    return BeginNestedMessage<T>(203);
  }


  using FieldMetadata_Ext4OtherInodeUpdateTime =
    ::protozero::proto_utils::FieldMetadata<
      204,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4OtherInodeUpdateTimeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4OtherInodeUpdateTime kExt4OtherInodeUpdateTime() { return {}; }
  template <typename T = Ext4OtherInodeUpdateTimeFtraceEvent> T* set_ext4_other_inode_update_time() {
    return BeginNestedMessage<T>(204);
  }


  using FieldMetadata_Ext4PunchHole =
    ::protozero::proto_utils::FieldMetadata<
      205,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4PunchHoleFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4PunchHole kExt4PunchHole() { return {}; }
  template <typename T = Ext4PunchHoleFtraceEvent> T* set_ext4_punch_hole() {
    return BeginNestedMessage<T>(205);
  }


  using FieldMetadata_Ext4ReadBlockBitmapLoad =
    ::protozero::proto_utils::FieldMetadata<
      206,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4ReadBlockBitmapLoadFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4ReadBlockBitmapLoad kExt4ReadBlockBitmapLoad() { return {}; }
  template <typename T = Ext4ReadBlockBitmapLoadFtraceEvent> T* set_ext4_read_block_bitmap_load() {
    return BeginNestedMessage<T>(206);
  }


  using FieldMetadata_Ext4Readpage =
    ::protozero::proto_utils::FieldMetadata<
      207,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4ReadpageFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4Readpage kExt4Readpage() { return {}; }
  template <typename T = Ext4ReadpageFtraceEvent> T* set_ext4_readpage() {
    return BeginNestedMessage<T>(207);
  }


  using FieldMetadata_Ext4Releasepage =
    ::protozero::proto_utils::FieldMetadata<
      208,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4ReleasepageFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4Releasepage kExt4Releasepage() { return {}; }
  template <typename T = Ext4ReleasepageFtraceEvent> T* set_ext4_releasepage() {
    return BeginNestedMessage<T>(208);
  }


  using FieldMetadata_Ext4RemoveBlocks =
    ::protozero::proto_utils::FieldMetadata<
      209,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4RemoveBlocksFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4RemoveBlocks kExt4RemoveBlocks() { return {}; }
  template <typename T = Ext4RemoveBlocksFtraceEvent> T* set_ext4_remove_blocks() {
    return BeginNestedMessage<T>(209);
  }


  using FieldMetadata_Ext4RequestBlocks =
    ::protozero::proto_utils::FieldMetadata<
      210,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4RequestBlocksFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4RequestBlocks kExt4RequestBlocks() { return {}; }
  template <typename T = Ext4RequestBlocksFtraceEvent> T* set_ext4_request_blocks() {
    return BeginNestedMessage<T>(210);
  }


  using FieldMetadata_Ext4RequestInode =
    ::protozero::proto_utils::FieldMetadata<
      211,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4RequestInodeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4RequestInode kExt4RequestInode() { return {}; }
  template <typename T = Ext4RequestInodeFtraceEvent> T* set_ext4_request_inode() {
    return BeginNestedMessage<T>(211);
  }


  using FieldMetadata_Ext4SyncFs =
    ::protozero::proto_utils::FieldMetadata<
      212,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4SyncFsFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4SyncFs kExt4SyncFs() { return {}; }
  template <typename T = Ext4SyncFsFtraceEvent> T* set_ext4_sync_fs() {
    return BeginNestedMessage<T>(212);
  }


  using FieldMetadata_Ext4TrimAllFree =
    ::protozero::proto_utils::FieldMetadata<
      213,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4TrimAllFreeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4TrimAllFree kExt4TrimAllFree() { return {}; }
  template <typename T = Ext4TrimAllFreeFtraceEvent> T* set_ext4_trim_all_free() {
    return BeginNestedMessage<T>(213);
  }


  using FieldMetadata_Ext4TrimExtent =
    ::protozero::proto_utils::FieldMetadata<
      214,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4TrimExtentFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4TrimExtent kExt4TrimExtent() { return {}; }
  template <typename T = Ext4TrimExtentFtraceEvent> T* set_ext4_trim_extent() {
    return BeginNestedMessage<T>(214);
  }


  using FieldMetadata_Ext4TruncateEnter =
    ::protozero::proto_utils::FieldMetadata<
      215,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4TruncateEnterFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4TruncateEnter kExt4TruncateEnter() { return {}; }
  template <typename T = Ext4TruncateEnterFtraceEvent> T* set_ext4_truncate_enter() {
    return BeginNestedMessage<T>(215);
  }


  using FieldMetadata_Ext4TruncateExit =
    ::protozero::proto_utils::FieldMetadata<
      216,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4TruncateExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4TruncateExit kExt4TruncateExit() { return {}; }
  template <typename T = Ext4TruncateExitFtraceEvent> T* set_ext4_truncate_exit() {
    return BeginNestedMessage<T>(216);
  }


  using FieldMetadata_Ext4UnlinkEnter =
    ::protozero::proto_utils::FieldMetadata<
      217,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4UnlinkEnterFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4UnlinkEnter kExt4UnlinkEnter() { return {}; }
  template <typename T = Ext4UnlinkEnterFtraceEvent> T* set_ext4_unlink_enter() {
    return BeginNestedMessage<T>(217);
  }


  using FieldMetadata_Ext4UnlinkExit =
    ::protozero::proto_utils::FieldMetadata<
      218,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4UnlinkExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4UnlinkExit kExt4UnlinkExit() { return {}; }
  template <typename T = Ext4UnlinkExitFtraceEvent> T* set_ext4_unlink_exit() {
    return BeginNestedMessage<T>(218);
  }


  using FieldMetadata_Ext4WriteBegin =
    ::protozero::proto_utils::FieldMetadata<
      219,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4WriteBeginFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4WriteBegin kExt4WriteBegin() { return {}; }
  template <typename T = Ext4WriteBeginFtraceEvent> T* set_ext4_write_begin() {
    return BeginNestedMessage<T>(219);
  }


  using FieldMetadata_Ext4WriteEnd =
    ::protozero::proto_utils::FieldMetadata<
      230,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4WriteEndFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4WriteEnd kExt4WriteEnd() { return {}; }
  template <typename T = Ext4WriteEndFtraceEvent> T* set_ext4_write_end() {
    return BeginNestedMessage<T>(230);
  }


  using FieldMetadata_Ext4Writepage =
    ::protozero::proto_utils::FieldMetadata<
      231,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4WritepageFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4Writepage kExt4Writepage() { return {}; }
  template <typename T = Ext4WritepageFtraceEvent> T* set_ext4_writepage() {
    return BeginNestedMessage<T>(231);
  }


  using FieldMetadata_Ext4Writepages =
    ::protozero::proto_utils::FieldMetadata<
      232,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4WritepagesFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4Writepages kExt4Writepages() { return {}; }
  template <typename T = Ext4WritepagesFtraceEvent> T* set_ext4_writepages() {
    return BeginNestedMessage<T>(232);
  }


  using FieldMetadata_Ext4WritepagesResult =
    ::protozero::proto_utils::FieldMetadata<
      233,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4WritepagesResultFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4WritepagesResult kExt4WritepagesResult() { return {}; }
  template <typename T = Ext4WritepagesResultFtraceEvent> T* set_ext4_writepages_result() {
    return BeginNestedMessage<T>(233);
  }


  using FieldMetadata_Ext4ZeroRange =
    ::protozero::proto_utils::FieldMetadata<
      234,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      Ext4ZeroRangeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Ext4ZeroRange kExt4ZeroRange() { return {}; }
  template <typename T = Ext4ZeroRangeFtraceEvent> T* set_ext4_zero_range() {
    return BeginNestedMessage<T>(234);
  }


  using FieldMetadata_TaskNewtask =
    ::protozero::proto_utils::FieldMetadata<
      235,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TaskNewtaskFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_TaskNewtask kTaskNewtask() { return {}; }
  template <typename T = TaskNewtaskFtraceEvent> T* set_task_newtask() {
    return BeginNestedMessage<T>(235);
  }


  using FieldMetadata_TaskRename =
    ::protozero::proto_utils::FieldMetadata<
      236,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TaskRenameFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_TaskRename kTaskRename() { return {}; }
  template <typename T = TaskRenameFtraceEvent> T* set_task_rename() {
    return BeginNestedMessage<T>(236);
  }


  using FieldMetadata_SchedProcessExec =
    ::protozero::proto_utils::FieldMetadata<
      237,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SchedProcessExecFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SchedProcessExec kSchedProcessExec() { return {}; }
  template <typename T = SchedProcessExecFtraceEvent> T* set_sched_process_exec() {
    return BeginNestedMessage<T>(237);
  }


  using FieldMetadata_SchedProcessExit =
    ::protozero::proto_utils::FieldMetadata<
      238,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SchedProcessExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SchedProcessExit kSchedProcessExit() { return {}; }
  template <typename T = SchedProcessExitFtraceEvent> T* set_sched_process_exit() {
    return BeginNestedMessage<T>(238);
  }


  using FieldMetadata_SchedProcessFork =
    ::protozero::proto_utils::FieldMetadata<
      239,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SchedProcessForkFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SchedProcessFork kSchedProcessFork() { return {}; }
  template <typename T = SchedProcessForkFtraceEvent> T* set_sched_process_fork() {
    return BeginNestedMessage<T>(239);
  }


  using FieldMetadata_SchedProcessFree =
    ::protozero::proto_utils::FieldMetadata<
      240,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SchedProcessFreeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SchedProcessFree kSchedProcessFree() { return {}; }
  template <typename T = SchedProcessFreeFtraceEvent> T* set_sched_process_free() {
    return BeginNestedMessage<T>(240);
  }


  using FieldMetadata_SchedProcessHang =
    ::protozero::proto_utils::FieldMetadata<
      241,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SchedProcessHangFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SchedProcessHang kSchedProcessHang() { return {}; }
  template <typename T = SchedProcessHangFtraceEvent> T* set_sched_process_hang() {
    return BeginNestedMessage<T>(241);
  }


  using FieldMetadata_SchedProcessWait =
    ::protozero::proto_utils::FieldMetadata<
      242,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SchedProcessWaitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SchedProcessWait kSchedProcessWait() { return {}; }
  template <typename T = SchedProcessWaitFtraceEvent> T* set_sched_process_wait() {
    return BeginNestedMessage<T>(242);
  }


  using FieldMetadata_F2fsDoSubmitBio =
    ::protozero::proto_utils::FieldMetadata<
      243,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsDoSubmitBioFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsDoSubmitBio kF2fsDoSubmitBio() { return {}; }
  template <typename T = F2fsDoSubmitBioFtraceEvent> T* set_f2fs_do_submit_bio() {
    return BeginNestedMessage<T>(243);
  }


  using FieldMetadata_F2fsEvictInode =
    ::protozero::proto_utils::FieldMetadata<
      244,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsEvictInodeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsEvictInode kF2fsEvictInode() { return {}; }
  template <typename T = F2fsEvictInodeFtraceEvent> T* set_f2fs_evict_inode() {
    return BeginNestedMessage<T>(244);
  }


  using FieldMetadata_F2fsFallocate =
    ::protozero::proto_utils::FieldMetadata<
      245,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsFallocateFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsFallocate kF2fsFallocate() { return {}; }
  template <typename T = F2fsFallocateFtraceEvent> T* set_f2fs_fallocate() {
    return BeginNestedMessage<T>(245);
  }


  using FieldMetadata_F2fsGetDataBlock =
    ::protozero::proto_utils::FieldMetadata<
      246,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsGetDataBlockFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsGetDataBlock kF2fsGetDataBlock() { return {}; }
  template <typename T = F2fsGetDataBlockFtraceEvent> T* set_f2fs_get_data_block() {
    return BeginNestedMessage<T>(246);
  }


  using FieldMetadata_F2fsGetVictim =
    ::protozero::proto_utils::FieldMetadata<
      247,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsGetVictimFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsGetVictim kF2fsGetVictim() { return {}; }
  template <typename T = F2fsGetVictimFtraceEvent> T* set_f2fs_get_victim() {
    return BeginNestedMessage<T>(247);
  }


  using FieldMetadata_F2fsIget =
    ::protozero::proto_utils::FieldMetadata<
      248,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsIgetFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsIget kF2fsIget() { return {}; }
  template <typename T = F2fsIgetFtraceEvent> T* set_f2fs_iget() {
    return BeginNestedMessage<T>(248);
  }


  using FieldMetadata_F2fsIgetExit =
    ::protozero::proto_utils::FieldMetadata<
      249,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsIgetExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsIgetExit kF2fsIgetExit() { return {}; }
  template <typename T = F2fsIgetExitFtraceEvent> T* set_f2fs_iget_exit() {
    return BeginNestedMessage<T>(249);
  }


  using FieldMetadata_F2fsNewInode =
    ::protozero::proto_utils::FieldMetadata<
      250,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsNewInodeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsNewInode kF2fsNewInode() { return {}; }
  template <typename T = F2fsNewInodeFtraceEvent> T* set_f2fs_new_inode() {
    return BeginNestedMessage<T>(250);
  }


  using FieldMetadata_F2fsReadpage =
    ::protozero::proto_utils::FieldMetadata<
      251,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsReadpageFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsReadpage kF2fsReadpage() { return {}; }
  template <typename T = F2fsReadpageFtraceEvent> T* set_f2fs_readpage() {
    return BeginNestedMessage<T>(251);
  }


  using FieldMetadata_F2fsReserveNewBlock =
    ::protozero::proto_utils::FieldMetadata<
      252,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsReserveNewBlockFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsReserveNewBlock kF2fsReserveNewBlock() { return {}; }
  template <typename T = F2fsReserveNewBlockFtraceEvent> T* set_f2fs_reserve_new_block() {
    return BeginNestedMessage<T>(252);
  }


  using FieldMetadata_F2fsSetPageDirty =
    ::protozero::proto_utils::FieldMetadata<
      253,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsSetPageDirtyFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsSetPageDirty kF2fsSetPageDirty() { return {}; }
  template <typename T = F2fsSetPageDirtyFtraceEvent> T* set_f2fs_set_page_dirty() {
    return BeginNestedMessage<T>(253);
  }


  using FieldMetadata_F2fsSubmitWritePage =
    ::protozero::proto_utils::FieldMetadata<
      254,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsSubmitWritePageFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsSubmitWritePage kF2fsSubmitWritePage() { return {}; }
  template <typename T = F2fsSubmitWritePageFtraceEvent> T* set_f2fs_submit_write_page() {
    return BeginNestedMessage<T>(254);
  }


  using FieldMetadata_F2fsSyncFileEnter =
    ::protozero::proto_utils::FieldMetadata<
      255,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsSyncFileEnterFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsSyncFileEnter kF2fsSyncFileEnter() { return {}; }
  template <typename T = F2fsSyncFileEnterFtraceEvent> T* set_f2fs_sync_file_enter() {
    return BeginNestedMessage<T>(255);
  }


  using FieldMetadata_F2fsSyncFileExit =
    ::protozero::proto_utils::FieldMetadata<
      256,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsSyncFileExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsSyncFileExit kF2fsSyncFileExit() { return {}; }
  template <typename T = F2fsSyncFileExitFtraceEvent> T* set_f2fs_sync_file_exit() {
    return BeginNestedMessage<T>(256);
  }


  using FieldMetadata_F2fsSyncFs =
    ::protozero::proto_utils::FieldMetadata<
      257,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsSyncFsFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsSyncFs kF2fsSyncFs() { return {}; }
  template <typename T = F2fsSyncFsFtraceEvent> T* set_f2fs_sync_fs() {
    return BeginNestedMessage<T>(257);
  }


  using FieldMetadata_F2fsTruncate =
    ::protozero::proto_utils::FieldMetadata<
      258,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsTruncateFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsTruncate kF2fsTruncate() { return {}; }
  template <typename T = F2fsTruncateFtraceEvent> T* set_f2fs_truncate() {
    return BeginNestedMessage<T>(258);
  }


  using FieldMetadata_F2fsTruncateBlocksEnter =
    ::protozero::proto_utils::FieldMetadata<
      259,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsTruncateBlocksEnterFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsTruncateBlocksEnter kF2fsTruncateBlocksEnter() { return {}; }
  template <typename T = F2fsTruncateBlocksEnterFtraceEvent> T* set_f2fs_truncate_blocks_enter() {
    return BeginNestedMessage<T>(259);
  }


  using FieldMetadata_F2fsTruncateBlocksExit =
    ::protozero::proto_utils::FieldMetadata<
      260,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsTruncateBlocksExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsTruncateBlocksExit kF2fsTruncateBlocksExit() { return {}; }
  template <typename T = F2fsTruncateBlocksExitFtraceEvent> T* set_f2fs_truncate_blocks_exit() {
    return BeginNestedMessage<T>(260);
  }


  using FieldMetadata_F2fsTruncateDataBlocksRange =
    ::protozero::proto_utils::FieldMetadata<
      261,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsTruncateDataBlocksRangeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsTruncateDataBlocksRange kF2fsTruncateDataBlocksRange() { return {}; }
  template <typename T = F2fsTruncateDataBlocksRangeFtraceEvent> T* set_f2fs_truncate_data_blocks_range() {
    return BeginNestedMessage<T>(261);
  }


  using FieldMetadata_F2fsTruncateInodeBlocksEnter =
    ::protozero::proto_utils::FieldMetadata<
      262,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsTruncateInodeBlocksEnterFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsTruncateInodeBlocksEnter kF2fsTruncateInodeBlocksEnter() { return {}; }
  template <typename T = F2fsTruncateInodeBlocksEnterFtraceEvent> T* set_f2fs_truncate_inode_blocks_enter() {
    return BeginNestedMessage<T>(262);
  }


  using FieldMetadata_F2fsTruncateInodeBlocksExit =
    ::protozero::proto_utils::FieldMetadata<
      263,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsTruncateInodeBlocksExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsTruncateInodeBlocksExit kF2fsTruncateInodeBlocksExit() { return {}; }
  template <typename T = F2fsTruncateInodeBlocksExitFtraceEvent> T* set_f2fs_truncate_inode_blocks_exit() {
    return BeginNestedMessage<T>(263);
  }


  using FieldMetadata_F2fsTruncateNode =
    ::protozero::proto_utils::FieldMetadata<
      264,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsTruncateNodeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsTruncateNode kF2fsTruncateNode() { return {}; }
  template <typename T = F2fsTruncateNodeFtraceEvent> T* set_f2fs_truncate_node() {
    return BeginNestedMessage<T>(264);
  }


  using FieldMetadata_F2fsTruncateNodesEnter =
    ::protozero::proto_utils::FieldMetadata<
      265,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsTruncateNodesEnterFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsTruncateNodesEnter kF2fsTruncateNodesEnter() { return {}; }
  template <typename T = F2fsTruncateNodesEnterFtraceEvent> T* set_f2fs_truncate_nodes_enter() {
    return BeginNestedMessage<T>(265);
  }


  using FieldMetadata_F2fsTruncateNodesExit =
    ::protozero::proto_utils::FieldMetadata<
      266,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsTruncateNodesExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsTruncateNodesExit kF2fsTruncateNodesExit() { return {}; }
  template <typename T = F2fsTruncateNodesExitFtraceEvent> T* set_f2fs_truncate_nodes_exit() {
    return BeginNestedMessage<T>(266);
  }


  using FieldMetadata_F2fsTruncatePartialNodes =
    ::protozero::proto_utils::FieldMetadata<
      267,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsTruncatePartialNodesFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsTruncatePartialNodes kF2fsTruncatePartialNodes() { return {}; }
  template <typename T = F2fsTruncatePartialNodesFtraceEvent> T* set_f2fs_truncate_partial_nodes() {
    return BeginNestedMessage<T>(267);
  }


  using FieldMetadata_F2fsUnlinkEnter =
    ::protozero::proto_utils::FieldMetadata<
      268,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsUnlinkEnterFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsUnlinkEnter kF2fsUnlinkEnter() { return {}; }
  template <typename T = F2fsUnlinkEnterFtraceEvent> T* set_f2fs_unlink_enter() {
    return BeginNestedMessage<T>(268);
  }


  using FieldMetadata_F2fsUnlinkExit =
    ::protozero::proto_utils::FieldMetadata<
      269,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsUnlinkExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsUnlinkExit kF2fsUnlinkExit() { return {}; }
  template <typename T = F2fsUnlinkExitFtraceEvent> T* set_f2fs_unlink_exit() {
    return BeginNestedMessage<T>(269);
  }


  using FieldMetadata_F2fsVmPageMkwrite =
    ::protozero::proto_utils::FieldMetadata<
      270,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsVmPageMkwriteFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsVmPageMkwrite kF2fsVmPageMkwrite() { return {}; }
  template <typename T = F2fsVmPageMkwriteFtraceEvent> T* set_f2fs_vm_page_mkwrite() {
    return BeginNestedMessage<T>(270);
  }


  using FieldMetadata_F2fsWriteBegin =
    ::protozero::proto_utils::FieldMetadata<
      271,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsWriteBeginFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsWriteBegin kF2fsWriteBegin() { return {}; }
  template <typename T = F2fsWriteBeginFtraceEvent> T* set_f2fs_write_begin() {
    return BeginNestedMessage<T>(271);
  }


  using FieldMetadata_F2fsWriteCheckpoint =
    ::protozero::proto_utils::FieldMetadata<
      272,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsWriteCheckpointFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsWriteCheckpoint kF2fsWriteCheckpoint() { return {}; }
  template <typename T = F2fsWriteCheckpointFtraceEvent> T* set_f2fs_write_checkpoint() {
    return BeginNestedMessage<T>(272);
  }


  using FieldMetadata_F2fsWriteEnd =
    ::protozero::proto_utils::FieldMetadata<
      273,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      F2fsWriteEndFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_F2fsWriteEnd kF2fsWriteEnd() { return {}; }
  template <typename T = F2fsWriteEndFtraceEvent> T* set_f2fs_write_end() {
    return BeginNestedMessage<T>(273);
  }


  using FieldMetadata_AllocPagesIommuEnd =
    ::protozero::proto_utils::FieldMetadata<
      274,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      AllocPagesIommuEndFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_AllocPagesIommuEnd kAllocPagesIommuEnd() { return {}; }
  template <typename T = AllocPagesIommuEndFtraceEvent> T* set_alloc_pages_iommu_end() {
    return BeginNestedMessage<T>(274);
  }


  using FieldMetadata_AllocPagesIommuFail =
    ::protozero::proto_utils::FieldMetadata<
      275,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      AllocPagesIommuFailFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_AllocPagesIommuFail kAllocPagesIommuFail() { return {}; }
  template <typename T = AllocPagesIommuFailFtraceEvent> T* set_alloc_pages_iommu_fail() {
    return BeginNestedMessage<T>(275);
  }


  using FieldMetadata_AllocPagesIommuStart =
    ::protozero::proto_utils::FieldMetadata<
      276,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      AllocPagesIommuStartFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_AllocPagesIommuStart kAllocPagesIommuStart() { return {}; }
  template <typename T = AllocPagesIommuStartFtraceEvent> T* set_alloc_pages_iommu_start() {
    return BeginNestedMessage<T>(276);
  }


  using FieldMetadata_AllocPagesSysEnd =
    ::protozero::proto_utils::FieldMetadata<
      277,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      AllocPagesSysEndFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_AllocPagesSysEnd kAllocPagesSysEnd() { return {}; }
  template <typename T = AllocPagesSysEndFtraceEvent> T* set_alloc_pages_sys_end() {
    return BeginNestedMessage<T>(277);
  }


  using FieldMetadata_AllocPagesSysFail =
    ::protozero::proto_utils::FieldMetadata<
      278,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      AllocPagesSysFailFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_AllocPagesSysFail kAllocPagesSysFail() { return {}; }
  template <typename T = AllocPagesSysFailFtraceEvent> T* set_alloc_pages_sys_fail() {
    return BeginNestedMessage<T>(278);
  }


  using FieldMetadata_AllocPagesSysStart =
    ::protozero::proto_utils::FieldMetadata<
      279,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      AllocPagesSysStartFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_AllocPagesSysStart kAllocPagesSysStart() { return {}; }
  template <typename T = AllocPagesSysStartFtraceEvent> T* set_alloc_pages_sys_start() {
    return BeginNestedMessage<T>(279);
  }


  using FieldMetadata_DmaAllocContiguousRetry =
    ::protozero::proto_utils::FieldMetadata<
      280,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DmaAllocContiguousRetryFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DmaAllocContiguousRetry kDmaAllocContiguousRetry() { return {}; }
  template <typename T = DmaAllocContiguousRetryFtraceEvent> T* set_dma_alloc_contiguous_retry() {
    return BeginNestedMessage<T>(280);
  }


  using FieldMetadata_IommuMapRange =
    ::protozero::proto_utils::FieldMetadata<
      281,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IommuMapRangeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IommuMapRange kIommuMapRange() { return {}; }
  template <typename T = IommuMapRangeFtraceEvent> T* set_iommu_map_range() {
    return BeginNestedMessage<T>(281);
  }


  using FieldMetadata_IommuSecPtblMapRangeEnd =
    ::protozero::proto_utils::FieldMetadata<
      282,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IommuSecPtblMapRangeEndFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IommuSecPtblMapRangeEnd kIommuSecPtblMapRangeEnd() { return {}; }
  template <typename T = IommuSecPtblMapRangeEndFtraceEvent> T* set_iommu_sec_ptbl_map_range_end() {
    return BeginNestedMessage<T>(282);
  }


  using FieldMetadata_IommuSecPtblMapRangeStart =
    ::protozero::proto_utils::FieldMetadata<
      283,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IommuSecPtblMapRangeStartFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IommuSecPtblMapRangeStart kIommuSecPtblMapRangeStart() { return {}; }
  template <typename T = IommuSecPtblMapRangeStartFtraceEvent> T* set_iommu_sec_ptbl_map_range_start() {
    return BeginNestedMessage<T>(283);
  }


  using FieldMetadata_IonAllocBufferEnd =
    ::protozero::proto_utils::FieldMetadata<
      284,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IonAllocBufferEndFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IonAllocBufferEnd kIonAllocBufferEnd() { return {}; }
  template <typename T = IonAllocBufferEndFtraceEvent> T* set_ion_alloc_buffer_end() {
    return BeginNestedMessage<T>(284);
  }


  using FieldMetadata_IonAllocBufferFail =
    ::protozero::proto_utils::FieldMetadata<
      285,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IonAllocBufferFailFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IonAllocBufferFail kIonAllocBufferFail() { return {}; }
  template <typename T = IonAllocBufferFailFtraceEvent> T* set_ion_alloc_buffer_fail() {
    return BeginNestedMessage<T>(285);
  }


  using FieldMetadata_IonAllocBufferFallback =
    ::protozero::proto_utils::FieldMetadata<
      286,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IonAllocBufferFallbackFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IonAllocBufferFallback kIonAllocBufferFallback() { return {}; }
  template <typename T = IonAllocBufferFallbackFtraceEvent> T* set_ion_alloc_buffer_fallback() {
    return BeginNestedMessage<T>(286);
  }


  using FieldMetadata_IonAllocBufferStart =
    ::protozero::proto_utils::FieldMetadata<
      287,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IonAllocBufferStartFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IonAllocBufferStart kIonAllocBufferStart() { return {}; }
  template <typename T = IonAllocBufferStartFtraceEvent> T* set_ion_alloc_buffer_start() {
    return BeginNestedMessage<T>(287);
  }


  using FieldMetadata_IonCpAllocRetry =
    ::protozero::proto_utils::FieldMetadata<
      288,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IonCpAllocRetryFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IonCpAllocRetry kIonCpAllocRetry() { return {}; }
  template <typename T = IonCpAllocRetryFtraceEvent> T* set_ion_cp_alloc_retry() {
    return BeginNestedMessage<T>(288);
  }


  using FieldMetadata_IonCpSecureBufferEnd =
    ::protozero::proto_utils::FieldMetadata<
      289,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IonCpSecureBufferEndFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IonCpSecureBufferEnd kIonCpSecureBufferEnd() { return {}; }
  template <typename T = IonCpSecureBufferEndFtraceEvent> T* set_ion_cp_secure_buffer_end() {
    return BeginNestedMessage<T>(289);
  }


  using FieldMetadata_IonCpSecureBufferStart =
    ::protozero::proto_utils::FieldMetadata<
      290,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IonCpSecureBufferStartFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IonCpSecureBufferStart kIonCpSecureBufferStart() { return {}; }
  template <typename T = IonCpSecureBufferStartFtraceEvent> T* set_ion_cp_secure_buffer_start() {
    return BeginNestedMessage<T>(290);
  }


  using FieldMetadata_IonPrefetching =
    ::protozero::proto_utils::FieldMetadata<
      291,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IonPrefetchingFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IonPrefetching kIonPrefetching() { return {}; }
  template <typename T = IonPrefetchingFtraceEvent> T* set_ion_prefetching() {
    return BeginNestedMessage<T>(291);
  }


  using FieldMetadata_IonSecureCmaAddToPoolEnd =
    ::protozero::proto_utils::FieldMetadata<
      292,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IonSecureCmaAddToPoolEndFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IonSecureCmaAddToPoolEnd kIonSecureCmaAddToPoolEnd() { return {}; }
  template <typename T = IonSecureCmaAddToPoolEndFtraceEvent> T* set_ion_secure_cma_add_to_pool_end() {
    return BeginNestedMessage<T>(292);
  }


  using FieldMetadata_IonSecureCmaAddToPoolStart =
    ::protozero::proto_utils::FieldMetadata<
      293,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IonSecureCmaAddToPoolStartFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IonSecureCmaAddToPoolStart kIonSecureCmaAddToPoolStart() { return {}; }
  template <typename T = IonSecureCmaAddToPoolStartFtraceEvent> T* set_ion_secure_cma_add_to_pool_start() {
    return BeginNestedMessage<T>(293);
  }


  using FieldMetadata_IonSecureCmaAllocateEnd =
    ::protozero::proto_utils::FieldMetadata<
      294,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IonSecureCmaAllocateEndFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IonSecureCmaAllocateEnd kIonSecureCmaAllocateEnd() { return {}; }
  template <typename T = IonSecureCmaAllocateEndFtraceEvent> T* set_ion_secure_cma_allocate_end() {
    return BeginNestedMessage<T>(294);
  }


  using FieldMetadata_IonSecureCmaAllocateStart =
    ::protozero::proto_utils::FieldMetadata<
      295,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IonSecureCmaAllocateStartFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IonSecureCmaAllocateStart kIonSecureCmaAllocateStart() { return {}; }
  template <typename T = IonSecureCmaAllocateStartFtraceEvent> T* set_ion_secure_cma_allocate_start() {
    return BeginNestedMessage<T>(295);
  }


  using FieldMetadata_IonSecureCmaShrinkPoolEnd =
    ::protozero::proto_utils::FieldMetadata<
      296,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IonSecureCmaShrinkPoolEndFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IonSecureCmaShrinkPoolEnd kIonSecureCmaShrinkPoolEnd() { return {}; }
  template <typename T = IonSecureCmaShrinkPoolEndFtraceEvent> T* set_ion_secure_cma_shrink_pool_end() {
    return BeginNestedMessage<T>(296);
  }


  using FieldMetadata_IonSecureCmaShrinkPoolStart =
    ::protozero::proto_utils::FieldMetadata<
      297,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IonSecureCmaShrinkPoolStartFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IonSecureCmaShrinkPoolStart kIonSecureCmaShrinkPoolStart() { return {}; }
  template <typename T = IonSecureCmaShrinkPoolStartFtraceEvent> T* set_ion_secure_cma_shrink_pool_start() {
    return BeginNestedMessage<T>(297);
  }


  using FieldMetadata_Kfree =
    ::protozero::proto_utils::FieldMetadata<
      298,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KfreeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Kfree kKfree() { return {}; }
  template <typename T = KfreeFtraceEvent> T* set_kfree() {
    return BeginNestedMessage<T>(298);
  }


  using FieldMetadata_Kmalloc =
    ::protozero::proto_utils::FieldMetadata<
      299,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KmallocFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Kmalloc kKmalloc() { return {}; }
  template <typename T = KmallocFtraceEvent> T* set_kmalloc() {
    return BeginNestedMessage<T>(299);
  }


  using FieldMetadata_KmallocNode =
    ::protozero::proto_utils::FieldMetadata<
      300,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KmallocNodeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KmallocNode kKmallocNode() { return {}; }
  template <typename T = KmallocNodeFtraceEvent> T* set_kmalloc_node() {
    return BeginNestedMessage<T>(300);
  }


  using FieldMetadata_KmemCacheAlloc =
    ::protozero::proto_utils::FieldMetadata<
      301,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KmemCacheAllocFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KmemCacheAlloc kKmemCacheAlloc() { return {}; }
  template <typename T = KmemCacheAllocFtraceEvent> T* set_kmem_cache_alloc() {
    return BeginNestedMessage<T>(301);
  }


  using FieldMetadata_KmemCacheAllocNode =
    ::protozero::proto_utils::FieldMetadata<
      302,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KmemCacheAllocNodeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KmemCacheAllocNode kKmemCacheAllocNode() { return {}; }
  template <typename T = KmemCacheAllocNodeFtraceEvent> T* set_kmem_cache_alloc_node() {
    return BeginNestedMessage<T>(302);
  }


  using FieldMetadata_KmemCacheFree =
    ::protozero::proto_utils::FieldMetadata<
      303,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KmemCacheFreeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KmemCacheFree kKmemCacheFree() { return {}; }
  template <typename T = KmemCacheFreeFtraceEvent> T* set_kmem_cache_free() {
    return BeginNestedMessage<T>(303);
  }


  using FieldMetadata_MigratePagesEnd =
    ::protozero::proto_utils::FieldMetadata<
      304,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MigratePagesEndFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MigratePagesEnd kMigratePagesEnd() { return {}; }
  template <typename T = MigratePagesEndFtraceEvent> T* set_migrate_pages_end() {
    return BeginNestedMessage<T>(304);
  }


  using FieldMetadata_MigratePagesStart =
    ::protozero::proto_utils::FieldMetadata<
      305,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MigratePagesStartFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MigratePagesStart kMigratePagesStart() { return {}; }
  template <typename T = MigratePagesStartFtraceEvent> T* set_migrate_pages_start() {
    return BeginNestedMessage<T>(305);
  }


  using FieldMetadata_MigrateRetry =
    ::protozero::proto_utils::FieldMetadata<
      306,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MigrateRetryFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MigrateRetry kMigrateRetry() { return {}; }
  template <typename T = MigrateRetryFtraceEvent> T* set_migrate_retry() {
    return BeginNestedMessage<T>(306);
  }


  using FieldMetadata_MmPageAlloc =
    ::protozero::proto_utils::FieldMetadata<
      307,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmPageAllocFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmPageAlloc kMmPageAlloc() { return {}; }
  template <typename T = MmPageAllocFtraceEvent> T* set_mm_page_alloc() {
    return BeginNestedMessage<T>(307);
  }


  using FieldMetadata_MmPageAllocExtfrag =
    ::protozero::proto_utils::FieldMetadata<
      308,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmPageAllocExtfragFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmPageAllocExtfrag kMmPageAllocExtfrag() { return {}; }
  template <typename T = MmPageAllocExtfragFtraceEvent> T* set_mm_page_alloc_extfrag() {
    return BeginNestedMessage<T>(308);
  }


  using FieldMetadata_MmPageAllocZoneLocked =
    ::protozero::proto_utils::FieldMetadata<
      309,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmPageAllocZoneLockedFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmPageAllocZoneLocked kMmPageAllocZoneLocked() { return {}; }
  template <typename T = MmPageAllocZoneLockedFtraceEvent> T* set_mm_page_alloc_zone_locked() {
    return BeginNestedMessage<T>(309);
  }


  using FieldMetadata_MmPageFree =
    ::protozero::proto_utils::FieldMetadata<
      310,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmPageFreeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmPageFree kMmPageFree() { return {}; }
  template <typename T = MmPageFreeFtraceEvent> T* set_mm_page_free() {
    return BeginNestedMessage<T>(310);
  }


  using FieldMetadata_MmPageFreeBatched =
    ::protozero::proto_utils::FieldMetadata<
      311,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmPageFreeBatchedFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmPageFreeBatched kMmPageFreeBatched() { return {}; }
  template <typename T = MmPageFreeBatchedFtraceEvent> T* set_mm_page_free_batched() {
    return BeginNestedMessage<T>(311);
  }


  using FieldMetadata_MmPagePcpuDrain =
    ::protozero::proto_utils::FieldMetadata<
      312,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmPagePcpuDrainFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmPagePcpuDrain kMmPagePcpuDrain() { return {}; }
  template <typename T = MmPagePcpuDrainFtraceEvent> T* set_mm_page_pcpu_drain() {
    return BeginNestedMessage<T>(312);
  }


  using FieldMetadata_RssStat =
    ::protozero::proto_utils::FieldMetadata<
      313,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RssStatFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RssStat kRssStat() { return {}; }
  template <typename T = RssStatFtraceEvent> T* set_rss_stat() {
    return BeginNestedMessage<T>(313);
  }


  using FieldMetadata_IonHeapShrink =
    ::protozero::proto_utils::FieldMetadata<
      314,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IonHeapShrinkFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IonHeapShrink kIonHeapShrink() { return {}; }
  template <typename T = IonHeapShrinkFtraceEvent> T* set_ion_heap_shrink() {
    return BeginNestedMessage<T>(314);
  }


  using FieldMetadata_IonHeapGrow =
    ::protozero::proto_utils::FieldMetadata<
      315,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IonHeapGrowFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IonHeapGrow kIonHeapGrow() { return {}; }
  template <typename T = IonHeapGrowFtraceEvent> T* set_ion_heap_grow() {
    return BeginNestedMessage<T>(315);
  }


  using FieldMetadata_FenceInit =
    ::protozero::proto_utils::FieldMetadata<
      316,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      FenceInitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FenceInit kFenceInit() { return {}; }
  template <typename T = FenceInitFtraceEvent> T* set_fence_init() {
    return BeginNestedMessage<T>(316);
  }


  using FieldMetadata_FenceDestroy =
    ::protozero::proto_utils::FieldMetadata<
      317,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      FenceDestroyFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FenceDestroy kFenceDestroy() { return {}; }
  template <typename T = FenceDestroyFtraceEvent> T* set_fence_destroy() {
    return BeginNestedMessage<T>(317);
  }


  using FieldMetadata_FenceEnableSignal =
    ::protozero::proto_utils::FieldMetadata<
      318,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      FenceEnableSignalFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FenceEnableSignal kFenceEnableSignal() { return {}; }
  template <typename T = FenceEnableSignalFtraceEvent> T* set_fence_enable_signal() {
    return BeginNestedMessage<T>(318);
  }


  using FieldMetadata_FenceSignaled =
    ::protozero::proto_utils::FieldMetadata<
      319,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      FenceSignaledFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FenceSignaled kFenceSignaled() { return {}; }
  template <typename T = FenceSignaledFtraceEvent> T* set_fence_signaled() {
    return BeginNestedMessage<T>(319);
  }


  using FieldMetadata_ClkEnable =
    ::protozero::proto_utils::FieldMetadata<
      320,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ClkEnableFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ClkEnable kClkEnable() { return {}; }
  template <typename T = ClkEnableFtraceEvent> T* set_clk_enable() {
    return BeginNestedMessage<T>(320);
  }


  using FieldMetadata_ClkDisable =
    ::protozero::proto_utils::FieldMetadata<
      321,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ClkDisableFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ClkDisable kClkDisable() { return {}; }
  template <typename T = ClkDisableFtraceEvent> T* set_clk_disable() {
    return BeginNestedMessage<T>(321);
  }


  using FieldMetadata_ClkSetRate =
    ::protozero::proto_utils::FieldMetadata<
      322,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ClkSetRateFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ClkSetRate kClkSetRate() { return {}; }
  template <typename T = ClkSetRateFtraceEvent> T* set_clk_set_rate() {
    return BeginNestedMessage<T>(322);
  }


  using FieldMetadata_BinderTransactionAllocBuf =
    ::protozero::proto_utils::FieldMetadata<
      323,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BinderTransactionAllocBufFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BinderTransactionAllocBuf kBinderTransactionAllocBuf() { return {}; }
  template <typename T = BinderTransactionAllocBufFtraceEvent> T* set_binder_transaction_alloc_buf() {
    return BeginNestedMessage<T>(323);
  }


  using FieldMetadata_SignalDeliver =
    ::protozero::proto_utils::FieldMetadata<
      324,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SignalDeliverFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SignalDeliver kSignalDeliver() { return {}; }
  template <typename T = SignalDeliverFtraceEvent> T* set_signal_deliver() {
    return BeginNestedMessage<T>(324);
  }


  using FieldMetadata_SignalGenerate =
    ::protozero::proto_utils::FieldMetadata<
      325,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SignalGenerateFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SignalGenerate kSignalGenerate() { return {}; }
  template <typename T = SignalGenerateFtraceEvent> T* set_signal_generate() {
    return BeginNestedMessage<T>(325);
  }


  using FieldMetadata_OomScoreAdjUpdate =
    ::protozero::proto_utils::FieldMetadata<
      326,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      OomScoreAdjUpdateFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_OomScoreAdjUpdate kOomScoreAdjUpdate() { return {}; }
  template <typename T = OomScoreAdjUpdateFtraceEvent> T* set_oom_score_adj_update() {
    return BeginNestedMessage<T>(326);
  }


  using FieldMetadata_Generic =
    ::protozero::proto_utils::FieldMetadata<
      327,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      GenericFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Generic kGeneric() { return {}; }
  template <typename T = GenericFtraceEvent> T* set_generic() {
    return BeginNestedMessage<T>(327);
  }


  using FieldMetadata_MmEventRecord =
    ::protozero::proto_utils::FieldMetadata<
      328,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MmEventRecordFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MmEventRecord kMmEventRecord() { return {}; }
  template <typename T = MmEventRecordFtraceEvent> T* set_mm_event_record() {
    return BeginNestedMessage<T>(328);
  }


  using FieldMetadata_SysEnter =
    ::protozero::proto_utils::FieldMetadata<
      329,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SysEnterFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SysEnter kSysEnter() { return {}; }
  template <typename T = SysEnterFtraceEvent> T* set_sys_enter() {
    return BeginNestedMessage<T>(329);
  }


  using FieldMetadata_SysExit =
    ::protozero::proto_utils::FieldMetadata<
      330,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SysExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SysExit kSysExit() { return {}; }
  template <typename T = SysExitFtraceEvent> T* set_sys_exit() {
    return BeginNestedMessage<T>(330);
  }


  using FieldMetadata_Zero =
    ::protozero::proto_utils::FieldMetadata<
      331,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ZeroFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Zero kZero() { return {}; }
  template <typename T = ZeroFtraceEvent> T* set_zero() {
    return BeginNestedMessage<T>(331);
  }


  using FieldMetadata_GpuFrequency =
    ::protozero::proto_utils::FieldMetadata<
      332,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      GpuFrequencyFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_GpuFrequency kGpuFrequency() { return {}; }
  template <typename T = GpuFrequencyFtraceEvent> T* set_gpu_frequency() {
    return BeginNestedMessage<T>(332);
  }


  using FieldMetadata_SdeTracingMarkWrite =
    ::protozero::proto_utils::FieldMetadata<
      333,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SdeTracingMarkWriteFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SdeTracingMarkWrite kSdeTracingMarkWrite() { return {}; }
  template <typename T = SdeTracingMarkWriteFtraceEvent> T* set_sde_tracing_mark_write() {
    return BeginNestedMessage<T>(333);
  }


  using FieldMetadata_MarkVictim =
    ::protozero::proto_utils::FieldMetadata<
      334,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MarkVictimFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MarkVictim kMarkVictim() { return {}; }
  template <typename T = MarkVictimFtraceEvent> T* set_mark_victim() {
    return BeginNestedMessage<T>(334);
  }


  using FieldMetadata_IonStat =
    ::protozero::proto_utils::FieldMetadata<
      335,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IonStatFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IonStat kIonStat() { return {}; }
  template <typename T = IonStatFtraceEvent> T* set_ion_stat() {
    return BeginNestedMessage<T>(335);
  }


  using FieldMetadata_IonBufferCreate =
    ::protozero::proto_utils::FieldMetadata<
      336,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IonBufferCreateFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IonBufferCreate kIonBufferCreate() { return {}; }
  template <typename T = IonBufferCreateFtraceEvent> T* set_ion_buffer_create() {
    return BeginNestedMessage<T>(336);
  }


  using FieldMetadata_IonBufferDestroy =
    ::protozero::proto_utils::FieldMetadata<
      337,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IonBufferDestroyFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IonBufferDestroy kIonBufferDestroy() { return {}; }
  template <typename T = IonBufferDestroyFtraceEvent> T* set_ion_buffer_destroy() {
    return BeginNestedMessage<T>(337);
  }


  using FieldMetadata_ScmCallStart =
    ::protozero::proto_utils::FieldMetadata<
      338,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ScmCallStartFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ScmCallStart kScmCallStart() { return {}; }
  template <typename T = ScmCallStartFtraceEvent> T* set_scm_call_start() {
    return BeginNestedMessage<T>(338);
  }


  using FieldMetadata_ScmCallEnd =
    ::protozero::proto_utils::FieldMetadata<
      339,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ScmCallEndFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ScmCallEnd kScmCallEnd() { return {}; }
  template <typename T = ScmCallEndFtraceEvent> T* set_scm_call_end() {
    return BeginNestedMessage<T>(339);
  }


  using FieldMetadata_GpuMemTotal =
    ::protozero::proto_utils::FieldMetadata<
      340,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      GpuMemTotalFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_GpuMemTotal kGpuMemTotal() { return {}; }
  template <typename T = GpuMemTotalFtraceEvent> T* set_gpu_mem_total() {
    return BeginNestedMessage<T>(340);
  }


  using FieldMetadata_ThermalTemperature =
    ::protozero::proto_utils::FieldMetadata<
      341,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ThermalTemperatureFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ThermalTemperature kThermalTemperature() { return {}; }
  template <typename T = ThermalTemperatureFtraceEvent> T* set_thermal_temperature() {
    return BeginNestedMessage<T>(341);
  }


  using FieldMetadata_CdevUpdate =
    ::protozero::proto_utils::FieldMetadata<
      342,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      CdevUpdateFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CdevUpdate kCdevUpdate() { return {}; }
  template <typename T = CdevUpdateFtraceEvent> T* set_cdev_update() {
    return BeginNestedMessage<T>(342);
  }


  using FieldMetadata_CpuhpExit =
    ::protozero::proto_utils::FieldMetadata<
      343,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      CpuhpExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CpuhpExit kCpuhpExit() { return {}; }
  template <typename T = CpuhpExitFtraceEvent> T* set_cpuhp_exit() {
    return BeginNestedMessage<T>(343);
  }


  using FieldMetadata_CpuhpMultiEnter =
    ::protozero::proto_utils::FieldMetadata<
      344,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      CpuhpMultiEnterFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CpuhpMultiEnter kCpuhpMultiEnter() { return {}; }
  template <typename T = CpuhpMultiEnterFtraceEvent> T* set_cpuhp_multi_enter() {
    return BeginNestedMessage<T>(344);
  }


  using FieldMetadata_CpuhpEnter =
    ::protozero::proto_utils::FieldMetadata<
      345,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      CpuhpEnterFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CpuhpEnter kCpuhpEnter() { return {}; }
  template <typename T = CpuhpEnterFtraceEvent> T* set_cpuhp_enter() {
    return BeginNestedMessage<T>(345);
  }


  using FieldMetadata_CpuhpLatency =
    ::protozero::proto_utils::FieldMetadata<
      346,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      CpuhpLatencyFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CpuhpLatency kCpuhpLatency() { return {}; }
  template <typename T = CpuhpLatencyFtraceEvent> T* set_cpuhp_latency() {
    return BeginNestedMessage<T>(346);
  }


  using FieldMetadata_FastrpcDmaStat =
    ::protozero::proto_utils::FieldMetadata<
      347,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      FastrpcDmaStatFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FastrpcDmaStat kFastrpcDmaStat() { return {}; }
  template <typename T = FastrpcDmaStatFtraceEvent> T* set_fastrpc_dma_stat() {
    return BeginNestedMessage<T>(347);
  }


  using FieldMetadata_DpuTracingMarkWrite =
    ::protozero::proto_utils::FieldMetadata<
      348,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DpuTracingMarkWriteFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DpuTracingMarkWrite kDpuTracingMarkWrite() { return {}; }
  template <typename T = DpuTracingMarkWriteFtraceEvent> T* set_dpu_tracing_mark_write() {
    return BeginNestedMessage<T>(348);
  }


  using FieldMetadata_G2dTracingMarkWrite =
    ::protozero::proto_utils::FieldMetadata<
      349,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      G2dTracingMarkWriteFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_G2dTracingMarkWrite kG2dTracingMarkWrite() { return {}; }
  template <typename T = G2dTracingMarkWriteFtraceEvent> T* set_g2d_tracing_mark_write() {
    return BeginNestedMessage<T>(349);
  }


  using FieldMetadata_MaliTracingMarkWrite =
    ::protozero::proto_utils::FieldMetadata<
      350,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      MaliTracingMarkWriteFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MaliTracingMarkWrite kMaliTracingMarkWrite() { return {}; }
  template <typename T = MaliTracingMarkWriteFtraceEvent> T* set_mali_tracing_mark_write() {
    return BeginNestedMessage<T>(350);
  }


  using FieldMetadata_DmaHeapStat =
    ::protozero::proto_utils::FieldMetadata<
      351,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DmaHeapStatFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DmaHeapStat kDmaHeapStat() { return {}; }
  template <typename T = DmaHeapStatFtraceEvent> T* set_dma_heap_stat() {
    return BeginNestedMessage<T>(351);
  }


  using FieldMetadata_CpuhpPause =
    ::protozero::proto_utils::FieldMetadata<
      352,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      CpuhpPauseFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CpuhpPause kCpuhpPause() { return {}; }
  template <typename T = CpuhpPauseFtraceEvent> T* set_cpuhp_pause() {
    return BeginNestedMessage<T>(352);
  }


  using FieldMetadata_SchedPiSetprio =
    ::protozero::proto_utils::FieldMetadata<
      353,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SchedPiSetprioFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SchedPiSetprio kSchedPiSetprio() { return {}; }
  template <typename T = SchedPiSetprioFtraceEvent> T* set_sched_pi_setprio() {
    return BeginNestedMessage<T>(353);
  }


  using FieldMetadata_SdeSdeEvtlog =
    ::protozero::proto_utils::FieldMetadata<
      354,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SdeSdeEvtlogFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SdeSdeEvtlog kSdeSdeEvtlog() { return {}; }
  template <typename T = SdeSdeEvtlogFtraceEvent> T* set_sde_sde_evtlog() {
    return BeginNestedMessage<T>(354);
  }


  using FieldMetadata_SdeSdePerfCalcCrtc =
    ::protozero::proto_utils::FieldMetadata<
      355,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SdeSdePerfCalcCrtcFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SdeSdePerfCalcCrtc kSdeSdePerfCalcCrtc() { return {}; }
  template <typename T = SdeSdePerfCalcCrtcFtraceEvent> T* set_sde_sde_perf_calc_crtc() {
    return BeginNestedMessage<T>(355);
  }


  using FieldMetadata_SdeSdePerfCrtcUpdate =
    ::protozero::proto_utils::FieldMetadata<
      356,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SdeSdePerfCrtcUpdateFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SdeSdePerfCrtcUpdate kSdeSdePerfCrtcUpdate() { return {}; }
  template <typename T = SdeSdePerfCrtcUpdateFtraceEvent> T* set_sde_sde_perf_crtc_update() {
    return BeginNestedMessage<T>(356);
  }


  using FieldMetadata_SdeSdePerfSetQosLuts =
    ::protozero::proto_utils::FieldMetadata<
      357,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SdeSdePerfSetQosLutsFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SdeSdePerfSetQosLuts kSdeSdePerfSetQosLuts() { return {}; }
  template <typename T = SdeSdePerfSetQosLutsFtraceEvent> T* set_sde_sde_perf_set_qos_luts() {
    return BeginNestedMessage<T>(357);
  }


  using FieldMetadata_SdeSdePerfUpdateBus =
    ::protozero::proto_utils::FieldMetadata<
      358,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SdeSdePerfUpdateBusFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SdeSdePerfUpdateBus kSdeSdePerfUpdateBus() { return {}; }
  template <typename T = SdeSdePerfUpdateBusFtraceEvent> T* set_sde_sde_perf_update_bus() {
    return BeginNestedMessage<T>(358);
  }


  using FieldMetadata_RssStatThrottled =
    ::protozero::proto_utils::FieldMetadata<
      359,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RssStatThrottledFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RssStatThrottled kRssStatThrottled() { return {}; }
  template <typename T = RssStatThrottledFtraceEvent> T* set_rss_stat_throttled() {
    return BeginNestedMessage<T>(359);
  }


  using FieldMetadata_NetifReceiveSkb =
    ::protozero::proto_utils::FieldMetadata<
      360,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      NetifReceiveSkbFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_NetifReceiveSkb kNetifReceiveSkb() { return {}; }
  template <typename T = NetifReceiveSkbFtraceEvent> T* set_netif_receive_skb() {
    return BeginNestedMessage<T>(360);
  }


  using FieldMetadata_NetDevXmit =
    ::protozero::proto_utils::FieldMetadata<
      361,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      NetDevXmitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_NetDevXmit kNetDevXmit() { return {}; }
  template <typename T = NetDevXmitFtraceEvent> T* set_net_dev_xmit() {
    return BeginNestedMessage<T>(361);
  }


  using FieldMetadata_InetSockSetState =
    ::protozero::proto_utils::FieldMetadata<
      362,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      InetSockSetStateFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_InetSockSetState kInetSockSetState() { return {}; }
  template <typename T = InetSockSetStateFtraceEvent> T* set_inet_sock_set_state() {
    return BeginNestedMessage<T>(362);
  }


  using FieldMetadata_TcpRetransmitSkb =
    ::protozero::proto_utils::FieldMetadata<
      363,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TcpRetransmitSkbFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_TcpRetransmitSkb kTcpRetransmitSkb() { return {}; }
  template <typename T = TcpRetransmitSkbFtraceEvent> T* set_tcp_retransmit_skb() {
    return BeginNestedMessage<T>(363);
  }


  using FieldMetadata_CrosEcSensorhubData =
    ::protozero::proto_utils::FieldMetadata<
      364,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      CrosEcSensorhubDataFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_CrosEcSensorhubData kCrosEcSensorhubData() { return {}; }
  template <typename T = CrosEcSensorhubDataFtraceEvent> T* set_cros_ec_sensorhub_data() {
    return BeginNestedMessage<T>(364);
  }


  using FieldMetadata_NapiGroReceiveEntry =
    ::protozero::proto_utils::FieldMetadata<
      365,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      NapiGroReceiveEntryFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_NapiGroReceiveEntry kNapiGroReceiveEntry() { return {}; }
  template <typename T = NapiGroReceiveEntryFtraceEvent> T* set_napi_gro_receive_entry() {
    return BeginNestedMessage<T>(365);
  }


  using FieldMetadata_NapiGroReceiveExit =
    ::protozero::proto_utils::FieldMetadata<
      366,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      NapiGroReceiveExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_NapiGroReceiveExit kNapiGroReceiveExit() { return {}; }
  template <typename T = NapiGroReceiveExitFtraceEvent> T* set_napi_gro_receive_exit() {
    return BeginNestedMessage<T>(366);
  }


  using FieldMetadata_KfreeSkb =
    ::protozero::proto_utils::FieldMetadata<
      367,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KfreeSkbFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KfreeSkb kKfreeSkb() { return {}; }
  template <typename T = KfreeSkbFtraceEvent> T* set_kfree_skb() {
    return BeginNestedMessage<T>(367);
  }


  using FieldMetadata_KvmAccessFault =
    ::protozero::proto_utils::FieldMetadata<
      368,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmAccessFaultFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmAccessFault kKvmAccessFault() { return {}; }
  template <typename T = KvmAccessFaultFtraceEvent> T* set_kvm_access_fault() {
    return BeginNestedMessage<T>(368);
  }


  using FieldMetadata_KvmAckIrq =
    ::protozero::proto_utils::FieldMetadata<
      369,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmAckIrqFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmAckIrq kKvmAckIrq() { return {}; }
  template <typename T = KvmAckIrqFtraceEvent> T* set_kvm_ack_irq() {
    return BeginNestedMessage<T>(369);
  }


  using FieldMetadata_KvmAgeHva =
    ::protozero::proto_utils::FieldMetadata<
      370,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmAgeHvaFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmAgeHva kKvmAgeHva() { return {}; }
  template <typename T = KvmAgeHvaFtraceEvent> T* set_kvm_age_hva() {
    return BeginNestedMessage<T>(370);
  }


  using FieldMetadata_KvmAgePage =
    ::protozero::proto_utils::FieldMetadata<
      371,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmAgePageFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmAgePage kKvmAgePage() { return {}; }
  template <typename T = KvmAgePageFtraceEvent> T* set_kvm_age_page() {
    return BeginNestedMessage<T>(371);
  }


  using FieldMetadata_KvmArmClearDebug =
    ::protozero::proto_utils::FieldMetadata<
      372,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmArmClearDebugFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmArmClearDebug kKvmArmClearDebug() { return {}; }
  template <typename T = KvmArmClearDebugFtraceEvent> T* set_kvm_arm_clear_debug() {
    return BeginNestedMessage<T>(372);
  }


  using FieldMetadata_KvmArmSetDreg32 =
    ::protozero::proto_utils::FieldMetadata<
      373,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmArmSetDreg32FtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmArmSetDreg32 kKvmArmSetDreg32() { return {}; }
  template <typename T = KvmArmSetDreg32FtraceEvent> T* set_kvm_arm_set_dreg32() {
    return BeginNestedMessage<T>(373);
  }


  using FieldMetadata_KvmArmSetRegset =
    ::protozero::proto_utils::FieldMetadata<
      374,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmArmSetRegsetFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmArmSetRegset kKvmArmSetRegset() { return {}; }
  template <typename T = KvmArmSetRegsetFtraceEvent> T* set_kvm_arm_set_regset() {
    return BeginNestedMessage<T>(374);
  }


  using FieldMetadata_KvmArmSetupDebug =
    ::protozero::proto_utils::FieldMetadata<
      375,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmArmSetupDebugFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmArmSetupDebug kKvmArmSetupDebug() { return {}; }
  template <typename T = KvmArmSetupDebugFtraceEvent> T* set_kvm_arm_setup_debug() {
    return BeginNestedMessage<T>(375);
  }


  using FieldMetadata_KvmEntry =
    ::protozero::proto_utils::FieldMetadata<
      376,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmEntryFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmEntry kKvmEntry() { return {}; }
  template <typename T = KvmEntryFtraceEvent> T* set_kvm_entry() {
    return BeginNestedMessage<T>(376);
  }


  using FieldMetadata_KvmExit =
    ::protozero::proto_utils::FieldMetadata<
      377,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmExit kKvmExit() { return {}; }
  template <typename T = KvmExitFtraceEvent> T* set_kvm_exit() {
    return BeginNestedMessage<T>(377);
  }


  using FieldMetadata_KvmFpu =
    ::protozero::proto_utils::FieldMetadata<
      378,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmFpuFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmFpu kKvmFpu() { return {}; }
  template <typename T = KvmFpuFtraceEvent> T* set_kvm_fpu() {
    return BeginNestedMessage<T>(378);
  }


  using FieldMetadata_KvmGetTimerMap =
    ::protozero::proto_utils::FieldMetadata<
      379,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmGetTimerMapFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmGetTimerMap kKvmGetTimerMap() { return {}; }
  template <typename T = KvmGetTimerMapFtraceEvent> T* set_kvm_get_timer_map() {
    return BeginNestedMessage<T>(379);
  }


  using FieldMetadata_KvmGuestFault =
    ::protozero::proto_utils::FieldMetadata<
      380,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmGuestFaultFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmGuestFault kKvmGuestFault() { return {}; }
  template <typename T = KvmGuestFaultFtraceEvent> T* set_kvm_guest_fault() {
    return BeginNestedMessage<T>(380);
  }


  using FieldMetadata_KvmHandleSysReg =
    ::protozero::proto_utils::FieldMetadata<
      381,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmHandleSysRegFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmHandleSysReg kKvmHandleSysReg() { return {}; }
  template <typename T = KvmHandleSysRegFtraceEvent> T* set_kvm_handle_sys_reg() {
    return BeginNestedMessage<T>(381);
  }


  using FieldMetadata_KvmHvcArm64 =
    ::protozero::proto_utils::FieldMetadata<
      382,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmHvcArm64FtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmHvcArm64 kKvmHvcArm64() { return {}; }
  template <typename T = KvmHvcArm64FtraceEvent> T* set_kvm_hvc_arm64() {
    return BeginNestedMessage<T>(382);
  }


  using FieldMetadata_KvmIrqLine =
    ::protozero::proto_utils::FieldMetadata<
      383,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmIrqLineFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmIrqLine kKvmIrqLine() { return {}; }
  template <typename T = KvmIrqLineFtraceEvent> T* set_kvm_irq_line() {
    return BeginNestedMessage<T>(383);
  }


  using FieldMetadata_KvmMmio =
    ::protozero::proto_utils::FieldMetadata<
      384,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmMmioFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmMmio kKvmMmio() { return {}; }
  template <typename T = KvmMmioFtraceEvent> T* set_kvm_mmio() {
    return BeginNestedMessage<T>(384);
  }


  using FieldMetadata_KvmMmioEmulate =
    ::protozero::proto_utils::FieldMetadata<
      385,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmMmioEmulateFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmMmioEmulate kKvmMmioEmulate() { return {}; }
  template <typename T = KvmMmioEmulateFtraceEvent> T* set_kvm_mmio_emulate() {
    return BeginNestedMessage<T>(385);
  }


  using FieldMetadata_KvmSetGuestDebug =
    ::protozero::proto_utils::FieldMetadata<
      386,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmSetGuestDebugFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmSetGuestDebug kKvmSetGuestDebug() { return {}; }
  template <typename T = KvmSetGuestDebugFtraceEvent> T* set_kvm_set_guest_debug() {
    return BeginNestedMessage<T>(386);
  }


  using FieldMetadata_KvmSetIrq =
    ::protozero::proto_utils::FieldMetadata<
      387,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmSetIrqFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmSetIrq kKvmSetIrq() { return {}; }
  template <typename T = KvmSetIrqFtraceEvent> T* set_kvm_set_irq() {
    return BeginNestedMessage<T>(387);
  }


  using FieldMetadata_KvmSetSpteHva =
    ::protozero::proto_utils::FieldMetadata<
      388,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmSetSpteHvaFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmSetSpteHva kKvmSetSpteHva() { return {}; }
  template <typename T = KvmSetSpteHvaFtraceEvent> T* set_kvm_set_spte_hva() {
    return BeginNestedMessage<T>(388);
  }


  using FieldMetadata_KvmSetWayFlush =
    ::protozero::proto_utils::FieldMetadata<
      389,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmSetWayFlushFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmSetWayFlush kKvmSetWayFlush() { return {}; }
  template <typename T = KvmSetWayFlushFtraceEvent> T* set_kvm_set_way_flush() {
    return BeginNestedMessage<T>(389);
  }


  using FieldMetadata_KvmSysAccess =
    ::protozero::proto_utils::FieldMetadata<
      390,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmSysAccessFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmSysAccess kKvmSysAccess() { return {}; }
  template <typename T = KvmSysAccessFtraceEvent> T* set_kvm_sys_access() {
    return BeginNestedMessage<T>(390);
  }


  using FieldMetadata_KvmTestAgeHva =
    ::protozero::proto_utils::FieldMetadata<
      391,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmTestAgeHvaFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmTestAgeHva kKvmTestAgeHva() { return {}; }
  template <typename T = KvmTestAgeHvaFtraceEvent> T* set_kvm_test_age_hva() {
    return BeginNestedMessage<T>(391);
  }


  using FieldMetadata_KvmTimerEmulate =
    ::protozero::proto_utils::FieldMetadata<
      392,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmTimerEmulateFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmTimerEmulate kKvmTimerEmulate() { return {}; }
  template <typename T = KvmTimerEmulateFtraceEvent> T* set_kvm_timer_emulate() {
    return BeginNestedMessage<T>(392);
  }


  using FieldMetadata_KvmTimerHrtimerExpire =
    ::protozero::proto_utils::FieldMetadata<
      393,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmTimerHrtimerExpireFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmTimerHrtimerExpire kKvmTimerHrtimerExpire() { return {}; }
  template <typename T = KvmTimerHrtimerExpireFtraceEvent> T* set_kvm_timer_hrtimer_expire() {
    return BeginNestedMessage<T>(393);
  }


  using FieldMetadata_KvmTimerRestoreState =
    ::protozero::proto_utils::FieldMetadata<
      394,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmTimerRestoreStateFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmTimerRestoreState kKvmTimerRestoreState() { return {}; }
  template <typename T = KvmTimerRestoreStateFtraceEvent> T* set_kvm_timer_restore_state() {
    return BeginNestedMessage<T>(394);
  }


  using FieldMetadata_KvmTimerSaveState =
    ::protozero::proto_utils::FieldMetadata<
      395,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmTimerSaveStateFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmTimerSaveState kKvmTimerSaveState() { return {}; }
  template <typename T = KvmTimerSaveStateFtraceEvent> T* set_kvm_timer_save_state() {
    return BeginNestedMessage<T>(395);
  }


  using FieldMetadata_KvmTimerUpdateIrq =
    ::protozero::proto_utils::FieldMetadata<
      396,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmTimerUpdateIrqFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmTimerUpdateIrq kKvmTimerUpdateIrq() { return {}; }
  template <typename T = KvmTimerUpdateIrqFtraceEvent> T* set_kvm_timer_update_irq() {
    return BeginNestedMessage<T>(396);
  }


  using FieldMetadata_KvmToggleCache =
    ::protozero::proto_utils::FieldMetadata<
      397,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmToggleCacheFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmToggleCache kKvmToggleCache() { return {}; }
  template <typename T = KvmToggleCacheFtraceEvent> T* set_kvm_toggle_cache() {
    return BeginNestedMessage<T>(397);
  }


  using FieldMetadata_KvmUnmapHvaRange =
    ::protozero::proto_utils::FieldMetadata<
      398,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmUnmapHvaRangeFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmUnmapHvaRange kKvmUnmapHvaRange() { return {}; }
  template <typename T = KvmUnmapHvaRangeFtraceEvent> T* set_kvm_unmap_hva_range() {
    return BeginNestedMessage<T>(398);
  }


  using FieldMetadata_KvmUserspaceExit =
    ::protozero::proto_utils::FieldMetadata<
      399,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmUserspaceExitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmUserspaceExit kKvmUserspaceExit() { return {}; }
  template <typename T = KvmUserspaceExitFtraceEvent> T* set_kvm_userspace_exit() {
    return BeginNestedMessage<T>(399);
  }


  using FieldMetadata_KvmVcpuWakeup =
    ::protozero::proto_utils::FieldMetadata<
      400,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmVcpuWakeupFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmVcpuWakeup kKvmVcpuWakeup() { return {}; }
  template <typename T = KvmVcpuWakeupFtraceEvent> T* set_kvm_vcpu_wakeup() {
    return BeginNestedMessage<T>(400);
  }


  using FieldMetadata_KvmWfxArm64 =
    ::protozero::proto_utils::FieldMetadata<
      401,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KvmWfxArm64FtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_KvmWfxArm64 kKvmWfxArm64() { return {}; }
  template <typename T = KvmWfxArm64FtraceEvent> T* set_kvm_wfx_arm64() {
    return BeginNestedMessage<T>(401);
  }


  using FieldMetadata_TrapReg =
    ::protozero::proto_utils::FieldMetadata<
      402,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TrapRegFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_TrapReg kTrapReg() { return {}; }
  template <typename T = TrapRegFtraceEvent> T* set_trap_reg() {
    return BeginNestedMessage<T>(402);
  }


  using FieldMetadata_VgicUpdateIrqPending =
    ::protozero::proto_utils::FieldMetadata<
      403,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      VgicUpdateIrqPendingFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_VgicUpdateIrqPending kVgicUpdateIrqPending() { return {}; }
  template <typename T = VgicUpdateIrqPendingFtraceEvent> T* set_vgic_update_irq_pending() {
    return BeginNestedMessage<T>(403);
  }


  using FieldMetadata_WakeupSourceActivate =
    ::protozero::proto_utils::FieldMetadata<
      404,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WakeupSourceActivateFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_WakeupSourceActivate kWakeupSourceActivate() { return {}; }
  template <typename T = WakeupSourceActivateFtraceEvent> T* set_wakeup_source_activate() {
    return BeginNestedMessage<T>(404);
  }


  using FieldMetadata_WakeupSourceDeactivate =
    ::protozero::proto_utils::FieldMetadata<
      405,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WakeupSourceDeactivateFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_WakeupSourceDeactivate kWakeupSourceDeactivate() { return {}; }
  template <typename T = WakeupSourceDeactivateFtraceEvent> T* set_wakeup_source_deactivate() {
    return BeginNestedMessage<T>(405);
  }


  using FieldMetadata_UfshcdCommand =
    ::protozero::proto_utils::FieldMetadata<
      406,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      UfshcdCommandFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_UfshcdCommand kUfshcdCommand() { return {}; }
  template <typename T = UfshcdCommandFtraceEvent> T* set_ufshcd_command() {
    return BeginNestedMessage<T>(406);
  }


  using FieldMetadata_UfshcdClkGating =
    ::protozero::proto_utils::FieldMetadata<
      407,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      UfshcdClkGatingFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_UfshcdClkGating kUfshcdClkGating() { return {}; }
  template <typename T = UfshcdClkGatingFtraceEvent> T* set_ufshcd_clk_gating() {
    return BeginNestedMessage<T>(407);
  }


  using FieldMetadata_Console =
    ::protozero::proto_utils::FieldMetadata<
      408,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ConsoleFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Console kConsole() { return {}; }
  template <typename T = ConsoleFtraceEvent> T* set_console() {
    return BeginNestedMessage<T>(408);
  }


  using FieldMetadata_DrmVblankEvent =
    ::protozero::proto_utils::FieldMetadata<
      409,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DrmVblankEventFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DrmVblankEvent kDrmVblankEvent() { return {}; }
  template <typename T = DrmVblankEventFtraceEvent> T* set_drm_vblank_event() {
    return BeginNestedMessage<T>(409);
  }


  using FieldMetadata_DrmVblankEventDelivered =
    ::protozero::proto_utils::FieldMetadata<
      410,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DrmVblankEventDeliveredFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DrmVblankEventDelivered kDrmVblankEventDelivered() { return {}; }
  template <typename T = DrmVblankEventDeliveredFtraceEvent> T* set_drm_vblank_event_delivered() {
    return BeginNestedMessage<T>(410);
  }


  using FieldMetadata_DrmSchedJob =
    ::protozero::proto_utils::FieldMetadata<
      411,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DrmSchedJobFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DrmSchedJob kDrmSchedJob() { return {}; }
  template <typename T = DrmSchedJobFtraceEvent> T* set_drm_sched_job() {
    return BeginNestedMessage<T>(411);
  }


  using FieldMetadata_DrmRunJob =
    ::protozero::proto_utils::FieldMetadata<
      412,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DrmRunJobFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DrmRunJob kDrmRunJob() { return {}; }
  template <typename T = DrmRunJobFtraceEvent> T* set_drm_run_job() {
    return BeginNestedMessage<T>(412);
  }


  using FieldMetadata_DrmSchedProcessJob =
    ::protozero::proto_utils::FieldMetadata<
      413,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DrmSchedProcessJobFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DrmSchedProcessJob kDrmSchedProcessJob() { return {}; }
  template <typename T = DrmSchedProcessJobFtraceEvent> T* set_drm_sched_process_job() {
    return BeginNestedMessage<T>(413);
  }


  using FieldMetadata_DmaFenceInit =
    ::protozero::proto_utils::FieldMetadata<
      414,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DmaFenceInitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DmaFenceInit kDmaFenceInit() { return {}; }
  template <typename T = DmaFenceInitFtraceEvent> T* set_dma_fence_init() {
    return BeginNestedMessage<T>(414);
  }


  using FieldMetadata_DmaFenceEmit =
    ::protozero::proto_utils::FieldMetadata<
      415,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DmaFenceEmitFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DmaFenceEmit kDmaFenceEmit() { return {}; }
  template <typename T = DmaFenceEmitFtraceEvent> T* set_dma_fence_emit() {
    return BeginNestedMessage<T>(415);
  }


  using FieldMetadata_DmaFenceSignaled =
    ::protozero::proto_utils::FieldMetadata<
      416,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DmaFenceSignaledFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DmaFenceSignaled kDmaFenceSignaled() { return {}; }
  template <typename T = DmaFenceSignaledFtraceEvent> T* set_dma_fence_signaled() {
    return BeginNestedMessage<T>(416);
  }


  using FieldMetadata_DmaFenceWaitStart =
    ::protozero::proto_utils::FieldMetadata<
      417,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DmaFenceWaitStartFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DmaFenceWaitStart kDmaFenceWaitStart() { return {}; }
  template <typename T = DmaFenceWaitStartFtraceEvent> T* set_dma_fence_wait_start() {
    return BeginNestedMessage<T>(417);
  }


  using FieldMetadata_DmaFenceWaitEnd =
    ::protozero::proto_utils::FieldMetadata<
      418,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DmaFenceWaitEndFtraceEvent,
      FtraceEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DmaFenceWaitEnd kDmaFenceWaitEnd() { return {}; }
  template <typename T = DmaFenceWaitEndFtraceEvent> T* set_dma_fence_wait_end() {
    return BeginNestedMessage<T>(418);
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
