// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_FRAME_TIMELINE_EVENT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_FRAME_TIMELINE_EVENT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/field_writer.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class FrameTimelineEvent_ActualDisplayFrameStart;
class FrameTimelineEvent_ActualSurfaceFrameStart;
class FrameTimelineEvent_ExpectedDisplayFrameStart;
class FrameTimelineEvent_ExpectedSurfaceFrameStart;
class FrameTimelineEvent_FrameEnd;
enum FrameTimelineEvent_PredictionType : int32_t;
enum FrameTimelineEvent_PresentType : int32_t;

enum FrameTimelineEvent_JankType : int32_t {
  FrameTimelineEvent_JankType_JANK_UNSPECIFIED = 0,
  FrameTimelineEvent_JankType_JANK_NONE = 1,
  FrameTimelineEvent_JankType_JANK_SF_SCHEDULING = 2,
  FrameTimelineEvent_JankType_JANK_PREDICTION_ERROR = 4,
  FrameTimelineEvent_JankType_JANK_DISPLAY_HAL = 8,
  FrameTimelineEvent_JankType_JANK_SF_CPU_DEADLINE_MISSED = 16,
  FrameTimelineEvent_JankType_JANK_SF_GPU_DEADLINE_MISSED = 32,
  FrameTimelineEvent_JankType_JANK_APP_DEADLINE_MISSED = 64,
  FrameTimelineEvent_JankType_JANK_BUFFER_STUFFING = 128,
  FrameTimelineEvent_JankType_JANK_UNKNOWN = 256,
  FrameTimelineEvent_JankType_JANK_SF_STUFFING = 512,
};

const FrameTimelineEvent_JankType FrameTimelineEvent_JankType_MIN = FrameTimelineEvent_JankType_JANK_UNSPECIFIED;
const FrameTimelineEvent_JankType FrameTimelineEvent_JankType_MAX = FrameTimelineEvent_JankType_JANK_SF_STUFFING;

enum FrameTimelineEvent_PresentType : int32_t {
  FrameTimelineEvent_PresentType_PRESENT_UNSPECIFIED = 0,
  FrameTimelineEvent_PresentType_PRESENT_ON_TIME = 1,
  FrameTimelineEvent_PresentType_PRESENT_LATE = 2,
  FrameTimelineEvent_PresentType_PRESENT_EARLY = 3,
  FrameTimelineEvent_PresentType_PRESENT_DROPPED = 4,
  FrameTimelineEvent_PresentType_PRESENT_UNKNOWN = 5,
};

const FrameTimelineEvent_PresentType FrameTimelineEvent_PresentType_MIN = FrameTimelineEvent_PresentType_PRESENT_UNSPECIFIED;
const FrameTimelineEvent_PresentType FrameTimelineEvent_PresentType_MAX = FrameTimelineEvent_PresentType_PRESENT_UNKNOWN;

enum FrameTimelineEvent_PredictionType : int32_t {
  FrameTimelineEvent_PredictionType_PREDICTION_UNSPECIFIED = 0,
  FrameTimelineEvent_PredictionType_PREDICTION_VALID = 1,
  FrameTimelineEvent_PredictionType_PREDICTION_EXPIRED = 2,
  FrameTimelineEvent_PredictionType_PREDICTION_UNKNOWN = 3,
};

const FrameTimelineEvent_PredictionType FrameTimelineEvent_PredictionType_MIN = FrameTimelineEvent_PredictionType_PREDICTION_UNSPECIFIED;
const FrameTimelineEvent_PredictionType FrameTimelineEvent_PredictionType_MAX = FrameTimelineEvent_PredictionType_PREDICTION_UNKNOWN;

class FrameTimelineEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  FrameTimelineEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FrameTimelineEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FrameTimelineEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_expected_display_frame_start() const { return at<1>().valid(); }
  ::protozero::ConstBytes expected_display_frame_start() const { return at<1>().as_bytes(); }
  bool has_actual_display_frame_start() const { return at<2>().valid(); }
  ::protozero::ConstBytes actual_display_frame_start() const { return at<2>().as_bytes(); }
  bool has_expected_surface_frame_start() const { return at<3>().valid(); }
  ::protozero::ConstBytes expected_surface_frame_start() const { return at<3>().as_bytes(); }
  bool has_actual_surface_frame_start() const { return at<4>().valid(); }
  ::protozero::ConstBytes actual_surface_frame_start() const { return at<4>().as_bytes(); }
  bool has_frame_end() const { return at<5>().valid(); }
  ::protozero::ConstBytes frame_end() const { return at<5>().as_bytes(); }
};

class FrameTimelineEvent : public ::protozero::Message {
 public:
  using Decoder = FrameTimelineEvent_Decoder;
  enum : int32_t {
    kExpectedDisplayFrameStartFieldNumber = 1,
    kActualDisplayFrameStartFieldNumber = 2,
    kExpectedSurfaceFrameStartFieldNumber = 3,
    kActualSurfaceFrameStartFieldNumber = 4,
    kFrameEndFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.FrameTimelineEvent"; }

  using ExpectedSurfaceFrameStart = ::perfetto::protos::pbzero::FrameTimelineEvent_ExpectedSurfaceFrameStart;
  using ActualSurfaceFrameStart = ::perfetto::protos::pbzero::FrameTimelineEvent_ActualSurfaceFrameStart;
  using ExpectedDisplayFrameStart = ::perfetto::protos::pbzero::FrameTimelineEvent_ExpectedDisplayFrameStart;
  using ActualDisplayFrameStart = ::perfetto::protos::pbzero::FrameTimelineEvent_ActualDisplayFrameStart;
  using FrameEnd = ::perfetto::protos::pbzero::FrameTimelineEvent_FrameEnd;
  using JankType = ::perfetto::protos::pbzero::FrameTimelineEvent_JankType;
  using PresentType = ::perfetto::protos::pbzero::FrameTimelineEvent_PresentType;
  using PredictionType = ::perfetto::protos::pbzero::FrameTimelineEvent_PredictionType;
  static const JankType JANK_UNSPECIFIED = FrameTimelineEvent_JankType_JANK_UNSPECIFIED;
  static const JankType JANK_NONE = FrameTimelineEvent_JankType_JANK_NONE;
  static const JankType JANK_SF_SCHEDULING = FrameTimelineEvent_JankType_JANK_SF_SCHEDULING;
  static const JankType JANK_PREDICTION_ERROR = FrameTimelineEvent_JankType_JANK_PREDICTION_ERROR;
  static const JankType JANK_DISPLAY_HAL = FrameTimelineEvent_JankType_JANK_DISPLAY_HAL;
  static const JankType JANK_SF_CPU_DEADLINE_MISSED = FrameTimelineEvent_JankType_JANK_SF_CPU_DEADLINE_MISSED;
  static const JankType JANK_SF_GPU_DEADLINE_MISSED = FrameTimelineEvent_JankType_JANK_SF_GPU_DEADLINE_MISSED;
  static const JankType JANK_APP_DEADLINE_MISSED = FrameTimelineEvent_JankType_JANK_APP_DEADLINE_MISSED;
  static const JankType JANK_BUFFER_STUFFING = FrameTimelineEvent_JankType_JANK_BUFFER_STUFFING;
  static const JankType JANK_UNKNOWN = FrameTimelineEvent_JankType_JANK_UNKNOWN;
  static const JankType JANK_SF_STUFFING = FrameTimelineEvent_JankType_JANK_SF_STUFFING;
  static const PresentType PRESENT_UNSPECIFIED = FrameTimelineEvent_PresentType_PRESENT_UNSPECIFIED;
  static const PresentType PRESENT_ON_TIME = FrameTimelineEvent_PresentType_PRESENT_ON_TIME;
  static const PresentType PRESENT_LATE = FrameTimelineEvent_PresentType_PRESENT_LATE;
  static const PresentType PRESENT_EARLY = FrameTimelineEvent_PresentType_PRESENT_EARLY;
  static const PresentType PRESENT_DROPPED = FrameTimelineEvent_PresentType_PRESENT_DROPPED;
  static const PresentType PRESENT_UNKNOWN = FrameTimelineEvent_PresentType_PRESENT_UNKNOWN;
  static const PredictionType PREDICTION_UNSPECIFIED = FrameTimelineEvent_PredictionType_PREDICTION_UNSPECIFIED;
  static const PredictionType PREDICTION_VALID = FrameTimelineEvent_PredictionType_PREDICTION_VALID;
  static const PredictionType PREDICTION_EXPIRED = FrameTimelineEvent_PredictionType_PREDICTION_EXPIRED;
  static const PredictionType PREDICTION_UNKNOWN = FrameTimelineEvent_PredictionType_PREDICTION_UNKNOWN;

  using FieldMetadata_ExpectedDisplayFrameStart =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      FrameTimelineEvent_ExpectedDisplayFrameStart,
      FrameTimelineEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ExpectedDisplayFrameStart kExpectedDisplayFrameStart() { return {}; }
  template <typename T = FrameTimelineEvent_ExpectedDisplayFrameStart> T* set_expected_display_frame_start() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_ActualDisplayFrameStart =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      FrameTimelineEvent_ActualDisplayFrameStart,
      FrameTimelineEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ActualDisplayFrameStart kActualDisplayFrameStart() { return {}; }
  template <typename T = FrameTimelineEvent_ActualDisplayFrameStart> T* set_actual_display_frame_start() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_ExpectedSurfaceFrameStart =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      FrameTimelineEvent_ExpectedSurfaceFrameStart,
      FrameTimelineEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ExpectedSurfaceFrameStart kExpectedSurfaceFrameStart() { return {}; }
  template <typename T = FrameTimelineEvent_ExpectedSurfaceFrameStart> T* set_expected_surface_frame_start() {
    return BeginNestedMessage<T>(3);
  }


  using FieldMetadata_ActualSurfaceFrameStart =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      FrameTimelineEvent_ActualSurfaceFrameStart,
      FrameTimelineEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ActualSurfaceFrameStart kActualSurfaceFrameStart() { return {}; }
  template <typename T = FrameTimelineEvent_ActualSurfaceFrameStart> T* set_actual_surface_frame_start() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_FrameEnd =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      FrameTimelineEvent_FrameEnd,
      FrameTimelineEvent>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FrameEnd kFrameEnd() { return {}; }
  template <typename T = FrameTimelineEvent_FrameEnd> T* set_frame_end() {
    return BeginNestedMessage<T>(5);
  }

};

class FrameTimelineEvent_FrameEnd_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  FrameTimelineEvent_FrameEnd_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FrameTimelineEvent_FrameEnd_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FrameTimelineEvent_FrameEnd_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_cookie() const { return at<1>().valid(); }
  int64_t cookie() const { return at<1>().as_int64(); }
};

class FrameTimelineEvent_FrameEnd : public ::protozero::Message {
 public:
  using Decoder = FrameTimelineEvent_FrameEnd_Decoder;
  enum : int32_t {
    kCookieFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.FrameTimelineEvent.FrameEnd"; }


  using FieldMetadata_Cookie =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      FrameTimelineEvent_FrameEnd>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Cookie kCookie() { return {}; }
  void set_cookie(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Cookie::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }
};

class FrameTimelineEvent_ActualDisplayFrameStart_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  FrameTimelineEvent_ActualDisplayFrameStart_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FrameTimelineEvent_ActualDisplayFrameStart_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FrameTimelineEvent_ActualDisplayFrameStart_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_cookie() const { return at<1>().valid(); }
  int64_t cookie() const { return at<1>().as_int64(); }
  bool has_token() const { return at<2>().valid(); }
  int64_t token() const { return at<2>().as_int64(); }
  bool has_pid() const { return at<3>().valid(); }
  int32_t pid() const { return at<3>().as_int32(); }
  bool has_present_type() const { return at<4>().valid(); }
  int32_t present_type() const { return at<4>().as_int32(); }
  bool has_on_time_finish() const { return at<5>().valid(); }
  bool on_time_finish() const { return at<5>().as_bool(); }
  bool has_gpu_composition() const { return at<6>().valid(); }
  bool gpu_composition() const { return at<6>().as_bool(); }
  bool has_jank_type() const { return at<7>().valid(); }
  int32_t jank_type() const { return at<7>().as_int32(); }
  bool has_prediction_type() const { return at<8>().valid(); }
  int32_t prediction_type() const { return at<8>().as_int32(); }
};

class FrameTimelineEvent_ActualDisplayFrameStart : public ::protozero::Message {
 public:
  using Decoder = FrameTimelineEvent_ActualDisplayFrameStart_Decoder;
  enum : int32_t {
    kCookieFieldNumber = 1,
    kTokenFieldNumber = 2,
    kPidFieldNumber = 3,
    kPresentTypeFieldNumber = 4,
    kOnTimeFinishFieldNumber = 5,
    kGpuCompositionFieldNumber = 6,
    kJankTypeFieldNumber = 7,
    kPredictionTypeFieldNumber = 8,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.FrameTimelineEvent.ActualDisplayFrameStart"; }


  using FieldMetadata_Cookie =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      FrameTimelineEvent_ActualDisplayFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Cookie kCookie() { return {}; }
  void set_cookie(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Cookie::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Token =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      FrameTimelineEvent_ActualDisplayFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Token kToken() { return {}; }
  void set_token(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Token::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Pid =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      FrameTimelineEvent_ActualDisplayFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Pid kPid() { return {}; }
  void set_pid(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Pid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_PresentType =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::FrameTimelineEvent_PresentType,
      FrameTimelineEvent_ActualDisplayFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_PresentType kPresentType() { return {}; }
  void set_present_type(::perfetto::protos::pbzero::FrameTimelineEvent_PresentType value) {
    static constexpr uint32_t field_id = FieldMetadata_PresentType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_OnTimeFinish =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      FrameTimelineEvent_ActualDisplayFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_OnTimeFinish kOnTimeFinish() { return {}; }
  void set_on_time_finish(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_OnTimeFinish::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_GpuComposition =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      FrameTimelineEvent_ActualDisplayFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_GpuComposition kGpuComposition() { return {}; }
  void set_gpu_composition(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_GpuComposition::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_JankType =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      FrameTimelineEvent_ActualDisplayFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_JankType kJankType() { return {}; }
  void set_jank_type(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_JankType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_PredictionType =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::FrameTimelineEvent_PredictionType,
      FrameTimelineEvent_ActualDisplayFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_PredictionType kPredictionType() { return {}; }
  void set_prediction_type(::perfetto::protos::pbzero::FrameTimelineEvent_PredictionType value) {
    static constexpr uint32_t field_id = FieldMetadata_PredictionType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }
};

class FrameTimelineEvent_ExpectedDisplayFrameStart_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  FrameTimelineEvent_ExpectedDisplayFrameStart_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FrameTimelineEvent_ExpectedDisplayFrameStart_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FrameTimelineEvent_ExpectedDisplayFrameStart_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_cookie() const { return at<1>().valid(); }
  int64_t cookie() const { return at<1>().as_int64(); }
  bool has_token() const { return at<2>().valid(); }
  int64_t token() const { return at<2>().as_int64(); }
  bool has_pid() const { return at<3>().valid(); }
  int32_t pid() const { return at<3>().as_int32(); }
};

class FrameTimelineEvent_ExpectedDisplayFrameStart : public ::protozero::Message {
 public:
  using Decoder = FrameTimelineEvent_ExpectedDisplayFrameStart_Decoder;
  enum : int32_t {
    kCookieFieldNumber = 1,
    kTokenFieldNumber = 2,
    kPidFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.FrameTimelineEvent.ExpectedDisplayFrameStart"; }


  using FieldMetadata_Cookie =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      FrameTimelineEvent_ExpectedDisplayFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Cookie kCookie() { return {}; }
  void set_cookie(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Cookie::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Token =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      FrameTimelineEvent_ExpectedDisplayFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Token kToken() { return {}; }
  void set_token(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Token::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Pid =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      FrameTimelineEvent_ExpectedDisplayFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Pid kPid() { return {}; }
  void set_pid(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Pid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class FrameTimelineEvent_ActualSurfaceFrameStart_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/11, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  FrameTimelineEvent_ActualSurfaceFrameStart_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FrameTimelineEvent_ActualSurfaceFrameStart_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FrameTimelineEvent_ActualSurfaceFrameStart_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_cookie() const { return at<1>().valid(); }
  int64_t cookie() const { return at<1>().as_int64(); }
  bool has_token() const { return at<2>().valid(); }
  int64_t token() const { return at<2>().as_int64(); }
  bool has_display_frame_token() const { return at<3>().valid(); }
  int64_t display_frame_token() const { return at<3>().as_int64(); }
  bool has_pid() const { return at<4>().valid(); }
  int32_t pid() const { return at<4>().as_int32(); }
  bool has_layer_name() const { return at<5>().valid(); }
  ::protozero::ConstChars layer_name() const { return at<5>().as_string(); }
  bool has_present_type() const { return at<6>().valid(); }
  int32_t present_type() const { return at<6>().as_int32(); }
  bool has_on_time_finish() const { return at<7>().valid(); }
  bool on_time_finish() const { return at<7>().as_bool(); }
  bool has_gpu_composition() const { return at<8>().valid(); }
  bool gpu_composition() const { return at<8>().as_bool(); }
  bool has_jank_type() const { return at<9>().valid(); }
  int32_t jank_type() const { return at<9>().as_int32(); }
  bool has_prediction_type() const { return at<10>().valid(); }
  int32_t prediction_type() const { return at<10>().as_int32(); }
  bool has_is_buffer() const { return at<11>().valid(); }
  bool is_buffer() const { return at<11>().as_bool(); }
};

class FrameTimelineEvent_ActualSurfaceFrameStart : public ::protozero::Message {
 public:
  using Decoder = FrameTimelineEvent_ActualSurfaceFrameStart_Decoder;
  enum : int32_t {
    kCookieFieldNumber = 1,
    kTokenFieldNumber = 2,
    kDisplayFrameTokenFieldNumber = 3,
    kPidFieldNumber = 4,
    kLayerNameFieldNumber = 5,
    kPresentTypeFieldNumber = 6,
    kOnTimeFinishFieldNumber = 7,
    kGpuCompositionFieldNumber = 8,
    kJankTypeFieldNumber = 9,
    kPredictionTypeFieldNumber = 10,
    kIsBufferFieldNumber = 11,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.FrameTimelineEvent.ActualSurfaceFrameStart"; }


  using FieldMetadata_Cookie =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      FrameTimelineEvent_ActualSurfaceFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Cookie kCookie() { return {}; }
  void set_cookie(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Cookie::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Token =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      FrameTimelineEvent_ActualSurfaceFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Token kToken() { return {}; }
  void set_token(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Token::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DisplayFrameToken =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      FrameTimelineEvent_ActualSurfaceFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DisplayFrameToken kDisplayFrameToken() { return {}; }
  void set_display_frame_token(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_DisplayFrameToken::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Pid =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      FrameTimelineEvent_ActualSurfaceFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Pid kPid() { return {}; }
  void set_pid(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Pid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_LayerName =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      FrameTimelineEvent_ActualSurfaceFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_LayerName kLayerName() { return {}; }
  void set_layer_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_LayerName::kFieldId, data, size);
  }
  void set_layer_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_LayerName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_PresentType =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::FrameTimelineEvent_PresentType,
      FrameTimelineEvent_ActualSurfaceFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_PresentType kPresentType() { return {}; }
  void set_present_type(::perfetto::protos::pbzero::FrameTimelineEvent_PresentType value) {
    static constexpr uint32_t field_id = FieldMetadata_PresentType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_OnTimeFinish =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      FrameTimelineEvent_ActualSurfaceFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_OnTimeFinish kOnTimeFinish() { return {}; }
  void set_on_time_finish(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_OnTimeFinish::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_GpuComposition =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      FrameTimelineEvent_ActualSurfaceFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_GpuComposition kGpuComposition() { return {}; }
  void set_gpu_composition(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_GpuComposition::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_JankType =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      FrameTimelineEvent_ActualSurfaceFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_JankType kJankType() { return {}; }
  void set_jank_type(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_JankType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_PredictionType =
    ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::FrameTimelineEvent_PredictionType,
      FrameTimelineEvent_ActualSurfaceFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_PredictionType kPredictionType() { return {}; }
  void set_prediction_type(::perfetto::protos::pbzero::FrameTimelineEvent_PredictionType value) {
    static constexpr uint32_t field_id = FieldMetadata_PredictionType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsBuffer =
    ::protozero::proto_utils::FieldMetadata<
      11,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      FrameTimelineEvent_ActualSurfaceFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsBuffer kIsBuffer() { return {}; }
  void set_is_buffer(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsBuffer::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class FrameTimelineEvent_ExpectedSurfaceFrameStart_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  FrameTimelineEvent_ExpectedSurfaceFrameStart_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FrameTimelineEvent_ExpectedSurfaceFrameStart_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FrameTimelineEvent_ExpectedSurfaceFrameStart_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_cookie() const { return at<1>().valid(); }
  int64_t cookie() const { return at<1>().as_int64(); }
  bool has_token() const { return at<2>().valid(); }
  int64_t token() const { return at<2>().as_int64(); }
  bool has_display_frame_token() const { return at<3>().valid(); }
  int64_t display_frame_token() const { return at<3>().as_int64(); }
  bool has_pid() const { return at<4>().valid(); }
  int32_t pid() const { return at<4>().as_int32(); }
  bool has_layer_name() const { return at<5>().valid(); }
  ::protozero::ConstChars layer_name() const { return at<5>().as_string(); }
};

class FrameTimelineEvent_ExpectedSurfaceFrameStart : public ::protozero::Message {
 public:
  using Decoder = FrameTimelineEvent_ExpectedSurfaceFrameStart_Decoder;
  enum : int32_t {
    kCookieFieldNumber = 1,
    kTokenFieldNumber = 2,
    kDisplayFrameTokenFieldNumber = 3,
    kPidFieldNumber = 4,
    kLayerNameFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.FrameTimelineEvent.ExpectedSurfaceFrameStart"; }


  using FieldMetadata_Cookie =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      FrameTimelineEvent_ExpectedSurfaceFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Cookie kCookie() { return {}; }
  void set_cookie(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Cookie::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Token =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      FrameTimelineEvent_ExpectedSurfaceFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Token kToken() { return {}; }
  void set_token(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Token::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DisplayFrameToken =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      FrameTimelineEvent_ExpectedSurfaceFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DisplayFrameToken kDisplayFrameToken() { return {}; }
  void set_display_frame_token(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_DisplayFrameToken::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Pid =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      FrameTimelineEvent_ExpectedSurfaceFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Pid kPid() { return {}; }
  void set_pid(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Pid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_LayerName =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      FrameTimelineEvent_ExpectedSurfaceFrameStart>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_LayerName kLayerName() { return {}; }
  void set_layer_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_LayerName::kFieldId, data, size);
  }
  void set_layer_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_LayerName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
